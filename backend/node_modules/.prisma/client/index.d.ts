
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model WebAuthnCredential
 * 
 */
export type WebAuthnCredential = $Result.DefaultSelection<Prisma.$WebAuthnCredentialPayload>
/**
 * Model PatientProfile
 * 
 */
export type PatientProfile = $Result.DefaultSelection<Prisma.$PatientProfilePayload>
/**
 * Model Representative
 * 
 */
export type Representative = $Result.DefaultSelection<Prisma.$RepresentativePayload>
/**
 * Model AdvanceDirective
 * 
 */
export type AdvanceDirective = $Result.DefaultSelection<Prisma.$AdvanceDirectivePayload>
/**
 * Model Witness
 * 
 */
export type Witness = $Result.DefaultSelection<Prisma.$WitnessPayload>
/**
 * Model EmergencyAccess
 * 
 */
export type EmergencyAccess = $Result.DefaultSelection<Prisma.$EmergencyAccessPayload>
/**
 * Model MedicalInstitution
 * 
 */
export type MedicalInstitution = $Result.DefaultSelection<Prisma.$MedicalInstitutionPayload>
/**
 * Model InsuranceCompany
 * 
 */
export type InsuranceCompany = $Result.DefaultSelection<Prisma.$InsuranceCompanyPayload>
/**
 * Model InsurancePlan
 * 
 */
export type InsurancePlan = $Result.DefaultSelection<Prisma.$InsurancePlanPayload>
/**
 * Model MedicalStaff
 * 
 */
export type MedicalStaff = $Result.DefaultSelection<Prisma.$MedicalStaffPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model StateLegalTemplate
 * 
 */
export type StateLegalTemplate = $Result.DefaultSelection<Prisma.$StateLegalTemplatePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model PanicAlert
 * 
 */
export type PanicAlert = $Result.DefaultSelection<Prisma.$PanicAlertPayload>
/**
 * Model AdminUser
 * 
 */
export type AdminUser = $Result.DefaultSelection<Prisma.$AdminUserPayload>
/**
 * Model AdminSession
 * 
 */
export type AdminSession = $Result.DefaultSelection<Prisma.$AdminSessionPayload>
/**
 * Model AdminAuditLog
 * 
 */
export type AdminAuditLog = $Result.DefaultSelection<Prisma.$AdminAuditLogPayload>
/**
 * Model SubscriptionPlan
 * 
 */
export type SubscriptionPlan = $Result.DefaultSelection<Prisma.$SubscriptionPlanPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model PaymentMethod
 * 
 */
export type PaymentMethod = $Result.DefaultSelection<Prisma.$PaymentMethodPayload>
/**
 * Model FiscalData
 * 
 */
export type FiscalData = $Result.DefaultSelection<Prisma.$FiscalDataPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const DirectiveType: {
  NOTARIZED_DOCUMENT: 'NOTARIZED_DOCUMENT',
  DIGITAL_DRAFT: 'DIGITAL_DRAFT',
  DIGITAL_WITNESSED: 'DIGITAL_WITNESSED'
};

export type DirectiveType = (typeof DirectiveType)[keyof typeof DirectiveType]


export const DirectiveStatus: {
  DRAFT: 'DRAFT',
  PENDING_VALIDATION: 'PENDING_VALIDATION',
  ACTIVE: 'ACTIVE',
  REVOKED: 'REVOKED',
  EXPIRED: 'EXPIRED'
};

export type DirectiveStatus = (typeof DirectiveStatus)[keyof typeof DirectiveStatus]


export const InstitutionType: {
  HOSPITAL_PUBLIC: 'HOSPITAL_PUBLIC',
  HOSPITAL_PRIVATE: 'HOSPITAL_PRIVATE',
  CLINIC: 'CLINIC',
  AMBULANCE_SERVICE: 'AMBULANCE_SERVICE',
  IMSS: 'IMSS',
  ISSSTE: 'ISSSTE',
  OTHER: 'OTHER'
};

export type InstitutionType = (typeof InstitutionType)[keyof typeof InstitutionType]


export const AttentionLevel: {
  FIRST: 'FIRST',
  SECOND: 'SECOND',
  THIRD: 'THIRD'
};

export type AttentionLevel = (typeof AttentionLevel)[keyof typeof AttentionLevel]


export const InsuranceType: {
  HEALTH: 'HEALTH',
  LIFE: 'LIFE',
  ACCIDENT: 'ACCIDENT',
  HEALTH_LIFE: 'HEALTH_LIFE',
  GOVERNMENT: 'GOVERNMENT',
  OTHER: 'OTHER'
};

export type InsuranceType = (typeof InsuranceType)[keyof typeof InsuranceType]


export const StaffRole: {
  ADMIN: 'ADMIN',
  DOCTOR: 'DOCTOR',
  PARAMEDIC: 'PARAMEDIC',
  NURSE: 'NURSE',
  EMERGENCY_TECH: 'EMERGENCY_TECH'
};

export type StaffRole = (typeof StaffRole)[keyof typeof StaffRole]


export const NotificationType: {
  VERIFICATION_EMAIL: 'VERIFICATION_EMAIL',
  VERIFICATION_SMS: 'VERIFICATION_SMS',
  PASSWORD_RESET: 'PASSWORD_RESET',
  EMERGENCY_ALERT: 'EMERGENCY_ALERT',
  ACCESS_NOTIFICATION: 'ACCESS_NOTIFICATION',
  DIRECTIVE_REMINDER: 'DIRECTIVE_REMINDER',
  SYSTEM_ALERT: 'SYSTEM_ALERT'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const NotificationChannel: {
  EMAIL: 'EMAIL',
  SMS: 'SMS',
  PUSH: 'PUSH'
};

export type NotificationChannel = (typeof NotificationChannel)[keyof typeof NotificationChannel]


export const NotificationStatus: {
  PENDING: 'PENDING',
  SENT: 'SENT',
  DELIVERED: 'DELIVERED',
  FAILED: 'FAILED'
};

export type NotificationStatus = (typeof NotificationStatus)[keyof typeof NotificationStatus]


export const PanicStatus: {
  ACTIVE: 'ACTIVE',
  CANCELLED: 'CANCELLED',
  RESOLVED: 'RESOLVED',
  EXPIRED: 'EXPIRED'
};

export type PanicStatus = (typeof PanicStatus)[keyof typeof PanicStatus]


export const AdminRole: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  MODERATOR: 'MODERATOR',
  VIEWER: 'VIEWER',
  SUPPORT: 'SUPPORT'
};

export type AdminRole = (typeof AdminRole)[keyof typeof AdminRole]


export const BillingCycle: {
  MONTHLY: 'MONTHLY',
  ANNUAL: 'ANNUAL'
};

export type BillingCycle = (typeof BillingCycle)[keyof typeof BillingCycle]


export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  TRIALING: 'TRIALING',
  PAST_DUE: 'PAST_DUE',
  CANCELED: 'CANCELED',
  UNPAID: 'UNPAID',
  INCOMPLETE: 'INCOMPLETE',
  PAUSED: 'PAUSED'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const PaymentMethodType: {
  CARD: 'CARD',
  OXXO: 'OXXO'
};

export type PaymentMethodType = (typeof PaymentMethodType)[keyof typeof PaymentMethodType]


export const PaymentStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  REQUIRES_ACTION: 'REQUIRES_ACTION',
  SUCCEEDED: 'SUCCEEDED',
  FAILED: 'FAILED',
  CANCELED: 'CANCELED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const InvoiceStatus: {
  PENDING: 'PENDING',
  ISSUED: 'ISSUED',
  SENT: 'SENT',
  CANCELLED: 'CANCELLED',
  ERROR: 'ERROR'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]

}

export type DirectiveType = $Enums.DirectiveType

export const DirectiveType: typeof $Enums.DirectiveType

export type DirectiveStatus = $Enums.DirectiveStatus

export const DirectiveStatus: typeof $Enums.DirectiveStatus

export type InstitutionType = $Enums.InstitutionType

export const InstitutionType: typeof $Enums.InstitutionType

export type AttentionLevel = $Enums.AttentionLevel

export const AttentionLevel: typeof $Enums.AttentionLevel

export type InsuranceType = $Enums.InsuranceType

export const InsuranceType: typeof $Enums.InsuranceType

export type StaffRole = $Enums.StaffRole

export const StaffRole: typeof $Enums.StaffRole

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type NotificationChannel = $Enums.NotificationChannel

export const NotificationChannel: typeof $Enums.NotificationChannel

export type NotificationStatus = $Enums.NotificationStatus

export const NotificationStatus: typeof $Enums.NotificationStatus

export type PanicStatus = $Enums.PanicStatus

export const PanicStatus: typeof $Enums.PanicStatus

export type AdminRole = $Enums.AdminRole

export const AdminRole: typeof $Enums.AdminRole

export type BillingCycle = $Enums.BillingCycle

export const BillingCycle: typeof $Enums.BillingCycle

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type PaymentMethodType = $Enums.PaymentMethodType

export const PaymentMethodType: typeof $Enums.PaymentMethodType

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.webAuthnCredential`: Exposes CRUD operations for the **WebAuthnCredential** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebAuthnCredentials
    * const webAuthnCredentials = await prisma.webAuthnCredential.findMany()
    * ```
    */
  get webAuthnCredential(): Prisma.WebAuthnCredentialDelegate<ExtArgs>;

  /**
   * `prisma.patientProfile`: Exposes CRUD operations for the **PatientProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PatientProfiles
    * const patientProfiles = await prisma.patientProfile.findMany()
    * ```
    */
  get patientProfile(): Prisma.PatientProfileDelegate<ExtArgs>;

  /**
   * `prisma.representative`: Exposes CRUD operations for the **Representative** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Representatives
    * const representatives = await prisma.representative.findMany()
    * ```
    */
  get representative(): Prisma.RepresentativeDelegate<ExtArgs>;

  /**
   * `prisma.advanceDirective`: Exposes CRUD operations for the **AdvanceDirective** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdvanceDirectives
    * const advanceDirectives = await prisma.advanceDirective.findMany()
    * ```
    */
  get advanceDirective(): Prisma.AdvanceDirectiveDelegate<ExtArgs>;

  /**
   * `prisma.witness`: Exposes CRUD operations for the **Witness** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Witnesses
    * const witnesses = await prisma.witness.findMany()
    * ```
    */
  get witness(): Prisma.WitnessDelegate<ExtArgs>;

  /**
   * `prisma.emergencyAccess`: Exposes CRUD operations for the **EmergencyAccess** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmergencyAccesses
    * const emergencyAccesses = await prisma.emergencyAccess.findMany()
    * ```
    */
  get emergencyAccess(): Prisma.EmergencyAccessDelegate<ExtArgs>;

  /**
   * `prisma.medicalInstitution`: Exposes CRUD operations for the **MedicalInstitution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalInstitutions
    * const medicalInstitutions = await prisma.medicalInstitution.findMany()
    * ```
    */
  get medicalInstitution(): Prisma.MedicalInstitutionDelegate<ExtArgs>;

  /**
   * `prisma.insuranceCompany`: Exposes CRUD operations for the **InsuranceCompany** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InsuranceCompanies
    * const insuranceCompanies = await prisma.insuranceCompany.findMany()
    * ```
    */
  get insuranceCompany(): Prisma.InsuranceCompanyDelegate<ExtArgs>;

  /**
   * `prisma.insurancePlan`: Exposes CRUD operations for the **InsurancePlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InsurancePlans
    * const insurancePlans = await prisma.insurancePlan.findMany()
    * ```
    */
  get insurancePlan(): Prisma.InsurancePlanDelegate<ExtArgs>;

  /**
   * `prisma.medicalStaff`: Exposes CRUD operations for the **MedicalStaff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalStaffs
    * const medicalStaffs = await prisma.medicalStaff.findMany()
    * ```
    */
  get medicalStaff(): Prisma.MedicalStaffDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.stateLegalTemplate`: Exposes CRUD operations for the **StateLegalTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StateLegalTemplates
    * const stateLegalTemplates = await prisma.stateLegalTemplate.findMany()
    * ```
    */
  get stateLegalTemplate(): Prisma.StateLegalTemplateDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.panicAlert`: Exposes CRUD operations for the **PanicAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PanicAlerts
    * const panicAlerts = await prisma.panicAlert.findMany()
    * ```
    */
  get panicAlert(): Prisma.PanicAlertDelegate<ExtArgs>;

  /**
   * `prisma.adminUser`: Exposes CRUD operations for the **AdminUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminUsers
    * const adminUsers = await prisma.adminUser.findMany()
    * ```
    */
  get adminUser(): Prisma.AdminUserDelegate<ExtArgs>;

  /**
   * `prisma.adminSession`: Exposes CRUD operations for the **AdminSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminSessions
    * const adminSessions = await prisma.adminSession.findMany()
    * ```
    */
  get adminSession(): Prisma.AdminSessionDelegate<ExtArgs>;

  /**
   * `prisma.adminAuditLog`: Exposes CRUD operations for the **AdminAuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminAuditLogs
    * const adminAuditLogs = await prisma.adminAuditLog.findMany()
    * ```
    */
  get adminAuditLog(): Prisma.AdminAuditLogDelegate<ExtArgs>;

  /**
   * `prisma.subscriptionPlan`: Exposes CRUD operations for the **SubscriptionPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionPlans
    * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
    * ```
    */
  get subscriptionPlan(): Prisma.SubscriptionPlanDelegate<ExtArgs>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.paymentMethod`: Exposes CRUD operations for the **PaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentMethods
    * const paymentMethods = await prisma.paymentMethod.findMany()
    * ```
    */
  get paymentMethod(): Prisma.PaymentMethodDelegate<ExtArgs>;

  /**
   * `prisma.fiscalData`: Exposes CRUD operations for the **FiscalData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FiscalData
    * const fiscalData = await prisma.fiscalData.findMany()
    * ```
    */
  get fiscalData(): Prisma.FiscalDataDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    WebAuthnCredential: 'WebAuthnCredential',
    PatientProfile: 'PatientProfile',
    Representative: 'Representative',
    AdvanceDirective: 'AdvanceDirective',
    Witness: 'Witness',
    EmergencyAccess: 'EmergencyAccess',
    MedicalInstitution: 'MedicalInstitution',
    InsuranceCompany: 'InsuranceCompany',
    InsurancePlan: 'InsurancePlan',
    MedicalStaff: 'MedicalStaff',
    AuditLog: 'AuditLog',
    StateLegalTemplate: 'StateLegalTemplate',
    Notification: 'Notification',
    PanicAlert: 'PanicAlert',
    AdminUser: 'AdminUser',
    AdminSession: 'AdminSession',
    AdminAuditLog: 'AdminAuditLog',
    SubscriptionPlan: 'SubscriptionPlan',
    Subscription: 'Subscription',
    Payment: 'Payment',
    PaymentMethod: 'PaymentMethod',
    FiscalData: 'FiscalData',
    Invoice: 'Invoice'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "session" | "webAuthnCredential" | "patientProfile" | "representative" | "advanceDirective" | "witness" | "emergencyAccess" | "medicalInstitution" | "insuranceCompany" | "insurancePlan" | "medicalStaff" | "auditLog" | "stateLegalTemplate" | "notification" | "panicAlert" | "adminUser" | "adminSession" | "adminAuditLog" | "subscriptionPlan" | "subscription" | "payment" | "paymentMethod" | "fiscalData" | "invoice"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      WebAuthnCredential: {
        payload: Prisma.$WebAuthnCredentialPayload<ExtArgs>
        fields: Prisma.WebAuthnCredentialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebAuthnCredentialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebAuthnCredentialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebAuthnCredentialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebAuthnCredentialPayload>
          }
          findFirst: {
            args: Prisma.WebAuthnCredentialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebAuthnCredentialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebAuthnCredentialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebAuthnCredentialPayload>
          }
          findMany: {
            args: Prisma.WebAuthnCredentialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebAuthnCredentialPayload>[]
          }
          create: {
            args: Prisma.WebAuthnCredentialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebAuthnCredentialPayload>
          }
          createMany: {
            args: Prisma.WebAuthnCredentialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebAuthnCredentialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebAuthnCredentialPayload>[]
          }
          delete: {
            args: Prisma.WebAuthnCredentialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebAuthnCredentialPayload>
          }
          update: {
            args: Prisma.WebAuthnCredentialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebAuthnCredentialPayload>
          }
          deleteMany: {
            args: Prisma.WebAuthnCredentialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebAuthnCredentialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebAuthnCredentialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebAuthnCredentialPayload>
          }
          aggregate: {
            args: Prisma.WebAuthnCredentialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebAuthnCredential>
          }
          groupBy: {
            args: Prisma.WebAuthnCredentialGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebAuthnCredentialGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebAuthnCredentialCountArgs<ExtArgs>
            result: $Utils.Optional<WebAuthnCredentialCountAggregateOutputType> | number
          }
        }
      }
      PatientProfile: {
        payload: Prisma.$PatientProfilePayload<ExtArgs>
        fields: Prisma.PatientProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientProfilePayload>
          }
          findFirst: {
            args: Prisma.PatientProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientProfilePayload>
          }
          findMany: {
            args: Prisma.PatientProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientProfilePayload>[]
          }
          create: {
            args: Prisma.PatientProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientProfilePayload>
          }
          createMany: {
            args: Prisma.PatientProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientProfilePayload>[]
          }
          delete: {
            args: Prisma.PatientProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientProfilePayload>
          }
          update: {
            args: Prisma.PatientProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientProfilePayload>
          }
          deleteMany: {
            args: Prisma.PatientProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PatientProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientProfilePayload>
          }
          aggregate: {
            args: Prisma.PatientProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatientProfile>
          }
          groupBy: {
            args: Prisma.PatientProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientProfileCountArgs<ExtArgs>
            result: $Utils.Optional<PatientProfileCountAggregateOutputType> | number
          }
        }
      }
      Representative: {
        payload: Prisma.$RepresentativePayload<ExtArgs>
        fields: Prisma.RepresentativeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RepresentativeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepresentativePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RepresentativeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepresentativePayload>
          }
          findFirst: {
            args: Prisma.RepresentativeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepresentativePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RepresentativeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepresentativePayload>
          }
          findMany: {
            args: Prisma.RepresentativeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepresentativePayload>[]
          }
          create: {
            args: Prisma.RepresentativeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepresentativePayload>
          }
          createMany: {
            args: Prisma.RepresentativeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RepresentativeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepresentativePayload>[]
          }
          delete: {
            args: Prisma.RepresentativeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepresentativePayload>
          }
          update: {
            args: Prisma.RepresentativeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepresentativePayload>
          }
          deleteMany: {
            args: Prisma.RepresentativeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RepresentativeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RepresentativeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepresentativePayload>
          }
          aggregate: {
            args: Prisma.RepresentativeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRepresentative>
          }
          groupBy: {
            args: Prisma.RepresentativeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RepresentativeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RepresentativeCountArgs<ExtArgs>
            result: $Utils.Optional<RepresentativeCountAggregateOutputType> | number
          }
        }
      }
      AdvanceDirective: {
        payload: Prisma.$AdvanceDirectivePayload<ExtArgs>
        fields: Prisma.AdvanceDirectiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdvanceDirectiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvanceDirectivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdvanceDirectiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvanceDirectivePayload>
          }
          findFirst: {
            args: Prisma.AdvanceDirectiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvanceDirectivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdvanceDirectiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvanceDirectivePayload>
          }
          findMany: {
            args: Prisma.AdvanceDirectiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvanceDirectivePayload>[]
          }
          create: {
            args: Prisma.AdvanceDirectiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvanceDirectivePayload>
          }
          createMany: {
            args: Prisma.AdvanceDirectiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdvanceDirectiveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvanceDirectivePayload>[]
          }
          delete: {
            args: Prisma.AdvanceDirectiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvanceDirectivePayload>
          }
          update: {
            args: Prisma.AdvanceDirectiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvanceDirectivePayload>
          }
          deleteMany: {
            args: Prisma.AdvanceDirectiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdvanceDirectiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdvanceDirectiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvanceDirectivePayload>
          }
          aggregate: {
            args: Prisma.AdvanceDirectiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdvanceDirective>
          }
          groupBy: {
            args: Prisma.AdvanceDirectiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdvanceDirectiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdvanceDirectiveCountArgs<ExtArgs>
            result: $Utils.Optional<AdvanceDirectiveCountAggregateOutputType> | number
          }
        }
      }
      Witness: {
        payload: Prisma.$WitnessPayload<ExtArgs>
        fields: Prisma.WitnessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WitnessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WitnessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessPayload>
          }
          findFirst: {
            args: Prisma.WitnessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WitnessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessPayload>
          }
          findMany: {
            args: Prisma.WitnessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessPayload>[]
          }
          create: {
            args: Prisma.WitnessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessPayload>
          }
          createMany: {
            args: Prisma.WitnessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WitnessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessPayload>[]
          }
          delete: {
            args: Prisma.WitnessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessPayload>
          }
          update: {
            args: Prisma.WitnessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessPayload>
          }
          deleteMany: {
            args: Prisma.WitnessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WitnessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WitnessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessPayload>
          }
          aggregate: {
            args: Prisma.WitnessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWitness>
          }
          groupBy: {
            args: Prisma.WitnessGroupByArgs<ExtArgs>
            result: $Utils.Optional<WitnessGroupByOutputType>[]
          }
          count: {
            args: Prisma.WitnessCountArgs<ExtArgs>
            result: $Utils.Optional<WitnessCountAggregateOutputType> | number
          }
        }
      }
      EmergencyAccess: {
        payload: Prisma.$EmergencyAccessPayload<ExtArgs>
        fields: Prisma.EmergencyAccessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmergencyAccessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyAccessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmergencyAccessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyAccessPayload>
          }
          findFirst: {
            args: Prisma.EmergencyAccessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyAccessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmergencyAccessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyAccessPayload>
          }
          findMany: {
            args: Prisma.EmergencyAccessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyAccessPayload>[]
          }
          create: {
            args: Prisma.EmergencyAccessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyAccessPayload>
          }
          createMany: {
            args: Prisma.EmergencyAccessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmergencyAccessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyAccessPayload>[]
          }
          delete: {
            args: Prisma.EmergencyAccessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyAccessPayload>
          }
          update: {
            args: Prisma.EmergencyAccessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyAccessPayload>
          }
          deleteMany: {
            args: Prisma.EmergencyAccessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmergencyAccessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmergencyAccessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyAccessPayload>
          }
          aggregate: {
            args: Prisma.EmergencyAccessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmergencyAccess>
          }
          groupBy: {
            args: Prisma.EmergencyAccessGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmergencyAccessGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmergencyAccessCountArgs<ExtArgs>
            result: $Utils.Optional<EmergencyAccessCountAggregateOutputType> | number
          }
        }
      }
      MedicalInstitution: {
        payload: Prisma.$MedicalInstitutionPayload<ExtArgs>
        fields: Prisma.MedicalInstitutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicalInstitutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInstitutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalInstitutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInstitutionPayload>
          }
          findFirst: {
            args: Prisma.MedicalInstitutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInstitutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalInstitutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInstitutionPayload>
          }
          findMany: {
            args: Prisma.MedicalInstitutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInstitutionPayload>[]
          }
          create: {
            args: Prisma.MedicalInstitutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInstitutionPayload>
          }
          createMany: {
            args: Prisma.MedicalInstitutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicalInstitutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInstitutionPayload>[]
          }
          delete: {
            args: Prisma.MedicalInstitutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInstitutionPayload>
          }
          update: {
            args: Prisma.MedicalInstitutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInstitutionPayload>
          }
          deleteMany: {
            args: Prisma.MedicalInstitutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalInstitutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MedicalInstitutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInstitutionPayload>
          }
          aggregate: {
            args: Prisma.MedicalInstitutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicalInstitution>
          }
          groupBy: {
            args: Prisma.MedicalInstitutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicalInstitutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicalInstitutionCountArgs<ExtArgs>
            result: $Utils.Optional<MedicalInstitutionCountAggregateOutputType> | number
          }
        }
      }
      InsuranceCompany: {
        payload: Prisma.$InsuranceCompanyPayload<ExtArgs>
        fields: Prisma.InsuranceCompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InsuranceCompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceCompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InsuranceCompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceCompanyPayload>
          }
          findFirst: {
            args: Prisma.InsuranceCompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceCompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InsuranceCompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceCompanyPayload>
          }
          findMany: {
            args: Prisma.InsuranceCompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceCompanyPayload>[]
          }
          create: {
            args: Prisma.InsuranceCompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceCompanyPayload>
          }
          createMany: {
            args: Prisma.InsuranceCompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InsuranceCompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceCompanyPayload>[]
          }
          delete: {
            args: Prisma.InsuranceCompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceCompanyPayload>
          }
          update: {
            args: Prisma.InsuranceCompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceCompanyPayload>
          }
          deleteMany: {
            args: Prisma.InsuranceCompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InsuranceCompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InsuranceCompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceCompanyPayload>
          }
          aggregate: {
            args: Prisma.InsuranceCompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInsuranceCompany>
          }
          groupBy: {
            args: Prisma.InsuranceCompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<InsuranceCompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.InsuranceCompanyCountArgs<ExtArgs>
            result: $Utils.Optional<InsuranceCompanyCountAggregateOutputType> | number
          }
        }
      }
      InsurancePlan: {
        payload: Prisma.$InsurancePlanPayload<ExtArgs>
        fields: Prisma.InsurancePlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InsurancePlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InsurancePlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePlanPayload>
          }
          findFirst: {
            args: Prisma.InsurancePlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InsurancePlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePlanPayload>
          }
          findMany: {
            args: Prisma.InsurancePlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePlanPayload>[]
          }
          create: {
            args: Prisma.InsurancePlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePlanPayload>
          }
          createMany: {
            args: Prisma.InsurancePlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InsurancePlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePlanPayload>[]
          }
          delete: {
            args: Prisma.InsurancePlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePlanPayload>
          }
          update: {
            args: Prisma.InsurancePlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePlanPayload>
          }
          deleteMany: {
            args: Prisma.InsurancePlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InsurancePlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InsurancePlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePlanPayload>
          }
          aggregate: {
            args: Prisma.InsurancePlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInsurancePlan>
          }
          groupBy: {
            args: Prisma.InsurancePlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<InsurancePlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.InsurancePlanCountArgs<ExtArgs>
            result: $Utils.Optional<InsurancePlanCountAggregateOutputType> | number
          }
        }
      }
      MedicalStaff: {
        payload: Prisma.$MedicalStaffPayload<ExtArgs>
        fields: Prisma.MedicalStaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicalStaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalStaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStaffPayload>
          }
          findFirst: {
            args: Prisma.MedicalStaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalStaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStaffPayload>
          }
          findMany: {
            args: Prisma.MedicalStaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStaffPayload>[]
          }
          create: {
            args: Prisma.MedicalStaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStaffPayload>
          }
          createMany: {
            args: Prisma.MedicalStaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicalStaffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStaffPayload>[]
          }
          delete: {
            args: Prisma.MedicalStaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStaffPayload>
          }
          update: {
            args: Prisma.MedicalStaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStaffPayload>
          }
          deleteMany: {
            args: Prisma.MedicalStaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalStaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MedicalStaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStaffPayload>
          }
          aggregate: {
            args: Prisma.MedicalStaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicalStaff>
          }
          groupBy: {
            args: Prisma.MedicalStaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicalStaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicalStaffCountArgs<ExtArgs>
            result: $Utils.Optional<MedicalStaffCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      StateLegalTemplate: {
        payload: Prisma.$StateLegalTemplatePayload<ExtArgs>
        fields: Prisma.StateLegalTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StateLegalTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StateLegalTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StateLegalTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StateLegalTemplatePayload>
          }
          findFirst: {
            args: Prisma.StateLegalTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StateLegalTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StateLegalTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StateLegalTemplatePayload>
          }
          findMany: {
            args: Prisma.StateLegalTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StateLegalTemplatePayload>[]
          }
          create: {
            args: Prisma.StateLegalTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StateLegalTemplatePayload>
          }
          createMany: {
            args: Prisma.StateLegalTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StateLegalTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StateLegalTemplatePayload>[]
          }
          delete: {
            args: Prisma.StateLegalTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StateLegalTemplatePayload>
          }
          update: {
            args: Prisma.StateLegalTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StateLegalTemplatePayload>
          }
          deleteMany: {
            args: Prisma.StateLegalTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StateLegalTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StateLegalTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StateLegalTemplatePayload>
          }
          aggregate: {
            args: Prisma.StateLegalTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStateLegalTemplate>
          }
          groupBy: {
            args: Prisma.StateLegalTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<StateLegalTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.StateLegalTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<StateLegalTemplateCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      PanicAlert: {
        payload: Prisma.$PanicAlertPayload<ExtArgs>
        fields: Prisma.PanicAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PanicAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanicAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PanicAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanicAlertPayload>
          }
          findFirst: {
            args: Prisma.PanicAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanicAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PanicAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanicAlertPayload>
          }
          findMany: {
            args: Prisma.PanicAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanicAlertPayload>[]
          }
          create: {
            args: Prisma.PanicAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanicAlertPayload>
          }
          createMany: {
            args: Prisma.PanicAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PanicAlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanicAlertPayload>[]
          }
          delete: {
            args: Prisma.PanicAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanicAlertPayload>
          }
          update: {
            args: Prisma.PanicAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanicAlertPayload>
          }
          deleteMany: {
            args: Prisma.PanicAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PanicAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PanicAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanicAlertPayload>
          }
          aggregate: {
            args: Prisma.PanicAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePanicAlert>
          }
          groupBy: {
            args: Prisma.PanicAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<PanicAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.PanicAlertCountArgs<ExtArgs>
            result: $Utils.Optional<PanicAlertCountAggregateOutputType> | number
          }
        }
      }
      AdminUser: {
        payload: Prisma.$AdminUserPayload<ExtArgs>
        fields: Prisma.AdminUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          findFirst: {
            args: Prisma.AdminUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          findMany: {
            args: Prisma.AdminUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>[]
          }
          create: {
            args: Prisma.AdminUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          createMany: {
            args: Prisma.AdminUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>[]
          }
          delete: {
            args: Prisma.AdminUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          update: {
            args: Prisma.AdminUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          deleteMany: {
            args: Prisma.AdminUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          aggregate: {
            args: Prisma.AdminUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminUser>
          }
          groupBy: {
            args: Prisma.AdminUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminUserCountArgs<ExtArgs>
            result: $Utils.Optional<AdminUserCountAggregateOutputType> | number
          }
        }
      }
      AdminSession: {
        payload: Prisma.$AdminSessionPayload<ExtArgs>
        fields: Prisma.AdminSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          findFirst: {
            args: Prisma.AdminSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          findMany: {
            args: Prisma.AdminSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>[]
          }
          create: {
            args: Prisma.AdminSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          createMany: {
            args: Prisma.AdminSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>[]
          }
          delete: {
            args: Prisma.AdminSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          update: {
            args: Prisma.AdminSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          deleteMany: {
            args: Prisma.AdminSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          aggregate: {
            args: Prisma.AdminSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminSession>
          }
          groupBy: {
            args: Prisma.AdminSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminSessionCountArgs<ExtArgs>
            result: $Utils.Optional<AdminSessionCountAggregateOutputType> | number
          }
        }
      }
      AdminAuditLog: {
        payload: Prisma.$AdminAuditLogPayload<ExtArgs>
        fields: Prisma.AdminAuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminAuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminAuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          findFirst: {
            args: Prisma.AdminAuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminAuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          findMany: {
            args: Prisma.AdminAuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>[]
          }
          create: {
            args: Prisma.AdminAuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          createMany: {
            args: Prisma.AdminAuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminAuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>[]
          }
          delete: {
            args: Prisma.AdminAuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          update: {
            args: Prisma.AdminAuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AdminAuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminAuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminAuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          aggregate: {
            args: Prisma.AdminAuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminAuditLog>
          }
          groupBy: {
            args: Prisma.AdminAuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminAuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminAuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AdminAuditLogCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionPlan: {
        payload: Prisma.$SubscriptionPlanPayload<ExtArgs>
        fields: Prisma.SubscriptionPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          findMany: {
            args: Prisma.SubscriptionPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          create: {
            args: Prisma.SubscriptionPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          createMany: {
            args: Prisma.SubscriptionPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          update: {
            args: Prisma.SubscriptionPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionPlan>
          }
          groupBy: {
            args: Prisma.SubscriptionPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionPlanCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPlanCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      PaymentMethod: {
        payload: Prisma.$PaymentMethodPayload<ExtArgs>
        fields: Prisma.PaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.PaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findMany: {
            args: Prisma.PaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          create: {
            args: Prisma.PaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          createMany: {
            args: Prisma.PaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentMethodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          delete: {
            args: Prisma.PaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          update: {
            args: Prisma.PaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.PaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.PaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentMethod>
          }
          groupBy: {
            args: Prisma.PaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      FiscalData: {
        payload: Prisma.$FiscalDataPayload<ExtArgs>
        fields: Prisma.FiscalDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FiscalDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FiscalDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalDataPayload>
          }
          findFirst: {
            args: Prisma.FiscalDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FiscalDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalDataPayload>
          }
          findMany: {
            args: Prisma.FiscalDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalDataPayload>[]
          }
          create: {
            args: Prisma.FiscalDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalDataPayload>
          }
          createMany: {
            args: Prisma.FiscalDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FiscalDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalDataPayload>[]
          }
          delete: {
            args: Prisma.FiscalDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalDataPayload>
          }
          update: {
            args: Prisma.FiscalDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalDataPayload>
          }
          deleteMany: {
            args: Prisma.FiscalDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FiscalDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FiscalDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalDataPayload>
          }
          aggregate: {
            args: Prisma.FiscalDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFiscalData>
          }
          groupBy: {
            args: Prisma.FiscalDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<FiscalDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.FiscalDataCountArgs<ExtArgs>
            result: $Utils.Optional<FiscalDataCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    directives: number
    representatives: number
    emergencyAccesses: number
    panicAlerts: number
    auditLogs: number
    sessions: number
    webauthnCredentials: number
    payments: number
    paymentMethods: number
    invoices: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    directives?: boolean | UserCountOutputTypeCountDirectivesArgs
    representatives?: boolean | UserCountOutputTypeCountRepresentativesArgs
    emergencyAccesses?: boolean | UserCountOutputTypeCountEmergencyAccessesArgs
    panicAlerts?: boolean | UserCountOutputTypeCountPanicAlertsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    webauthnCredentials?: boolean | UserCountOutputTypeCountWebauthnCredentialsArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
    paymentMethods?: boolean | UserCountOutputTypeCountPaymentMethodsArgs
    invoices?: boolean | UserCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDirectivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvanceDirectiveWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRepresentativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepresentativeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmergencyAccessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyAccessWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPanicAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PanicAlertWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWebauthnCredentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebAuthnCredentialWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type AdvanceDirectiveCountOutputType
   */

  export type AdvanceDirectiveCountOutputType = {
    witnesses: number
  }

  export type AdvanceDirectiveCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    witnesses?: boolean | AdvanceDirectiveCountOutputTypeCountWitnessesArgs
  }

  // Custom InputTypes
  /**
   * AdvanceDirectiveCountOutputType without action
   */
  export type AdvanceDirectiveCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvanceDirectiveCountOutputType
     */
    select?: AdvanceDirectiveCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdvanceDirectiveCountOutputType without action
   */
  export type AdvanceDirectiveCountOutputTypeCountWitnessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WitnessWhereInput
  }


  /**
   * Count Type MedicalInstitutionCountOutputType
   */

  export type MedicalInstitutionCountOutputType = {
    emergencyAccesses: number
    staff: number
    insuranceNetworks: number
  }

  export type MedicalInstitutionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emergencyAccesses?: boolean | MedicalInstitutionCountOutputTypeCountEmergencyAccessesArgs
    staff?: boolean | MedicalInstitutionCountOutputTypeCountStaffArgs
    insuranceNetworks?: boolean | MedicalInstitutionCountOutputTypeCountInsuranceNetworksArgs
  }

  // Custom InputTypes
  /**
   * MedicalInstitutionCountOutputType without action
   */
  export type MedicalInstitutionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInstitutionCountOutputType
     */
    select?: MedicalInstitutionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MedicalInstitutionCountOutputType without action
   */
  export type MedicalInstitutionCountOutputTypeCountEmergencyAccessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyAccessWhereInput
  }

  /**
   * MedicalInstitutionCountOutputType without action
   */
  export type MedicalInstitutionCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalStaffWhereInput
  }

  /**
   * MedicalInstitutionCountOutputType without action
   */
  export type MedicalInstitutionCountOutputTypeCountInsuranceNetworksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsuranceCompanyWhereInput
  }


  /**
   * Count Type InsuranceCompanyCountOutputType
   */

  export type InsuranceCompanyCountOutputType = {
    plans: number
    networkHospitals: number
    emergencyAccesses: number
  }

  export type InsuranceCompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plans?: boolean | InsuranceCompanyCountOutputTypeCountPlansArgs
    networkHospitals?: boolean | InsuranceCompanyCountOutputTypeCountNetworkHospitalsArgs
    emergencyAccesses?: boolean | InsuranceCompanyCountOutputTypeCountEmergencyAccessesArgs
  }

  // Custom InputTypes
  /**
   * InsuranceCompanyCountOutputType without action
   */
  export type InsuranceCompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceCompanyCountOutputType
     */
    select?: InsuranceCompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InsuranceCompanyCountOutputType without action
   */
  export type InsuranceCompanyCountOutputTypeCountPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsurancePlanWhereInput
  }

  /**
   * InsuranceCompanyCountOutputType without action
   */
  export type InsuranceCompanyCountOutputTypeCountNetworkHospitalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalInstitutionWhereInput
  }

  /**
   * InsuranceCompanyCountOutputType without action
   */
  export type InsuranceCompanyCountOutputTypeCountEmergencyAccessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyAccessWhereInput
  }


  /**
   * Count Type AdminUserCountOutputType
   */

  export type AdminUserCountOutputType = {
    sessions: number
    auditActions: number
  }

  export type AdminUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | AdminUserCountOutputTypeCountSessionsArgs
    auditActions?: boolean | AdminUserCountOutputTypeCountAuditActionsArgs
  }

  // Custom InputTypes
  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUserCountOutputType
     */
    select?: AdminUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminSessionWhereInput
  }

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountAuditActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuditLogWhereInput
  }


  /**
   * Count Type SubscriptionPlanCountOutputType
   */

  export type SubscriptionPlanCountOutputType = {
    subscriptions: number
  }

  export type SubscriptionPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | SubscriptionPlanCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlanCountOutputType
     */
    select?: SubscriptionPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    payments: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | SubscriptionCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type FiscalDataCountOutputType
   */

  export type FiscalDataCountOutputType = {
    invoices: number
  }

  export type FiscalDataCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | FiscalDataCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * FiscalDataCountOutputType without action
   */
  export type FiscalDataCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalDataCountOutputType
     */
    select?: FiscalDataCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FiscalDataCountOutputType without action
   */
  export type FiscalDataCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    curp: string | null
    name: string | null
    dateOfBirth: Date | null
    sex: string | null
    phone: string | null
    address: string | null
    isActive: boolean | null
    isVerified: boolean | null
    verificationToken: string | null
    verificationExpires: Date | null
    resetToken: string | null
    resetExpires: Date | null
    webauthnChallenge: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    curp: string | null
    name: string | null
    dateOfBirth: Date | null
    sex: string | null
    phone: string | null
    address: string | null
    isActive: boolean | null
    isVerified: boolean | null
    verificationToken: string | null
    verificationExpires: Date | null
    resetToken: string | null
    resetExpires: Date | null
    webauthnChallenge: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    curp: number
    name: number
    dateOfBirth: number
    sex: number
    phone: number
    address: number
    isActive: number
    isVerified: number
    verificationToken: number
    verificationExpires: number
    resetToken: number
    resetExpires: number
    webauthnChallenge: number
    createdAt: number
    updatedAt: number
    lastLoginAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    curp?: true
    name?: true
    dateOfBirth?: true
    sex?: true
    phone?: true
    address?: true
    isActive?: true
    isVerified?: true
    verificationToken?: true
    verificationExpires?: true
    resetToken?: true
    resetExpires?: true
    webauthnChallenge?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    curp?: true
    name?: true
    dateOfBirth?: true
    sex?: true
    phone?: true
    address?: true
    isActive?: true
    isVerified?: true
    verificationToken?: true
    verificationExpires?: true
    resetToken?: true
    resetExpires?: true
    webauthnChallenge?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    curp?: true
    name?: true
    dateOfBirth?: true
    sex?: true
    phone?: true
    address?: true
    isActive?: true
    isVerified?: true
    verificationToken?: true
    verificationExpires?: true
    resetToken?: true
    resetExpires?: true
    webauthnChallenge?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth: Date | null
    sex: string | null
    phone: string | null
    address: string | null
    isActive: boolean
    isVerified: boolean
    verificationToken: string | null
    verificationExpires: Date | null
    resetToken: string | null
    resetExpires: Date | null
    webauthnChallenge: string | null
    createdAt: Date
    updatedAt: Date
    lastLoginAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    curp?: boolean
    name?: boolean
    dateOfBirth?: boolean
    sex?: boolean
    phone?: boolean
    address?: boolean
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: boolean
    verificationExpires?: boolean
    resetToken?: boolean
    resetExpires?: boolean
    webauthnChallenge?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    profile?: boolean | User$profileArgs<ExtArgs>
    directives?: boolean | User$directivesArgs<ExtArgs>
    representatives?: boolean | User$representativesArgs<ExtArgs>
    emergencyAccesses?: boolean | User$emergencyAccessesArgs<ExtArgs>
    panicAlerts?: boolean | User$panicAlertsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    webauthnCredentials?: boolean | User$webauthnCredentialsArgs<ExtArgs>
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    paymentMethods?: boolean | User$paymentMethodsArgs<ExtArgs>
    fiscalData?: boolean | User$fiscalDataArgs<ExtArgs>
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    curp?: boolean
    name?: boolean
    dateOfBirth?: boolean
    sex?: boolean
    phone?: boolean
    address?: boolean
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: boolean
    verificationExpires?: boolean
    resetToken?: boolean
    resetExpires?: boolean
    webauthnChallenge?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    curp?: boolean
    name?: boolean
    dateOfBirth?: boolean
    sex?: boolean
    phone?: boolean
    address?: boolean
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: boolean
    verificationExpires?: boolean
    resetToken?: boolean
    resetExpires?: boolean
    webauthnChallenge?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | User$profileArgs<ExtArgs>
    directives?: boolean | User$directivesArgs<ExtArgs>
    representatives?: boolean | User$representativesArgs<ExtArgs>
    emergencyAccesses?: boolean | User$emergencyAccessesArgs<ExtArgs>
    panicAlerts?: boolean | User$panicAlertsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    webauthnCredentials?: boolean | User$webauthnCredentialsArgs<ExtArgs>
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    paymentMethods?: boolean | User$paymentMethodsArgs<ExtArgs>
    fiscalData?: boolean | User$fiscalDataArgs<ExtArgs>
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profile: Prisma.$PatientProfilePayload<ExtArgs> | null
      directives: Prisma.$AdvanceDirectivePayload<ExtArgs>[]
      representatives: Prisma.$RepresentativePayload<ExtArgs>[]
      emergencyAccesses: Prisma.$EmergencyAccessPayload<ExtArgs>[]
      panicAlerts: Prisma.$PanicAlertPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      webauthnCredentials: Prisma.$WebAuthnCredentialPayload<ExtArgs>[]
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      paymentMethods: Prisma.$PaymentMethodPayload<ExtArgs>[]
      fiscalData: Prisma.$FiscalDataPayload<ExtArgs> | null
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      curp: string
      name: string
      dateOfBirth: Date | null
      sex: string | null
      phone: string | null
      address: string | null
      isActive: boolean
      isVerified: boolean
      verificationToken: string | null
      verificationExpires: Date | null
      resetToken: string | null
      resetExpires: Date | null
      webauthnChallenge: string | null
      createdAt: Date
      updatedAt: Date
      lastLoginAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__PatientProfileClient<$Result.GetResult<Prisma.$PatientProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    directives<T extends User$directivesArgs<ExtArgs> = {}>(args?: Subset<T, User$directivesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvanceDirectivePayload<ExtArgs>, T, "findMany"> | Null>
    representatives<T extends User$representativesArgs<ExtArgs> = {}>(args?: Subset<T, User$representativesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepresentativePayload<ExtArgs>, T, "findMany"> | Null>
    emergencyAccesses<T extends User$emergencyAccessesArgs<ExtArgs> = {}>(args?: Subset<T, User$emergencyAccessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyAccessPayload<ExtArgs>, T, "findMany"> | Null>
    panicAlerts<T extends User$panicAlertsArgs<ExtArgs> = {}>(args?: Subset<T, User$panicAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PanicAlertPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    webauthnCredentials<T extends User$webauthnCredentialsArgs<ExtArgs> = {}>(args?: Subset<T, User$webauthnCredentialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebAuthnCredentialPayload<ExtArgs>, T, "findMany"> | Null>
    subscription<T extends User$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    paymentMethods<T extends User$paymentMethodsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentMethodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany"> | Null>
    fiscalData<T extends User$fiscalDataArgs<ExtArgs> = {}>(args?: Subset<T, User$fiscalDataArgs<ExtArgs>>): Prisma__FiscalDataClient<$Result.GetResult<Prisma.$FiscalDataPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    invoices<T extends User$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, User$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly curp: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly dateOfBirth: FieldRef<"User", 'DateTime'>
    readonly sex: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly verificationToken: FieldRef<"User", 'String'>
    readonly verificationExpires: FieldRef<"User", 'DateTime'>
    readonly resetToken: FieldRef<"User", 'String'>
    readonly resetExpires: FieldRef<"User", 'DateTime'>
    readonly webauthnChallenge: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileInclude<ExtArgs> | null
    where?: PatientProfileWhereInput
  }

  /**
   * User.directives
   */
  export type User$directivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvanceDirective
     */
    select?: AdvanceDirectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvanceDirectiveInclude<ExtArgs> | null
    where?: AdvanceDirectiveWhereInput
    orderBy?: AdvanceDirectiveOrderByWithRelationInput | AdvanceDirectiveOrderByWithRelationInput[]
    cursor?: AdvanceDirectiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdvanceDirectiveScalarFieldEnum | AdvanceDirectiveScalarFieldEnum[]
  }

  /**
   * User.representatives
   */
  export type User$representativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Representative
     */
    select?: RepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepresentativeInclude<ExtArgs> | null
    where?: RepresentativeWhereInput
    orderBy?: RepresentativeOrderByWithRelationInput | RepresentativeOrderByWithRelationInput[]
    cursor?: RepresentativeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RepresentativeScalarFieldEnum | RepresentativeScalarFieldEnum[]
  }

  /**
   * User.emergencyAccesses
   */
  export type User$emergencyAccessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAccess
     */
    select?: EmergencyAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAccessInclude<ExtArgs> | null
    where?: EmergencyAccessWhereInput
    orderBy?: EmergencyAccessOrderByWithRelationInput | EmergencyAccessOrderByWithRelationInput[]
    cursor?: EmergencyAccessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmergencyAccessScalarFieldEnum | EmergencyAccessScalarFieldEnum[]
  }

  /**
   * User.panicAlerts
   */
  export type User$panicAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanicAlert
     */
    select?: PanicAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanicAlertInclude<ExtArgs> | null
    where?: PanicAlertWhereInput
    orderBy?: PanicAlertOrderByWithRelationInput | PanicAlertOrderByWithRelationInput[]
    cursor?: PanicAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PanicAlertScalarFieldEnum | PanicAlertScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.webauthnCredentials
   */
  export type User$webauthnCredentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null
    where?: WebAuthnCredentialWhereInput
    orderBy?: WebAuthnCredentialOrderByWithRelationInput | WebAuthnCredentialOrderByWithRelationInput[]
    cursor?: WebAuthnCredentialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebAuthnCredentialScalarFieldEnum | WebAuthnCredentialScalarFieldEnum[]
  }

  /**
   * User.subscription
   */
  export type User$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.paymentMethods
   */
  export type User$paymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    cursor?: PaymentMethodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * User.fiscalData
   */
  export type User$fiscalDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalData
     */
    select?: FiscalDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalDataInclude<ExtArgs> | null
    where?: FiscalDataWhereInput
  }

  /**
   * User.invoices
   */
  export type User$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    refreshToken: string | null
    userAgent: string | null
    ipAddress: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    refreshToken: string | null
    userAgent: string | null
    ipAddress: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    refreshToken: number
    userAgent: number
    ipAddress: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    refreshToken?: true
    userAgent?: true
    ipAddress?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    refreshToken?: true
    userAgent?: true
    ipAddress?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    refreshToken?: true
    userAgent?: true
    ipAddress?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    refreshToken: string
    userAgent: string | null
    ipAddress: string | null
    expiresAt: Date
    createdAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refreshToken?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refreshToken?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    refreshToken?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      refreshToken: string
      userAgent: string | null
      ipAddress: string | null
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly refreshToken: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model WebAuthnCredential
   */

  export type AggregateWebAuthnCredential = {
    _count: WebAuthnCredentialCountAggregateOutputType | null
    _avg: WebAuthnCredentialAvgAggregateOutputType | null
    _sum: WebAuthnCredentialSumAggregateOutputType | null
    _min: WebAuthnCredentialMinAggregateOutputType | null
    _max: WebAuthnCredentialMaxAggregateOutputType | null
  }

  export type WebAuthnCredentialAvgAggregateOutputType = {
    counter: number | null
  }

  export type WebAuthnCredentialSumAggregateOutputType = {
    counter: bigint | null
  }

  export type WebAuthnCredentialMinAggregateOutputType = {
    id: string | null
    userId: string | null
    credentialId: string | null
    credentialPublicKey: Buffer | null
    counter: bigint | null
    deviceType: string | null
    deviceName: string | null
    createdAt: Date | null
    lastUsedAt: Date | null
  }

  export type WebAuthnCredentialMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    credentialId: string | null
    credentialPublicKey: Buffer | null
    counter: bigint | null
    deviceType: string | null
    deviceName: string | null
    createdAt: Date | null
    lastUsedAt: Date | null
  }

  export type WebAuthnCredentialCountAggregateOutputType = {
    id: number
    userId: number
    credentialId: number
    credentialPublicKey: number
    counter: number
    deviceType: number
    deviceName: number
    transports: number
    createdAt: number
    lastUsedAt: number
    _all: number
  }


  export type WebAuthnCredentialAvgAggregateInputType = {
    counter?: true
  }

  export type WebAuthnCredentialSumAggregateInputType = {
    counter?: true
  }

  export type WebAuthnCredentialMinAggregateInputType = {
    id?: true
    userId?: true
    credentialId?: true
    credentialPublicKey?: true
    counter?: true
    deviceType?: true
    deviceName?: true
    createdAt?: true
    lastUsedAt?: true
  }

  export type WebAuthnCredentialMaxAggregateInputType = {
    id?: true
    userId?: true
    credentialId?: true
    credentialPublicKey?: true
    counter?: true
    deviceType?: true
    deviceName?: true
    createdAt?: true
    lastUsedAt?: true
  }

  export type WebAuthnCredentialCountAggregateInputType = {
    id?: true
    userId?: true
    credentialId?: true
    credentialPublicKey?: true
    counter?: true
    deviceType?: true
    deviceName?: true
    transports?: true
    createdAt?: true
    lastUsedAt?: true
    _all?: true
  }

  export type WebAuthnCredentialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebAuthnCredential to aggregate.
     */
    where?: WebAuthnCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebAuthnCredentials to fetch.
     */
    orderBy?: WebAuthnCredentialOrderByWithRelationInput | WebAuthnCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebAuthnCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebAuthnCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebAuthnCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebAuthnCredentials
    **/
    _count?: true | WebAuthnCredentialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebAuthnCredentialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebAuthnCredentialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebAuthnCredentialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebAuthnCredentialMaxAggregateInputType
  }

  export type GetWebAuthnCredentialAggregateType<T extends WebAuthnCredentialAggregateArgs> = {
        [P in keyof T & keyof AggregateWebAuthnCredential]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebAuthnCredential[P]>
      : GetScalarType<T[P], AggregateWebAuthnCredential[P]>
  }




  export type WebAuthnCredentialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebAuthnCredentialWhereInput
    orderBy?: WebAuthnCredentialOrderByWithAggregationInput | WebAuthnCredentialOrderByWithAggregationInput[]
    by: WebAuthnCredentialScalarFieldEnum[] | WebAuthnCredentialScalarFieldEnum
    having?: WebAuthnCredentialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebAuthnCredentialCountAggregateInputType | true
    _avg?: WebAuthnCredentialAvgAggregateInputType
    _sum?: WebAuthnCredentialSumAggregateInputType
    _min?: WebAuthnCredentialMinAggregateInputType
    _max?: WebAuthnCredentialMaxAggregateInputType
  }

  export type WebAuthnCredentialGroupByOutputType = {
    id: string
    userId: string
    credentialId: string
    credentialPublicKey: Buffer
    counter: bigint
    deviceType: string | null
    deviceName: string | null
    transports: string[]
    createdAt: Date
    lastUsedAt: Date | null
    _count: WebAuthnCredentialCountAggregateOutputType | null
    _avg: WebAuthnCredentialAvgAggregateOutputType | null
    _sum: WebAuthnCredentialSumAggregateOutputType | null
    _min: WebAuthnCredentialMinAggregateOutputType | null
    _max: WebAuthnCredentialMaxAggregateOutputType | null
  }

  type GetWebAuthnCredentialGroupByPayload<T extends WebAuthnCredentialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebAuthnCredentialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebAuthnCredentialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebAuthnCredentialGroupByOutputType[P]>
            : GetScalarType<T[P], WebAuthnCredentialGroupByOutputType[P]>
        }
      >
    >


  export type WebAuthnCredentialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    credentialId?: boolean
    credentialPublicKey?: boolean
    counter?: boolean
    deviceType?: boolean
    deviceName?: boolean
    transports?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webAuthnCredential"]>

  export type WebAuthnCredentialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    credentialId?: boolean
    credentialPublicKey?: boolean
    counter?: boolean
    deviceType?: boolean
    deviceName?: boolean
    transports?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webAuthnCredential"]>

  export type WebAuthnCredentialSelectScalar = {
    id?: boolean
    userId?: boolean
    credentialId?: boolean
    credentialPublicKey?: boolean
    counter?: boolean
    deviceType?: boolean
    deviceName?: boolean
    transports?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
  }

  export type WebAuthnCredentialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WebAuthnCredentialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WebAuthnCredentialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebAuthnCredential"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      credentialId: string
      credentialPublicKey: Buffer
      counter: bigint
      deviceType: string | null
      deviceName: string | null
      transports: string[]
      createdAt: Date
      lastUsedAt: Date | null
    }, ExtArgs["result"]["webAuthnCredential"]>
    composites: {}
  }

  type WebAuthnCredentialGetPayload<S extends boolean | null | undefined | WebAuthnCredentialDefaultArgs> = $Result.GetResult<Prisma.$WebAuthnCredentialPayload, S>

  type WebAuthnCredentialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WebAuthnCredentialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WebAuthnCredentialCountAggregateInputType | true
    }

  export interface WebAuthnCredentialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebAuthnCredential'], meta: { name: 'WebAuthnCredential' } }
    /**
     * Find zero or one WebAuthnCredential that matches the filter.
     * @param {WebAuthnCredentialFindUniqueArgs} args - Arguments to find a WebAuthnCredential
     * @example
     * // Get one WebAuthnCredential
     * const webAuthnCredential = await prisma.webAuthnCredential.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebAuthnCredentialFindUniqueArgs>(args: SelectSubset<T, WebAuthnCredentialFindUniqueArgs<ExtArgs>>): Prisma__WebAuthnCredentialClient<$Result.GetResult<Prisma.$WebAuthnCredentialPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WebAuthnCredential that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WebAuthnCredentialFindUniqueOrThrowArgs} args - Arguments to find a WebAuthnCredential
     * @example
     * // Get one WebAuthnCredential
     * const webAuthnCredential = await prisma.webAuthnCredential.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebAuthnCredentialFindUniqueOrThrowArgs>(args: SelectSubset<T, WebAuthnCredentialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebAuthnCredentialClient<$Result.GetResult<Prisma.$WebAuthnCredentialPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WebAuthnCredential that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnCredentialFindFirstArgs} args - Arguments to find a WebAuthnCredential
     * @example
     * // Get one WebAuthnCredential
     * const webAuthnCredential = await prisma.webAuthnCredential.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebAuthnCredentialFindFirstArgs>(args?: SelectSubset<T, WebAuthnCredentialFindFirstArgs<ExtArgs>>): Prisma__WebAuthnCredentialClient<$Result.GetResult<Prisma.$WebAuthnCredentialPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WebAuthnCredential that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnCredentialFindFirstOrThrowArgs} args - Arguments to find a WebAuthnCredential
     * @example
     * // Get one WebAuthnCredential
     * const webAuthnCredential = await prisma.webAuthnCredential.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebAuthnCredentialFindFirstOrThrowArgs>(args?: SelectSubset<T, WebAuthnCredentialFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebAuthnCredentialClient<$Result.GetResult<Prisma.$WebAuthnCredentialPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WebAuthnCredentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnCredentialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebAuthnCredentials
     * const webAuthnCredentials = await prisma.webAuthnCredential.findMany()
     * 
     * // Get first 10 WebAuthnCredentials
     * const webAuthnCredentials = await prisma.webAuthnCredential.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webAuthnCredentialWithIdOnly = await prisma.webAuthnCredential.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebAuthnCredentialFindManyArgs>(args?: SelectSubset<T, WebAuthnCredentialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebAuthnCredentialPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WebAuthnCredential.
     * @param {WebAuthnCredentialCreateArgs} args - Arguments to create a WebAuthnCredential.
     * @example
     * // Create one WebAuthnCredential
     * const WebAuthnCredential = await prisma.webAuthnCredential.create({
     *   data: {
     *     // ... data to create a WebAuthnCredential
     *   }
     * })
     * 
     */
    create<T extends WebAuthnCredentialCreateArgs>(args: SelectSubset<T, WebAuthnCredentialCreateArgs<ExtArgs>>): Prisma__WebAuthnCredentialClient<$Result.GetResult<Prisma.$WebAuthnCredentialPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WebAuthnCredentials.
     * @param {WebAuthnCredentialCreateManyArgs} args - Arguments to create many WebAuthnCredentials.
     * @example
     * // Create many WebAuthnCredentials
     * const webAuthnCredential = await prisma.webAuthnCredential.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebAuthnCredentialCreateManyArgs>(args?: SelectSubset<T, WebAuthnCredentialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebAuthnCredentials and returns the data saved in the database.
     * @param {WebAuthnCredentialCreateManyAndReturnArgs} args - Arguments to create many WebAuthnCredentials.
     * @example
     * // Create many WebAuthnCredentials
     * const webAuthnCredential = await prisma.webAuthnCredential.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebAuthnCredentials and only return the `id`
     * const webAuthnCredentialWithIdOnly = await prisma.webAuthnCredential.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebAuthnCredentialCreateManyAndReturnArgs>(args?: SelectSubset<T, WebAuthnCredentialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebAuthnCredentialPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WebAuthnCredential.
     * @param {WebAuthnCredentialDeleteArgs} args - Arguments to delete one WebAuthnCredential.
     * @example
     * // Delete one WebAuthnCredential
     * const WebAuthnCredential = await prisma.webAuthnCredential.delete({
     *   where: {
     *     // ... filter to delete one WebAuthnCredential
     *   }
     * })
     * 
     */
    delete<T extends WebAuthnCredentialDeleteArgs>(args: SelectSubset<T, WebAuthnCredentialDeleteArgs<ExtArgs>>): Prisma__WebAuthnCredentialClient<$Result.GetResult<Prisma.$WebAuthnCredentialPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WebAuthnCredential.
     * @param {WebAuthnCredentialUpdateArgs} args - Arguments to update one WebAuthnCredential.
     * @example
     * // Update one WebAuthnCredential
     * const webAuthnCredential = await prisma.webAuthnCredential.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebAuthnCredentialUpdateArgs>(args: SelectSubset<T, WebAuthnCredentialUpdateArgs<ExtArgs>>): Prisma__WebAuthnCredentialClient<$Result.GetResult<Prisma.$WebAuthnCredentialPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WebAuthnCredentials.
     * @param {WebAuthnCredentialDeleteManyArgs} args - Arguments to filter WebAuthnCredentials to delete.
     * @example
     * // Delete a few WebAuthnCredentials
     * const { count } = await prisma.webAuthnCredential.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebAuthnCredentialDeleteManyArgs>(args?: SelectSubset<T, WebAuthnCredentialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebAuthnCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnCredentialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebAuthnCredentials
     * const webAuthnCredential = await prisma.webAuthnCredential.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebAuthnCredentialUpdateManyArgs>(args: SelectSubset<T, WebAuthnCredentialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WebAuthnCredential.
     * @param {WebAuthnCredentialUpsertArgs} args - Arguments to update or create a WebAuthnCredential.
     * @example
     * // Update or create a WebAuthnCredential
     * const webAuthnCredential = await prisma.webAuthnCredential.upsert({
     *   create: {
     *     // ... data to create a WebAuthnCredential
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebAuthnCredential we want to update
     *   }
     * })
     */
    upsert<T extends WebAuthnCredentialUpsertArgs>(args: SelectSubset<T, WebAuthnCredentialUpsertArgs<ExtArgs>>): Prisma__WebAuthnCredentialClient<$Result.GetResult<Prisma.$WebAuthnCredentialPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WebAuthnCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnCredentialCountArgs} args - Arguments to filter WebAuthnCredentials to count.
     * @example
     * // Count the number of WebAuthnCredentials
     * const count = await prisma.webAuthnCredential.count({
     *   where: {
     *     // ... the filter for the WebAuthnCredentials we want to count
     *   }
     * })
    **/
    count<T extends WebAuthnCredentialCountArgs>(
      args?: Subset<T, WebAuthnCredentialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebAuthnCredentialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebAuthnCredential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnCredentialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebAuthnCredentialAggregateArgs>(args: Subset<T, WebAuthnCredentialAggregateArgs>): Prisma.PrismaPromise<GetWebAuthnCredentialAggregateType<T>>

    /**
     * Group by WebAuthnCredential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnCredentialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebAuthnCredentialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebAuthnCredentialGroupByArgs['orderBy'] }
        : { orderBy?: WebAuthnCredentialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebAuthnCredentialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebAuthnCredentialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebAuthnCredential model
   */
  readonly fields: WebAuthnCredentialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebAuthnCredential.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebAuthnCredentialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebAuthnCredential model
   */ 
  interface WebAuthnCredentialFieldRefs {
    readonly id: FieldRef<"WebAuthnCredential", 'String'>
    readonly userId: FieldRef<"WebAuthnCredential", 'String'>
    readonly credentialId: FieldRef<"WebAuthnCredential", 'String'>
    readonly credentialPublicKey: FieldRef<"WebAuthnCredential", 'Bytes'>
    readonly counter: FieldRef<"WebAuthnCredential", 'BigInt'>
    readonly deviceType: FieldRef<"WebAuthnCredential", 'String'>
    readonly deviceName: FieldRef<"WebAuthnCredential", 'String'>
    readonly transports: FieldRef<"WebAuthnCredential", 'String[]'>
    readonly createdAt: FieldRef<"WebAuthnCredential", 'DateTime'>
    readonly lastUsedAt: FieldRef<"WebAuthnCredential", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebAuthnCredential findUnique
   */
  export type WebAuthnCredentialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null
    /**
     * Filter, which WebAuthnCredential to fetch.
     */
    where: WebAuthnCredentialWhereUniqueInput
  }

  /**
   * WebAuthnCredential findUniqueOrThrow
   */
  export type WebAuthnCredentialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null
    /**
     * Filter, which WebAuthnCredential to fetch.
     */
    where: WebAuthnCredentialWhereUniqueInput
  }

  /**
   * WebAuthnCredential findFirst
   */
  export type WebAuthnCredentialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null
    /**
     * Filter, which WebAuthnCredential to fetch.
     */
    where?: WebAuthnCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebAuthnCredentials to fetch.
     */
    orderBy?: WebAuthnCredentialOrderByWithRelationInput | WebAuthnCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebAuthnCredentials.
     */
    cursor?: WebAuthnCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebAuthnCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebAuthnCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebAuthnCredentials.
     */
    distinct?: WebAuthnCredentialScalarFieldEnum | WebAuthnCredentialScalarFieldEnum[]
  }

  /**
   * WebAuthnCredential findFirstOrThrow
   */
  export type WebAuthnCredentialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null
    /**
     * Filter, which WebAuthnCredential to fetch.
     */
    where?: WebAuthnCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebAuthnCredentials to fetch.
     */
    orderBy?: WebAuthnCredentialOrderByWithRelationInput | WebAuthnCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebAuthnCredentials.
     */
    cursor?: WebAuthnCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebAuthnCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebAuthnCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebAuthnCredentials.
     */
    distinct?: WebAuthnCredentialScalarFieldEnum | WebAuthnCredentialScalarFieldEnum[]
  }

  /**
   * WebAuthnCredential findMany
   */
  export type WebAuthnCredentialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null
    /**
     * Filter, which WebAuthnCredentials to fetch.
     */
    where?: WebAuthnCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebAuthnCredentials to fetch.
     */
    orderBy?: WebAuthnCredentialOrderByWithRelationInput | WebAuthnCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebAuthnCredentials.
     */
    cursor?: WebAuthnCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebAuthnCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebAuthnCredentials.
     */
    skip?: number
    distinct?: WebAuthnCredentialScalarFieldEnum | WebAuthnCredentialScalarFieldEnum[]
  }

  /**
   * WebAuthnCredential create
   */
  export type WebAuthnCredentialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null
    /**
     * The data needed to create a WebAuthnCredential.
     */
    data: XOR<WebAuthnCredentialCreateInput, WebAuthnCredentialUncheckedCreateInput>
  }

  /**
   * WebAuthnCredential createMany
   */
  export type WebAuthnCredentialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebAuthnCredentials.
     */
    data: WebAuthnCredentialCreateManyInput | WebAuthnCredentialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebAuthnCredential createManyAndReturn
   */
  export type WebAuthnCredentialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WebAuthnCredentials.
     */
    data: WebAuthnCredentialCreateManyInput | WebAuthnCredentialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebAuthnCredentialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebAuthnCredential update
   */
  export type WebAuthnCredentialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null
    /**
     * The data needed to update a WebAuthnCredential.
     */
    data: XOR<WebAuthnCredentialUpdateInput, WebAuthnCredentialUncheckedUpdateInput>
    /**
     * Choose, which WebAuthnCredential to update.
     */
    where: WebAuthnCredentialWhereUniqueInput
  }

  /**
   * WebAuthnCredential updateMany
   */
  export type WebAuthnCredentialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebAuthnCredentials.
     */
    data: XOR<WebAuthnCredentialUpdateManyMutationInput, WebAuthnCredentialUncheckedUpdateManyInput>
    /**
     * Filter which WebAuthnCredentials to update
     */
    where?: WebAuthnCredentialWhereInput
  }

  /**
   * WebAuthnCredential upsert
   */
  export type WebAuthnCredentialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null
    /**
     * The filter to search for the WebAuthnCredential to update in case it exists.
     */
    where: WebAuthnCredentialWhereUniqueInput
    /**
     * In case the WebAuthnCredential found by the `where` argument doesn't exist, create a new WebAuthnCredential with this data.
     */
    create: XOR<WebAuthnCredentialCreateInput, WebAuthnCredentialUncheckedCreateInput>
    /**
     * In case the WebAuthnCredential was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebAuthnCredentialUpdateInput, WebAuthnCredentialUncheckedUpdateInput>
  }

  /**
   * WebAuthnCredential delete
   */
  export type WebAuthnCredentialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null
    /**
     * Filter which WebAuthnCredential to delete.
     */
    where: WebAuthnCredentialWhereUniqueInput
  }

  /**
   * WebAuthnCredential deleteMany
   */
  export type WebAuthnCredentialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebAuthnCredentials to delete
     */
    where?: WebAuthnCredentialWhereInput
  }

  /**
   * WebAuthnCredential without action
   */
  export type WebAuthnCredentialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null
  }


  /**
   * Model PatientProfile
   */

  export type AggregatePatientProfile = {
    _count: PatientProfileCountAggregateOutputType | null
    _min: PatientProfileMinAggregateOutputType | null
    _max: PatientProfileMaxAggregateOutputType | null
  }

  export type PatientProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    bloodType: string | null
    allergiesEnc: string | null
    conditionsEnc: string | null
    medicationsEnc: string | null
    insuranceProvider: string | null
    insurancePolicy: string | null
    insurancePhone: string | null
    photoUrl: string | null
    isDonor: boolean | null
    donorPreferencesEnc: string | null
    donorVideoUrl: string | null
    qrToken: string | null
    qrGeneratedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    bloodType: string | null
    allergiesEnc: string | null
    conditionsEnc: string | null
    medicationsEnc: string | null
    insuranceProvider: string | null
    insurancePolicy: string | null
    insurancePhone: string | null
    photoUrl: string | null
    isDonor: boolean | null
    donorPreferencesEnc: string | null
    donorVideoUrl: string | null
    qrToken: string | null
    qrGeneratedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientProfileCountAggregateOutputType = {
    id: number
    userId: number
    bloodType: number
    allergiesEnc: number
    conditionsEnc: number
    medicationsEnc: number
    insuranceProvider: number
    insurancePolicy: number
    insurancePhone: number
    photoUrl: number
    isDonor: number
    donorPreferencesEnc: number
    donorVideoUrl: number
    qrToken: number
    qrGeneratedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PatientProfileMinAggregateInputType = {
    id?: true
    userId?: true
    bloodType?: true
    allergiesEnc?: true
    conditionsEnc?: true
    medicationsEnc?: true
    insuranceProvider?: true
    insurancePolicy?: true
    insurancePhone?: true
    photoUrl?: true
    isDonor?: true
    donorPreferencesEnc?: true
    donorVideoUrl?: true
    qrToken?: true
    qrGeneratedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    bloodType?: true
    allergiesEnc?: true
    conditionsEnc?: true
    medicationsEnc?: true
    insuranceProvider?: true
    insurancePolicy?: true
    insurancePhone?: true
    photoUrl?: true
    isDonor?: true
    donorPreferencesEnc?: true
    donorVideoUrl?: true
    qrToken?: true
    qrGeneratedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientProfileCountAggregateInputType = {
    id?: true
    userId?: true
    bloodType?: true
    allergiesEnc?: true
    conditionsEnc?: true
    medicationsEnc?: true
    insuranceProvider?: true
    insurancePolicy?: true
    insurancePhone?: true
    photoUrl?: true
    isDonor?: true
    donorPreferencesEnc?: true
    donorVideoUrl?: true
    qrToken?: true
    qrGeneratedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PatientProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientProfile to aggregate.
     */
    where?: PatientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientProfiles to fetch.
     */
    orderBy?: PatientProfileOrderByWithRelationInput | PatientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PatientProfiles
    **/
    _count?: true | PatientProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientProfileMaxAggregateInputType
  }

  export type GetPatientProfileAggregateType<T extends PatientProfileAggregateArgs> = {
        [P in keyof T & keyof AggregatePatientProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatientProfile[P]>
      : GetScalarType<T[P], AggregatePatientProfile[P]>
  }




  export type PatientProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientProfileWhereInput
    orderBy?: PatientProfileOrderByWithAggregationInput | PatientProfileOrderByWithAggregationInput[]
    by: PatientProfileScalarFieldEnum[] | PatientProfileScalarFieldEnum
    having?: PatientProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientProfileCountAggregateInputType | true
    _min?: PatientProfileMinAggregateInputType
    _max?: PatientProfileMaxAggregateInputType
  }

  export type PatientProfileGroupByOutputType = {
    id: string
    userId: string
    bloodType: string | null
    allergiesEnc: string | null
    conditionsEnc: string | null
    medicationsEnc: string | null
    insuranceProvider: string | null
    insurancePolicy: string | null
    insurancePhone: string | null
    photoUrl: string | null
    isDonor: boolean
    donorPreferencesEnc: string | null
    donorVideoUrl: string | null
    qrToken: string
    qrGeneratedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: PatientProfileCountAggregateOutputType | null
    _min: PatientProfileMinAggregateOutputType | null
    _max: PatientProfileMaxAggregateOutputType | null
  }

  type GetPatientProfileGroupByPayload<T extends PatientProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientProfileGroupByOutputType[P]>
            : GetScalarType<T[P], PatientProfileGroupByOutputType[P]>
        }
      >
    >


  export type PatientProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bloodType?: boolean
    allergiesEnc?: boolean
    conditionsEnc?: boolean
    medicationsEnc?: boolean
    insuranceProvider?: boolean
    insurancePolicy?: boolean
    insurancePhone?: boolean
    photoUrl?: boolean
    isDonor?: boolean
    donorPreferencesEnc?: boolean
    donorVideoUrl?: boolean
    qrToken?: boolean
    qrGeneratedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientProfile"]>

  export type PatientProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bloodType?: boolean
    allergiesEnc?: boolean
    conditionsEnc?: boolean
    medicationsEnc?: boolean
    insuranceProvider?: boolean
    insurancePolicy?: boolean
    insurancePhone?: boolean
    photoUrl?: boolean
    isDonor?: boolean
    donorPreferencesEnc?: boolean
    donorVideoUrl?: boolean
    qrToken?: boolean
    qrGeneratedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientProfile"]>

  export type PatientProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    bloodType?: boolean
    allergiesEnc?: boolean
    conditionsEnc?: boolean
    medicationsEnc?: boolean
    insuranceProvider?: boolean
    insurancePolicy?: boolean
    insurancePhone?: boolean
    photoUrl?: boolean
    isDonor?: boolean
    donorPreferencesEnc?: boolean
    donorVideoUrl?: boolean
    qrToken?: boolean
    qrGeneratedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PatientProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PatientProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PatientProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PatientProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      bloodType: string | null
      allergiesEnc: string | null
      conditionsEnc: string | null
      medicationsEnc: string | null
      insuranceProvider: string | null
      insurancePolicy: string | null
      insurancePhone: string | null
      photoUrl: string | null
      isDonor: boolean
      donorPreferencesEnc: string | null
      donorVideoUrl: string | null
      qrToken: string
      qrGeneratedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["patientProfile"]>
    composites: {}
  }

  type PatientProfileGetPayload<S extends boolean | null | undefined | PatientProfileDefaultArgs> = $Result.GetResult<Prisma.$PatientProfilePayload, S>

  type PatientProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PatientProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PatientProfileCountAggregateInputType | true
    }

  export interface PatientProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PatientProfile'], meta: { name: 'PatientProfile' } }
    /**
     * Find zero or one PatientProfile that matches the filter.
     * @param {PatientProfileFindUniqueArgs} args - Arguments to find a PatientProfile
     * @example
     * // Get one PatientProfile
     * const patientProfile = await prisma.patientProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientProfileFindUniqueArgs>(args: SelectSubset<T, PatientProfileFindUniqueArgs<ExtArgs>>): Prisma__PatientProfileClient<$Result.GetResult<Prisma.$PatientProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PatientProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PatientProfileFindUniqueOrThrowArgs} args - Arguments to find a PatientProfile
     * @example
     * // Get one PatientProfile
     * const patientProfile = await prisma.patientProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientProfileClient<$Result.GetResult<Prisma.$PatientProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PatientProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientProfileFindFirstArgs} args - Arguments to find a PatientProfile
     * @example
     * // Get one PatientProfile
     * const patientProfile = await prisma.patientProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientProfileFindFirstArgs>(args?: SelectSubset<T, PatientProfileFindFirstArgs<ExtArgs>>): Prisma__PatientProfileClient<$Result.GetResult<Prisma.$PatientProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PatientProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientProfileFindFirstOrThrowArgs} args - Arguments to find a PatientProfile
     * @example
     * // Get one PatientProfile
     * const patientProfile = await prisma.patientProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientProfileClient<$Result.GetResult<Prisma.$PatientProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PatientProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PatientProfiles
     * const patientProfiles = await prisma.patientProfile.findMany()
     * 
     * // Get first 10 PatientProfiles
     * const patientProfiles = await prisma.patientProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientProfileWithIdOnly = await prisma.patientProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientProfileFindManyArgs>(args?: SelectSubset<T, PatientProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PatientProfile.
     * @param {PatientProfileCreateArgs} args - Arguments to create a PatientProfile.
     * @example
     * // Create one PatientProfile
     * const PatientProfile = await prisma.patientProfile.create({
     *   data: {
     *     // ... data to create a PatientProfile
     *   }
     * })
     * 
     */
    create<T extends PatientProfileCreateArgs>(args: SelectSubset<T, PatientProfileCreateArgs<ExtArgs>>): Prisma__PatientProfileClient<$Result.GetResult<Prisma.$PatientProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PatientProfiles.
     * @param {PatientProfileCreateManyArgs} args - Arguments to create many PatientProfiles.
     * @example
     * // Create many PatientProfiles
     * const patientProfile = await prisma.patientProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientProfileCreateManyArgs>(args?: SelectSubset<T, PatientProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PatientProfiles and returns the data saved in the database.
     * @param {PatientProfileCreateManyAndReturnArgs} args - Arguments to create many PatientProfiles.
     * @example
     * // Create many PatientProfiles
     * const patientProfile = await prisma.patientProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PatientProfiles and only return the `id`
     * const patientProfileWithIdOnly = await prisma.patientProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PatientProfile.
     * @param {PatientProfileDeleteArgs} args - Arguments to delete one PatientProfile.
     * @example
     * // Delete one PatientProfile
     * const PatientProfile = await prisma.patientProfile.delete({
     *   where: {
     *     // ... filter to delete one PatientProfile
     *   }
     * })
     * 
     */
    delete<T extends PatientProfileDeleteArgs>(args: SelectSubset<T, PatientProfileDeleteArgs<ExtArgs>>): Prisma__PatientProfileClient<$Result.GetResult<Prisma.$PatientProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PatientProfile.
     * @param {PatientProfileUpdateArgs} args - Arguments to update one PatientProfile.
     * @example
     * // Update one PatientProfile
     * const patientProfile = await prisma.patientProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientProfileUpdateArgs>(args: SelectSubset<T, PatientProfileUpdateArgs<ExtArgs>>): Prisma__PatientProfileClient<$Result.GetResult<Prisma.$PatientProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PatientProfiles.
     * @param {PatientProfileDeleteManyArgs} args - Arguments to filter PatientProfiles to delete.
     * @example
     * // Delete a few PatientProfiles
     * const { count } = await prisma.patientProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientProfileDeleteManyArgs>(args?: SelectSubset<T, PatientProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatientProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PatientProfiles
     * const patientProfile = await prisma.patientProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientProfileUpdateManyArgs>(args: SelectSubset<T, PatientProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PatientProfile.
     * @param {PatientProfileUpsertArgs} args - Arguments to update or create a PatientProfile.
     * @example
     * // Update or create a PatientProfile
     * const patientProfile = await prisma.patientProfile.upsert({
     *   create: {
     *     // ... data to create a PatientProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PatientProfile we want to update
     *   }
     * })
     */
    upsert<T extends PatientProfileUpsertArgs>(args: SelectSubset<T, PatientProfileUpsertArgs<ExtArgs>>): Prisma__PatientProfileClient<$Result.GetResult<Prisma.$PatientProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PatientProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientProfileCountArgs} args - Arguments to filter PatientProfiles to count.
     * @example
     * // Count the number of PatientProfiles
     * const count = await prisma.patientProfile.count({
     *   where: {
     *     // ... the filter for the PatientProfiles we want to count
     *   }
     * })
    **/
    count<T extends PatientProfileCountArgs>(
      args?: Subset<T, PatientProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PatientProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientProfileAggregateArgs>(args: Subset<T, PatientProfileAggregateArgs>): Prisma.PrismaPromise<GetPatientProfileAggregateType<T>>

    /**
     * Group by PatientProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientProfileGroupByArgs['orderBy'] }
        : { orderBy?: PatientProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PatientProfile model
   */
  readonly fields: PatientProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PatientProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PatientProfile model
   */ 
  interface PatientProfileFieldRefs {
    readonly id: FieldRef<"PatientProfile", 'String'>
    readonly userId: FieldRef<"PatientProfile", 'String'>
    readonly bloodType: FieldRef<"PatientProfile", 'String'>
    readonly allergiesEnc: FieldRef<"PatientProfile", 'String'>
    readonly conditionsEnc: FieldRef<"PatientProfile", 'String'>
    readonly medicationsEnc: FieldRef<"PatientProfile", 'String'>
    readonly insuranceProvider: FieldRef<"PatientProfile", 'String'>
    readonly insurancePolicy: FieldRef<"PatientProfile", 'String'>
    readonly insurancePhone: FieldRef<"PatientProfile", 'String'>
    readonly photoUrl: FieldRef<"PatientProfile", 'String'>
    readonly isDonor: FieldRef<"PatientProfile", 'Boolean'>
    readonly donorPreferencesEnc: FieldRef<"PatientProfile", 'String'>
    readonly donorVideoUrl: FieldRef<"PatientProfile", 'String'>
    readonly qrToken: FieldRef<"PatientProfile", 'String'>
    readonly qrGeneratedAt: FieldRef<"PatientProfile", 'DateTime'>
    readonly createdAt: FieldRef<"PatientProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"PatientProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PatientProfile findUnique
   */
  export type PatientProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileInclude<ExtArgs> | null
    /**
     * Filter, which PatientProfile to fetch.
     */
    where: PatientProfileWhereUniqueInput
  }

  /**
   * PatientProfile findUniqueOrThrow
   */
  export type PatientProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileInclude<ExtArgs> | null
    /**
     * Filter, which PatientProfile to fetch.
     */
    where: PatientProfileWhereUniqueInput
  }

  /**
   * PatientProfile findFirst
   */
  export type PatientProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileInclude<ExtArgs> | null
    /**
     * Filter, which PatientProfile to fetch.
     */
    where?: PatientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientProfiles to fetch.
     */
    orderBy?: PatientProfileOrderByWithRelationInput | PatientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientProfiles.
     */
    cursor?: PatientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientProfiles.
     */
    distinct?: PatientProfileScalarFieldEnum | PatientProfileScalarFieldEnum[]
  }

  /**
   * PatientProfile findFirstOrThrow
   */
  export type PatientProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileInclude<ExtArgs> | null
    /**
     * Filter, which PatientProfile to fetch.
     */
    where?: PatientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientProfiles to fetch.
     */
    orderBy?: PatientProfileOrderByWithRelationInput | PatientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientProfiles.
     */
    cursor?: PatientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientProfiles.
     */
    distinct?: PatientProfileScalarFieldEnum | PatientProfileScalarFieldEnum[]
  }

  /**
   * PatientProfile findMany
   */
  export type PatientProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileInclude<ExtArgs> | null
    /**
     * Filter, which PatientProfiles to fetch.
     */
    where?: PatientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientProfiles to fetch.
     */
    orderBy?: PatientProfileOrderByWithRelationInput | PatientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PatientProfiles.
     */
    cursor?: PatientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientProfiles.
     */
    skip?: number
    distinct?: PatientProfileScalarFieldEnum | PatientProfileScalarFieldEnum[]
  }

  /**
   * PatientProfile create
   */
  export type PatientProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a PatientProfile.
     */
    data: XOR<PatientProfileCreateInput, PatientProfileUncheckedCreateInput>
  }

  /**
   * PatientProfile createMany
   */
  export type PatientProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PatientProfiles.
     */
    data: PatientProfileCreateManyInput | PatientProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatientProfile createManyAndReturn
   */
  export type PatientProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PatientProfiles.
     */
    data: PatientProfileCreateManyInput | PatientProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatientProfile update
   */
  export type PatientProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a PatientProfile.
     */
    data: XOR<PatientProfileUpdateInput, PatientProfileUncheckedUpdateInput>
    /**
     * Choose, which PatientProfile to update.
     */
    where: PatientProfileWhereUniqueInput
  }

  /**
   * PatientProfile updateMany
   */
  export type PatientProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PatientProfiles.
     */
    data: XOR<PatientProfileUpdateManyMutationInput, PatientProfileUncheckedUpdateManyInput>
    /**
     * Filter which PatientProfiles to update
     */
    where?: PatientProfileWhereInput
  }

  /**
   * PatientProfile upsert
   */
  export type PatientProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the PatientProfile to update in case it exists.
     */
    where: PatientProfileWhereUniqueInput
    /**
     * In case the PatientProfile found by the `where` argument doesn't exist, create a new PatientProfile with this data.
     */
    create: XOR<PatientProfileCreateInput, PatientProfileUncheckedCreateInput>
    /**
     * In case the PatientProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientProfileUpdateInput, PatientProfileUncheckedUpdateInput>
  }

  /**
   * PatientProfile delete
   */
  export type PatientProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileInclude<ExtArgs> | null
    /**
     * Filter which PatientProfile to delete.
     */
    where: PatientProfileWhereUniqueInput
  }

  /**
   * PatientProfile deleteMany
   */
  export type PatientProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientProfiles to delete
     */
    where?: PatientProfileWhereInput
  }

  /**
   * PatientProfile without action
   */
  export type PatientProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientProfile
     */
    select?: PatientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientProfileInclude<ExtArgs> | null
  }


  /**
   * Model Representative
   */

  export type AggregateRepresentative = {
    _count: RepresentativeCountAggregateOutputType | null
    _avg: RepresentativeAvgAggregateOutputType | null
    _sum: RepresentativeSumAggregateOutputType | null
    _min: RepresentativeMinAggregateOutputType | null
    _max: RepresentativeMaxAggregateOutputType | null
  }

  export type RepresentativeAvgAggregateOutputType = {
    priority: number | null
  }

  export type RepresentativeSumAggregateOutputType = {
    priority: number | null
  }

  export type RepresentativeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    phone: string | null
    email: string | null
    relation: string | null
    priority: number | null
    isDonorSpokesperson: boolean | null
    notifyOnEmergency: boolean | null
    notifyOnAccess: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RepresentativeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    phone: string | null
    email: string | null
    relation: string | null
    priority: number | null
    isDonorSpokesperson: boolean | null
    notifyOnEmergency: boolean | null
    notifyOnAccess: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RepresentativeCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    phone: number
    email: number
    relation: number
    priority: number
    isDonorSpokesperson: number
    notifyOnEmergency: number
    notifyOnAccess: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RepresentativeAvgAggregateInputType = {
    priority?: true
  }

  export type RepresentativeSumAggregateInputType = {
    priority?: true
  }

  export type RepresentativeMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    phone?: true
    email?: true
    relation?: true
    priority?: true
    isDonorSpokesperson?: true
    notifyOnEmergency?: true
    notifyOnAccess?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RepresentativeMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    phone?: true
    email?: true
    relation?: true
    priority?: true
    isDonorSpokesperson?: true
    notifyOnEmergency?: true
    notifyOnAccess?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RepresentativeCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    phone?: true
    email?: true
    relation?: true
    priority?: true
    isDonorSpokesperson?: true
    notifyOnEmergency?: true
    notifyOnAccess?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RepresentativeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Representative to aggregate.
     */
    where?: RepresentativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Representatives to fetch.
     */
    orderBy?: RepresentativeOrderByWithRelationInput | RepresentativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RepresentativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Representatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Representatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Representatives
    **/
    _count?: true | RepresentativeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RepresentativeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RepresentativeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RepresentativeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RepresentativeMaxAggregateInputType
  }

  export type GetRepresentativeAggregateType<T extends RepresentativeAggregateArgs> = {
        [P in keyof T & keyof AggregateRepresentative]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepresentative[P]>
      : GetScalarType<T[P], AggregateRepresentative[P]>
  }




  export type RepresentativeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepresentativeWhereInput
    orderBy?: RepresentativeOrderByWithAggregationInput | RepresentativeOrderByWithAggregationInput[]
    by: RepresentativeScalarFieldEnum[] | RepresentativeScalarFieldEnum
    having?: RepresentativeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RepresentativeCountAggregateInputType | true
    _avg?: RepresentativeAvgAggregateInputType
    _sum?: RepresentativeSumAggregateInputType
    _min?: RepresentativeMinAggregateInputType
    _max?: RepresentativeMaxAggregateInputType
  }

  export type RepresentativeGroupByOutputType = {
    id: string
    userId: string
    name: string
    phone: string
    email: string | null
    relation: string
    priority: number
    isDonorSpokesperson: boolean
    notifyOnEmergency: boolean
    notifyOnAccess: boolean
    createdAt: Date
    updatedAt: Date
    _count: RepresentativeCountAggregateOutputType | null
    _avg: RepresentativeAvgAggregateOutputType | null
    _sum: RepresentativeSumAggregateOutputType | null
    _min: RepresentativeMinAggregateOutputType | null
    _max: RepresentativeMaxAggregateOutputType | null
  }

  type GetRepresentativeGroupByPayload<T extends RepresentativeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RepresentativeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RepresentativeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RepresentativeGroupByOutputType[P]>
            : GetScalarType<T[P], RepresentativeGroupByOutputType[P]>
        }
      >
    >


  export type RepresentativeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    relation?: boolean
    priority?: boolean
    isDonorSpokesperson?: boolean
    notifyOnEmergency?: boolean
    notifyOnAccess?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["representative"]>

  export type RepresentativeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    relation?: boolean
    priority?: boolean
    isDonorSpokesperson?: boolean
    notifyOnEmergency?: boolean
    notifyOnAccess?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["representative"]>

  export type RepresentativeSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    relation?: boolean
    priority?: boolean
    isDonorSpokesperson?: boolean
    notifyOnEmergency?: boolean
    notifyOnAccess?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RepresentativeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RepresentativeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RepresentativePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Representative"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      phone: string
      email: string | null
      relation: string
      priority: number
      isDonorSpokesperson: boolean
      notifyOnEmergency: boolean
      notifyOnAccess: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["representative"]>
    composites: {}
  }

  type RepresentativeGetPayload<S extends boolean | null | undefined | RepresentativeDefaultArgs> = $Result.GetResult<Prisma.$RepresentativePayload, S>

  type RepresentativeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RepresentativeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RepresentativeCountAggregateInputType | true
    }

  export interface RepresentativeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Representative'], meta: { name: 'Representative' } }
    /**
     * Find zero or one Representative that matches the filter.
     * @param {RepresentativeFindUniqueArgs} args - Arguments to find a Representative
     * @example
     * // Get one Representative
     * const representative = await prisma.representative.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RepresentativeFindUniqueArgs>(args: SelectSubset<T, RepresentativeFindUniqueArgs<ExtArgs>>): Prisma__RepresentativeClient<$Result.GetResult<Prisma.$RepresentativePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Representative that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RepresentativeFindUniqueOrThrowArgs} args - Arguments to find a Representative
     * @example
     * // Get one Representative
     * const representative = await prisma.representative.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RepresentativeFindUniqueOrThrowArgs>(args: SelectSubset<T, RepresentativeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RepresentativeClient<$Result.GetResult<Prisma.$RepresentativePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Representative that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepresentativeFindFirstArgs} args - Arguments to find a Representative
     * @example
     * // Get one Representative
     * const representative = await prisma.representative.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RepresentativeFindFirstArgs>(args?: SelectSubset<T, RepresentativeFindFirstArgs<ExtArgs>>): Prisma__RepresentativeClient<$Result.GetResult<Prisma.$RepresentativePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Representative that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepresentativeFindFirstOrThrowArgs} args - Arguments to find a Representative
     * @example
     * // Get one Representative
     * const representative = await prisma.representative.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RepresentativeFindFirstOrThrowArgs>(args?: SelectSubset<T, RepresentativeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RepresentativeClient<$Result.GetResult<Prisma.$RepresentativePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Representatives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepresentativeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Representatives
     * const representatives = await prisma.representative.findMany()
     * 
     * // Get first 10 Representatives
     * const representatives = await prisma.representative.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const representativeWithIdOnly = await prisma.representative.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RepresentativeFindManyArgs>(args?: SelectSubset<T, RepresentativeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepresentativePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Representative.
     * @param {RepresentativeCreateArgs} args - Arguments to create a Representative.
     * @example
     * // Create one Representative
     * const Representative = await prisma.representative.create({
     *   data: {
     *     // ... data to create a Representative
     *   }
     * })
     * 
     */
    create<T extends RepresentativeCreateArgs>(args: SelectSubset<T, RepresentativeCreateArgs<ExtArgs>>): Prisma__RepresentativeClient<$Result.GetResult<Prisma.$RepresentativePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Representatives.
     * @param {RepresentativeCreateManyArgs} args - Arguments to create many Representatives.
     * @example
     * // Create many Representatives
     * const representative = await prisma.representative.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RepresentativeCreateManyArgs>(args?: SelectSubset<T, RepresentativeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Representatives and returns the data saved in the database.
     * @param {RepresentativeCreateManyAndReturnArgs} args - Arguments to create many Representatives.
     * @example
     * // Create many Representatives
     * const representative = await prisma.representative.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Representatives and only return the `id`
     * const representativeWithIdOnly = await prisma.representative.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RepresentativeCreateManyAndReturnArgs>(args?: SelectSubset<T, RepresentativeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepresentativePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Representative.
     * @param {RepresentativeDeleteArgs} args - Arguments to delete one Representative.
     * @example
     * // Delete one Representative
     * const Representative = await prisma.representative.delete({
     *   where: {
     *     // ... filter to delete one Representative
     *   }
     * })
     * 
     */
    delete<T extends RepresentativeDeleteArgs>(args: SelectSubset<T, RepresentativeDeleteArgs<ExtArgs>>): Prisma__RepresentativeClient<$Result.GetResult<Prisma.$RepresentativePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Representative.
     * @param {RepresentativeUpdateArgs} args - Arguments to update one Representative.
     * @example
     * // Update one Representative
     * const representative = await prisma.representative.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RepresentativeUpdateArgs>(args: SelectSubset<T, RepresentativeUpdateArgs<ExtArgs>>): Prisma__RepresentativeClient<$Result.GetResult<Prisma.$RepresentativePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Representatives.
     * @param {RepresentativeDeleteManyArgs} args - Arguments to filter Representatives to delete.
     * @example
     * // Delete a few Representatives
     * const { count } = await prisma.representative.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RepresentativeDeleteManyArgs>(args?: SelectSubset<T, RepresentativeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Representatives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepresentativeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Representatives
     * const representative = await prisma.representative.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RepresentativeUpdateManyArgs>(args: SelectSubset<T, RepresentativeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Representative.
     * @param {RepresentativeUpsertArgs} args - Arguments to update or create a Representative.
     * @example
     * // Update or create a Representative
     * const representative = await prisma.representative.upsert({
     *   create: {
     *     // ... data to create a Representative
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Representative we want to update
     *   }
     * })
     */
    upsert<T extends RepresentativeUpsertArgs>(args: SelectSubset<T, RepresentativeUpsertArgs<ExtArgs>>): Prisma__RepresentativeClient<$Result.GetResult<Prisma.$RepresentativePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Representatives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepresentativeCountArgs} args - Arguments to filter Representatives to count.
     * @example
     * // Count the number of Representatives
     * const count = await prisma.representative.count({
     *   where: {
     *     // ... the filter for the Representatives we want to count
     *   }
     * })
    **/
    count<T extends RepresentativeCountArgs>(
      args?: Subset<T, RepresentativeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RepresentativeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Representative.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepresentativeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RepresentativeAggregateArgs>(args: Subset<T, RepresentativeAggregateArgs>): Prisma.PrismaPromise<GetRepresentativeAggregateType<T>>

    /**
     * Group by Representative.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepresentativeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RepresentativeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RepresentativeGroupByArgs['orderBy'] }
        : { orderBy?: RepresentativeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RepresentativeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepresentativeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Representative model
   */
  readonly fields: RepresentativeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Representative.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RepresentativeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Representative model
   */ 
  interface RepresentativeFieldRefs {
    readonly id: FieldRef<"Representative", 'String'>
    readonly userId: FieldRef<"Representative", 'String'>
    readonly name: FieldRef<"Representative", 'String'>
    readonly phone: FieldRef<"Representative", 'String'>
    readonly email: FieldRef<"Representative", 'String'>
    readonly relation: FieldRef<"Representative", 'String'>
    readonly priority: FieldRef<"Representative", 'Int'>
    readonly isDonorSpokesperson: FieldRef<"Representative", 'Boolean'>
    readonly notifyOnEmergency: FieldRef<"Representative", 'Boolean'>
    readonly notifyOnAccess: FieldRef<"Representative", 'Boolean'>
    readonly createdAt: FieldRef<"Representative", 'DateTime'>
    readonly updatedAt: FieldRef<"Representative", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Representative findUnique
   */
  export type RepresentativeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Representative
     */
    select?: RepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepresentativeInclude<ExtArgs> | null
    /**
     * Filter, which Representative to fetch.
     */
    where: RepresentativeWhereUniqueInput
  }

  /**
   * Representative findUniqueOrThrow
   */
  export type RepresentativeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Representative
     */
    select?: RepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepresentativeInclude<ExtArgs> | null
    /**
     * Filter, which Representative to fetch.
     */
    where: RepresentativeWhereUniqueInput
  }

  /**
   * Representative findFirst
   */
  export type RepresentativeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Representative
     */
    select?: RepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepresentativeInclude<ExtArgs> | null
    /**
     * Filter, which Representative to fetch.
     */
    where?: RepresentativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Representatives to fetch.
     */
    orderBy?: RepresentativeOrderByWithRelationInput | RepresentativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Representatives.
     */
    cursor?: RepresentativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Representatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Representatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Representatives.
     */
    distinct?: RepresentativeScalarFieldEnum | RepresentativeScalarFieldEnum[]
  }

  /**
   * Representative findFirstOrThrow
   */
  export type RepresentativeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Representative
     */
    select?: RepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepresentativeInclude<ExtArgs> | null
    /**
     * Filter, which Representative to fetch.
     */
    where?: RepresentativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Representatives to fetch.
     */
    orderBy?: RepresentativeOrderByWithRelationInput | RepresentativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Representatives.
     */
    cursor?: RepresentativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Representatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Representatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Representatives.
     */
    distinct?: RepresentativeScalarFieldEnum | RepresentativeScalarFieldEnum[]
  }

  /**
   * Representative findMany
   */
  export type RepresentativeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Representative
     */
    select?: RepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepresentativeInclude<ExtArgs> | null
    /**
     * Filter, which Representatives to fetch.
     */
    where?: RepresentativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Representatives to fetch.
     */
    orderBy?: RepresentativeOrderByWithRelationInput | RepresentativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Representatives.
     */
    cursor?: RepresentativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Representatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Representatives.
     */
    skip?: number
    distinct?: RepresentativeScalarFieldEnum | RepresentativeScalarFieldEnum[]
  }

  /**
   * Representative create
   */
  export type RepresentativeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Representative
     */
    select?: RepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepresentativeInclude<ExtArgs> | null
    /**
     * The data needed to create a Representative.
     */
    data: XOR<RepresentativeCreateInput, RepresentativeUncheckedCreateInput>
  }

  /**
   * Representative createMany
   */
  export type RepresentativeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Representatives.
     */
    data: RepresentativeCreateManyInput | RepresentativeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Representative createManyAndReturn
   */
  export type RepresentativeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Representative
     */
    select?: RepresentativeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Representatives.
     */
    data: RepresentativeCreateManyInput | RepresentativeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepresentativeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Representative update
   */
  export type RepresentativeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Representative
     */
    select?: RepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepresentativeInclude<ExtArgs> | null
    /**
     * The data needed to update a Representative.
     */
    data: XOR<RepresentativeUpdateInput, RepresentativeUncheckedUpdateInput>
    /**
     * Choose, which Representative to update.
     */
    where: RepresentativeWhereUniqueInput
  }

  /**
   * Representative updateMany
   */
  export type RepresentativeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Representatives.
     */
    data: XOR<RepresentativeUpdateManyMutationInput, RepresentativeUncheckedUpdateManyInput>
    /**
     * Filter which Representatives to update
     */
    where?: RepresentativeWhereInput
  }

  /**
   * Representative upsert
   */
  export type RepresentativeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Representative
     */
    select?: RepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepresentativeInclude<ExtArgs> | null
    /**
     * The filter to search for the Representative to update in case it exists.
     */
    where: RepresentativeWhereUniqueInput
    /**
     * In case the Representative found by the `where` argument doesn't exist, create a new Representative with this data.
     */
    create: XOR<RepresentativeCreateInput, RepresentativeUncheckedCreateInput>
    /**
     * In case the Representative was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RepresentativeUpdateInput, RepresentativeUncheckedUpdateInput>
  }

  /**
   * Representative delete
   */
  export type RepresentativeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Representative
     */
    select?: RepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepresentativeInclude<ExtArgs> | null
    /**
     * Filter which Representative to delete.
     */
    where: RepresentativeWhereUniqueInput
  }

  /**
   * Representative deleteMany
   */
  export type RepresentativeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Representatives to delete
     */
    where?: RepresentativeWhereInput
  }

  /**
   * Representative without action
   */
  export type RepresentativeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Representative
     */
    select?: RepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepresentativeInclude<ExtArgs> | null
  }


  /**
   * Model AdvanceDirective
   */

  export type AggregateAdvanceDirective = {
    _count: AdvanceDirectiveCountAggregateOutputType | null
    _min: AdvanceDirectiveMinAggregateOutputType | null
    _max: AdvanceDirectiveMaxAggregateOutputType | null
  }

  export type AdvanceDirectiveMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.DirectiveType | null
    status: $Enums.DirectiveStatus | null
    documentUrl: string | null
    documentHash: string | null
    originalFileName: string | null
    nom151Sealed: boolean | null
    nom151Timestamp: Date | null
    nom151Certificate: string | null
    nom151Provider: string | null
    acceptsCPR: boolean | null
    acceptsIntubation: boolean | null
    acceptsDialysis: boolean | null
    acceptsTransfusion: boolean | null
    acceptsArtificialNutrition: boolean | null
    palliativeCareOnly: boolean | null
    additionalNotes: string | null
    originState: string | null
    legalBasisSummary: string | null
    validatedAt: Date | null
    validatedBy: string | null
    validationMethod: string | null
    createdAt: Date | null
    updatedAt: Date | null
    revokedAt: Date | null
    expiresAt: Date | null
  }

  export type AdvanceDirectiveMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.DirectiveType | null
    status: $Enums.DirectiveStatus | null
    documentUrl: string | null
    documentHash: string | null
    originalFileName: string | null
    nom151Sealed: boolean | null
    nom151Timestamp: Date | null
    nom151Certificate: string | null
    nom151Provider: string | null
    acceptsCPR: boolean | null
    acceptsIntubation: boolean | null
    acceptsDialysis: boolean | null
    acceptsTransfusion: boolean | null
    acceptsArtificialNutrition: boolean | null
    palliativeCareOnly: boolean | null
    additionalNotes: string | null
    originState: string | null
    legalBasisSummary: string | null
    validatedAt: Date | null
    validatedBy: string | null
    validationMethod: string | null
    createdAt: Date | null
    updatedAt: Date | null
    revokedAt: Date | null
    expiresAt: Date | null
  }

  export type AdvanceDirectiveCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    status: number
    documentUrl: number
    documentHash: number
    originalFileName: number
    nom151Sealed: number
    nom151Timestamp: number
    nom151Certificate: number
    nom151Provider: number
    acceptsCPR: number
    acceptsIntubation: number
    acceptsDialysis: number
    acceptsTransfusion: number
    acceptsArtificialNutrition: number
    palliativeCareOnly: number
    additionalNotes: number
    originState: number
    legalBasisSummary: number
    validatedAt: number
    validatedBy: number
    validationMethod: number
    createdAt: number
    updatedAt: number
    revokedAt: number
    expiresAt: number
    _all: number
  }


  export type AdvanceDirectiveMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    status?: true
    documentUrl?: true
    documentHash?: true
    originalFileName?: true
    nom151Sealed?: true
    nom151Timestamp?: true
    nom151Certificate?: true
    nom151Provider?: true
    acceptsCPR?: true
    acceptsIntubation?: true
    acceptsDialysis?: true
    acceptsTransfusion?: true
    acceptsArtificialNutrition?: true
    palliativeCareOnly?: true
    additionalNotes?: true
    originState?: true
    legalBasisSummary?: true
    validatedAt?: true
    validatedBy?: true
    validationMethod?: true
    createdAt?: true
    updatedAt?: true
    revokedAt?: true
    expiresAt?: true
  }

  export type AdvanceDirectiveMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    status?: true
    documentUrl?: true
    documentHash?: true
    originalFileName?: true
    nom151Sealed?: true
    nom151Timestamp?: true
    nom151Certificate?: true
    nom151Provider?: true
    acceptsCPR?: true
    acceptsIntubation?: true
    acceptsDialysis?: true
    acceptsTransfusion?: true
    acceptsArtificialNutrition?: true
    palliativeCareOnly?: true
    additionalNotes?: true
    originState?: true
    legalBasisSummary?: true
    validatedAt?: true
    validatedBy?: true
    validationMethod?: true
    createdAt?: true
    updatedAt?: true
    revokedAt?: true
    expiresAt?: true
  }

  export type AdvanceDirectiveCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    status?: true
    documentUrl?: true
    documentHash?: true
    originalFileName?: true
    nom151Sealed?: true
    nom151Timestamp?: true
    nom151Certificate?: true
    nom151Provider?: true
    acceptsCPR?: true
    acceptsIntubation?: true
    acceptsDialysis?: true
    acceptsTransfusion?: true
    acceptsArtificialNutrition?: true
    palliativeCareOnly?: true
    additionalNotes?: true
    originState?: true
    legalBasisSummary?: true
    validatedAt?: true
    validatedBy?: true
    validationMethod?: true
    createdAt?: true
    updatedAt?: true
    revokedAt?: true
    expiresAt?: true
    _all?: true
  }

  export type AdvanceDirectiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdvanceDirective to aggregate.
     */
    where?: AdvanceDirectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvanceDirectives to fetch.
     */
    orderBy?: AdvanceDirectiveOrderByWithRelationInput | AdvanceDirectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdvanceDirectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvanceDirectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvanceDirectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdvanceDirectives
    **/
    _count?: true | AdvanceDirectiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdvanceDirectiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdvanceDirectiveMaxAggregateInputType
  }

  export type GetAdvanceDirectiveAggregateType<T extends AdvanceDirectiveAggregateArgs> = {
        [P in keyof T & keyof AggregateAdvanceDirective]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdvanceDirective[P]>
      : GetScalarType<T[P], AggregateAdvanceDirective[P]>
  }




  export type AdvanceDirectiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvanceDirectiveWhereInput
    orderBy?: AdvanceDirectiveOrderByWithAggregationInput | AdvanceDirectiveOrderByWithAggregationInput[]
    by: AdvanceDirectiveScalarFieldEnum[] | AdvanceDirectiveScalarFieldEnum
    having?: AdvanceDirectiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdvanceDirectiveCountAggregateInputType | true
    _min?: AdvanceDirectiveMinAggregateInputType
    _max?: AdvanceDirectiveMaxAggregateInputType
  }

  export type AdvanceDirectiveGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.DirectiveType
    status: $Enums.DirectiveStatus
    documentUrl: string | null
    documentHash: string | null
    originalFileName: string | null
    nom151Sealed: boolean
    nom151Timestamp: Date | null
    nom151Certificate: string | null
    nom151Provider: string | null
    acceptsCPR: boolean | null
    acceptsIntubation: boolean | null
    acceptsDialysis: boolean | null
    acceptsTransfusion: boolean | null
    acceptsArtificialNutrition: boolean | null
    palliativeCareOnly: boolean | null
    additionalNotes: string | null
    originState: string | null
    legalBasisSummary: string | null
    validatedAt: Date | null
    validatedBy: string | null
    validationMethod: string | null
    createdAt: Date
    updatedAt: Date
    revokedAt: Date | null
    expiresAt: Date | null
    _count: AdvanceDirectiveCountAggregateOutputType | null
    _min: AdvanceDirectiveMinAggregateOutputType | null
    _max: AdvanceDirectiveMaxAggregateOutputType | null
  }

  type GetAdvanceDirectiveGroupByPayload<T extends AdvanceDirectiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdvanceDirectiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdvanceDirectiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdvanceDirectiveGroupByOutputType[P]>
            : GetScalarType<T[P], AdvanceDirectiveGroupByOutputType[P]>
        }
      >
    >


  export type AdvanceDirectiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    documentUrl?: boolean
    documentHash?: boolean
    originalFileName?: boolean
    nom151Sealed?: boolean
    nom151Timestamp?: boolean
    nom151Certificate?: boolean
    nom151Provider?: boolean
    acceptsCPR?: boolean
    acceptsIntubation?: boolean
    acceptsDialysis?: boolean
    acceptsTransfusion?: boolean
    acceptsArtificialNutrition?: boolean
    palliativeCareOnly?: boolean
    additionalNotes?: boolean
    originState?: boolean
    legalBasisSummary?: boolean
    validatedAt?: boolean
    validatedBy?: boolean
    validationMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    revokedAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    witnesses?: boolean | AdvanceDirective$witnessesArgs<ExtArgs>
    _count?: boolean | AdvanceDirectiveCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["advanceDirective"]>

  export type AdvanceDirectiveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    documentUrl?: boolean
    documentHash?: boolean
    originalFileName?: boolean
    nom151Sealed?: boolean
    nom151Timestamp?: boolean
    nom151Certificate?: boolean
    nom151Provider?: boolean
    acceptsCPR?: boolean
    acceptsIntubation?: boolean
    acceptsDialysis?: boolean
    acceptsTransfusion?: boolean
    acceptsArtificialNutrition?: boolean
    palliativeCareOnly?: boolean
    additionalNotes?: boolean
    originState?: boolean
    legalBasisSummary?: boolean
    validatedAt?: boolean
    validatedBy?: boolean
    validationMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    revokedAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["advanceDirective"]>

  export type AdvanceDirectiveSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    documentUrl?: boolean
    documentHash?: boolean
    originalFileName?: boolean
    nom151Sealed?: boolean
    nom151Timestamp?: boolean
    nom151Certificate?: boolean
    nom151Provider?: boolean
    acceptsCPR?: boolean
    acceptsIntubation?: boolean
    acceptsDialysis?: boolean
    acceptsTransfusion?: boolean
    acceptsArtificialNutrition?: boolean
    palliativeCareOnly?: boolean
    additionalNotes?: boolean
    originState?: boolean
    legalBasisSummary?: boolean
    validatedAt?: boolean
    validatedBy?: boolean
    validationMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    revokedAt?: boolean
    expiresAt?: boolean
  }

  export type AdvanceDirectiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    witnesses?: boolean | AdvanceDirective$witnessesArgs<ExtArgs>
    _count?: boolean | AdvanceDirectiveCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdvanceDirectiveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdvanceDirectivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdvanceDirective"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      witnesses: Prisma.$WitnessPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.DirectiveType
      status: $Enums.DirectiveStatus
      documentUrl: string | null
      documentHash: string | null
      originalFileName: string | null
      nom151Sealed: boolean
      nom151Timestamp: Date | null
      nom151Certificate: string | null
      nom151Provider: string | null
      acceptsCPR: boolean | null
      acceptsIntubation: boolean | null
      acceptsDialysis: boolean | null
      acceptsTransfusion: boolean | null
      acceptsArtificialNutrition: boolean | null
      palliativeCareOnly: boolean | null
      additionalNotes: string | null
      originState: string | null
      legalBasisSummary: string | null
      validatedAt: Date | null
      validatedBy: string | null
      validationMethod: string | null
      createdAt: Date
      updatedAt: Date
      revokedAt: Date | null
      expiresAt: Date | null
    }, ExtArgs["result"]["advanceDirective"]>
    composites: {}
  }

  type AdvanceDirectiveGetPayload<S extends boolean | null | undefined | AdvanceDirectiveDefaultArgs> = $Result.GetResult<Prisma.$AdvanceDirectivePayload, S>

  type AdvanceDirectiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdvanceDirectiveFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdvanceDirectiveCountAggregateInputType | true
    }

  export interface AdvanceDirectiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdvanceDirective'], meta: { name: 'AdvanceDirective' } }
    /**
     * Find zero or one AdvanceDirective that matches the filter.
     * @param {AdvanceDirectiveFindUniqueArgs} args - Arguments to find a AdvanceDirective
     * @example
     * // Get one AdvanceDirective
     * const advanceDirective = await prisma.advanceDirective.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdvanceDirectiveFindUniqueArgs>(args: SelectSubset<T, AdvanceDirectiveFindUniqueArgs<ExtArgs>>): Prisma__AdvanceDirectiveClient<$Result.GetResult<Prisma.$AdvanceDirectivePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdvanceDirective that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdvanceDirectiveFindUniqueOrThrowArgs} args - Arguments to find a AdvanceDirective
     * @example
     * // Get one AdvanceDirective
     * const advanceDirective = await prisma.advanceDirective.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdvanceDirectiveFindUniqueOrThrowArgs>(args: SelectSubset<T, AdvanceDirectiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdvanceDirectiveClient<$Result.GetResult<Prisma.$AdvanceDirectivePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdvanceDirective that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvanceDirectiveFindFirstArgs} args - Arguments to find a AdvanceDirective
     * @example
     * // Get one AdvanceDirective
     * const advanceDirective = await prisma.advanceDirective.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdvanceDirectiveFindFirstArgs>(args?: SelectSubset<T, AdvanceDirectiveFindFirstArgs<ExtArgs>>): Prisma__AdvanceDirectiveClient<$Result.GetResult<Prisma.$AdvanceDirectivePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdvanceDirective that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvanceDirectiveFindFirstOrThrowArgs} args - Arguments to find a AdvanceDirective
     * @example
     * // Get one AdvanceDirective
     * const advanceDirective = await prisma.advanceDirective.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdvanceDirectiveFindFirstOrThrowArgs>(args?: SelectSubset<T, AdvanceDirectiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdvanceDirectiveClient<$Result.GetResult<Prisma.$AdvanceDirectivePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdvanceDirectives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvanceDirectiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdvanceDirectives
     * const advanceDirectives = await prisma.advanceDirective.findMany()
     * 
     * // Get first 10 AdvanceDirectives
     * const advanceDirectives = await prisma.advanceDirective.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const advanceDirectiveWithIdOnly = await prisma.advanceDirective.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdvanceDirectiveFindManyArgs>(args?: SelectSubset<T, AdvanceDirectiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvanceDirectivePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdvanceDirective.
     * @param {AdvanceDirectiveCreateArgs} args - Arguments to create a AdvanceDirective.
     * @example
     * // Create one AdvanceDirective
     * const AdvanceDirective = await prisma.advanceDirective.create({
     *   data: {
     *     // ... data to create a AdvanceDirective
     *   }
     * })
     * 
     */
    create<T extends AdvanceDirectiveCreateArgs>(args: SelectSubset<T, AdvanceDirectiveCreateArgs<ExtArgs>>): Prisma__AdvanceDirectiveClient<$Result.GetResult<Prisma.$AdvanceDirectivePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdvanceDirectives.
     * @param {AdvanceDirectiveCreateManyArgs} args - Arguments to create many AdvanceDirectives.
     * @example
     * // Create many AdvanceDirectives
     * const advanceDirective = await prisma.advanceDirective.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdvanceDirectiveCreateManyArgs>(args?: SelectSubset<T, AdvanceDirectiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdvanceDirectives and returns the data saved in the database.
     * @param {AdvanceDirectiveCreateManyAndReturnArgs} args - Arguments to create many AdvanceDirectives.
     * @example
     * // Create many AdvanceDirectives
     * const advanceDirective = await prisma.advanceDirective.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdvanceDirectives and only return the `id`
     * const advanceDirectiveWithIdOnly = await prisma.advanceDirective.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdvanceDirectiveCreateManyAndReturnArgs>(args?: SelectSubset<T, AdvanceDirectiveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvanceDirectivePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdvanceDirective.
     * @param {AdvanceDirectiveDeleteArgs} args - Arguments to delete one AdvanceDirective.
     * @example
     * // Delete one AdvanceDirective
     * const AdvanceDirective = await prisma.advanceDirective.delete({
     *   where: {
     *     // ... filter to delete one AdvanceDirective
     *   }
     * })
     * 
     */
    delete<T extends AdvanceDirectiveDeleteArgs>(args: SelectSubset<T, AdvanceDirectiveDeleteArgs<ExtArgs>>): Prisma__AdvanceDirectiveClient<$Result.GetResult<Prisma.$AdvanceDirectivePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdvanceDirective.
     * @param {AdvanceDirectiveUpdateArgs} args - Arguments to update one AdvanceDirective.
     * @example
     * // Update one AdvanceDirective
     * const advanceDirective = await prisma.advanceDirective.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdvanceDirectiveUpdateArgs>(args: SelectSubset<T, AdvanceDirectiveUpdateArgs<ExtArgs>>): Prisma__AdvanceDirectiveClient<$Result.GetResult<Prisma.$AdvanceDirectivePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdvanceDirectives.
     * @param {AdvanceDirectiveDeleteManyArgs} args - Arguments to filter AdvanceDirectives to delete.
     * @example
     * // Delete a few AdvanceDirectives
     * const { count } = await prisma.advanceDirective.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdvanceDirectiveDeleteManyArgs>(args?: SelectSubset<T, AdvanceDirectiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdvanceDirectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvanceDirectiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdvanceDirectives
     * const advanceDirective = await prisma.advanceDirective.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdvanceDirectiveUpdateManyArgs>(args: SelectSubset<T, AdvanceDirectiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdvanceDirective.
     * @param {AdvanceDirectiveUpsertArgs} args - Arguments to update or create a AdvanceDirective.
     * @example
     * // Update or create a AdvanceDirective
     * const advanceDirective = await prisma.advanceDirective.upsert({
     *   create: {
     *     // ... data to create a AdvanceDirective
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdvanceDirective we want to update
     *   }
     * })
     */
    upsert<T extends AdvanceDirectiveUpsertArgs>(args: SelectSubset<T, AdvanceDirectiveUpsertArgs<ExtArgs>>): Prisma__AdvanceDirectiveClient<$Result.GetResult<Prisma.$AdvanceDirectivePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdvanceDirectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvanceDirectiveCountArgs} args - Arguments to filter AdvanceDirectives to count.
     * @example
     * // Count the number of AdvanceDirectives
     * const count = await prisma.advanceDirective.count({
     *   where: {
     *     // ... the filter for the AdvanceDirectives we want to count
     *   }
     * })
    **/
    count<T extends AdvanceDirectiveCountArgs>(
      args?: Subset<T, AdvanceDirectiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdvanceDirectiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdvanceDirective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvanceDirectiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdvanceDirectiveAggregateArgs>(args: Subset<T, AdvanceDirectiveAggregateArgs>): Prisma.PrismaPromise<GetAdvanceDirectiveAggregateType<T>>

    /**
     * Group by AdvanceDirective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvanceDirectiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdvanceDirectiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdvanceDirectiveGroupByArgs['orderBy'] }
        : { orderBy?: AdvanceDirectiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdvanceDirectiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdvanceDirectiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdvanceDirective model
   */
  readonly fields: AdvanceDirectiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdvanceDirective.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdvanceDirectiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    witnesses<T extends AdvanceDirective$witnessesArgs<ExtArgs> = {}>(args?: Subset<T, AdvanceDirective$witnessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WitnessPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdvanceDirective model
   */ 
  interface AdvanceDirectiveFieldRefs {
    readonly id: FieldRef<"AdvanceDirective", 'String'>
    readonly userId: FieldRef<"AdvanceDirective", 'String'>
    readonly type: FieldRef<"AdvanceDirective", 'DirectiveType'>
    readonly status: FieldRef<"AdvanceDirective", 'DirectiveStatus'>
    readonly documentUrl: FieldRef<"AdvanceDirective", 'String'>
    readonly documentHash: FieldRef<"AdvanceDirective", 'String'>
    readonly originalFileName: FieldRef<"AdvanceDirective", 'String'>
    readonly nom151Sealed: FieldRef<"AdvanceDirective", 'Boolean'>
    readonly nom151Timestamp: FieldRef<"AdvanceDirective", 'DateTime'>
    readonly nom151Certificate: FieldRef<"AdvanceDirective", 'String'>
    readonly nom151Provider: FieldRef<"AdvanceDirective", 'String'>
    readonly acceptsCPR: FieldRef<"AdvanceDirective", 'Boolean'>
    readonly acceptsIntubation: FieldRef<"AdvanceDirective", 'Boolean'>
    readonly acceptsDialysis: FieldRef<"AdvanceDirective", 'Boolean'>
    readonly acceptsTransfusion: FieldRef<"AdvanceDirective", 'Boolean'>
    readonly acceptsArtificialNutrition: FieldRef<"AdvanceDirective", 'Boolean'>
    readonly palliativeCareOnly: FieldRef<"AdvanceDirective", 'Boolean'>
    readonly additionalNotes: FieldRef<"AdvanceDirective", 'String'>
    readonly originState: FieldRef<"AdvanceDirective", 'String'>
    readonly legalBasisSummary: FieldRef<"AdvanceDirective", 'String'>
    readonly validatedAt: FieldRef<"AdvanceDirective", 'DateTime'>
    readonly validatedBy: FieldRef<"AdvanceDirective", 'String'>
    readonly validationMethod: FieldRef<"AdvanceDirective", 'String'>
    readonly createdAt: FieldRef<"AdvanceDirective", 'DateTime'>
    readonly updatedAt: FieldRef<"AdvanceDirective", 'DateTime'>
    readonly revokedAt: FieldRef<"AdvanceDirective", 'DateTime'>
    readonly expiresAt: FieldRef<"AdvanceDirective", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdvanceDirective findUnique
   */
  export type AdvanceDirectiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvanceDirective
     */
    select?: AdvanceDirectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvanceDirectiveInclude<ExtArgs> | null
    /**
     * Filter, which AdvanceDirective to fetch.
     */
    where: AdvanceDirectiveWhereUniqueInput
  }

  /**
   * AdvanceDirective findUniqueOrThrow
   */
  export type AdvanceDirectiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvanceDirective
     */
    select?: AdvanceDirectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvanceDirectiveInclude<ExtArgs> | null
    /**
     * Filter, which AdvanceDirective to fetch.
     */
    where: AdvanceDirectiveWhereUniqueInput
  }

  /**
   * AdvanceDirective findFirst
   */
  export type AdvanceDirectiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvanceDirective
     */
    select?: AdvanceDirectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvanceDirectiveInclude<ExtArgs> | null
    /**
     * Filter, which AdvanceDirective to fetch.
     */
    where?: AdvanceDirectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvanceDirectives to fetch.
     */
    orderBy?: AdvanceDirectiveOrderByWithRelationInput | AdvanceDirectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdvanceDirectives.
     */
    cursor?: AdvanceDirectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvanceDirectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvanceDirectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdvanceDirectives.
     */
    distinct?: AdvanceDirectiveScalarFieldEnum | AdvanceDirectiveScalarFieldEnum[]
  }

  /**
   * AdvanceDirective findFirstOrThrow
   */
  export type AdvanceDirectiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvanceDirective
     */
    select?: AdvanceDirectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvanceDirectiveInclude<ExtArgs> | null
    /**
     * Filter, which AdvanceDirective to fetch.
     */
    where?: AdvanceDirectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvanceDirectives to fetch.
     */
    orderBy?: AdvanceDirectiveOrderByWithRelationInput | AdvanceDirectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdvanceDirectives.
     */
    cursor?: AdvanceDirectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvanceDirectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvanceDirectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdvanceDirectives.
     */
    distinct?: AdvanceDirectiveScalarFieldEnum | AdvanceDirectiveScalarFieldEnum[]
  }

  /**
   * AdvanceDirective findMany
   */
  export type AdvanceDirectiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvanceDirective
     */
    select?: AdvanceDirectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvanceDirectiveInclude<ExtArgs> | null
    /**
     * Filter, which AdvanceDirectives to fetch.
     */
    where?: AdvanceDirectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvanceDirectives to fetch.
     */
    orderBy?: AdvanceDirectiveOrderByWithRelationInput | AdvanceDirectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdvanceDirectives.
     */
    cursor?: AdvanceDirectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvanceDirectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvanceDirectives.
     */
    skip?: number
    distinct?: AdvanceDirectiveScalarFieldEnum | AdvanceDirectiveScalarFieldEnum[]
  }

  /**
   * AdvanceDirective create
   */
  export type AdvanceDirectiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvanceDirective
     */
    select?: AdvanceDirectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvanceDirectiveInclude<ExtArgs> | null
    /**
     * The data needed to create a AdvanceDirective.
     */
    data: XOR<AdvanceDirectiveCreateInput, AdvanceDirectiveUncheckedCreateInput>
  }

  /**
   * AdvanceDirective createMany
   */
  export type AdvanceDirectiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdvanceDirectives.
     */
    data: AdvanceDirectiveCreateManyInput | AdvanceDirectiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdvanceDirective createManyAndReturn
   */
  export type AdvanceDirectiveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvanceDirective
     */
    select?: AdvanceDirectiveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdvanceDirectives.
     */
    data: AdvanceDirectiveCreateManyInput | AdvanceDirectiveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvanceDirectiveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdvanceDirective update
   */
  export type AdvanceDirectiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvanceDirective
     */
    select?: AdvanceDirectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvanceDirectiveInclude<ExtArgs> | null
    /**
     * The data needed to update a AdvanceDirective.
     */
    data: XOR<AdvanceDirectiveUpdateInput, AdvanceDirectiveUncheckedUpdateInput>
    /**
     * Choose, which AdvanceDirective to update.
     */
    where: AdvanceDirectiveWhereUniqueInput
  }

  /**
   * AdvanceDirective updateMany
   */
  export type AdvanceDirectiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdvanceDirectives.
     */
    data: XOR<AdvanceDirectiveUpdateManyMutationInput, AdvanceDirectiveUncheckedUpdateManyInput>
    /**
     * Filter which AdvanceDirectives to update
     */
    where?: AdvanceDirectiveWhereInput
  }

  /**
   * AdvanceDirective upsert
   */
  export type AdvanceDirectiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvanceDirective
     */
    select?: AdvanceDirectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvanceDirectiveInclude<ExtArgs> | null
    /**
     * The filter to search for the AdvanceDirective to update in case it exists.
     */
    where: AdvanceDirectiveWhereUniqueInput
    /**
     * In case the AdvanceDirective found by the `where` argument doesn't exist, create a new AdvanceDirective with this data.
     */
    create: XOR<AdvanceDirectiveCreateInput, AdvanceDirectiveUncheckedCreateInput>
    /**
     * In case the AdvanceDirective was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdvanceDirectiveUpdateInput, AdvanceDirectiveUncheckedUpdateInput>
  }

  /**
   * AdvanceDirective delete
   */
  export type AdvanceDirectiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvanceDirective
     */
    select?: AdvanceDirectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvanceDirectiveInclude<ExtArgs> | null
    /**
     * Filter which AdvanceDirective to delete.
     */
    where: AdvanceDirectiveWhereUniqueInput
  }

  /**
   * AdvanceDirective deleteMany
   */
  export type AdvanceDirectiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdvanceDirectives to delete
     */
    where?: AdvanceDirectiveWhereInput
  }

  /**
   * AdvanceDirective.witnesses
   */
  export type AdvanceDirective$witnessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Witness
     */
    select?: WitnessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessInclude<ExtArgs> | null
    where?: WitnessWhereInput
    orderBy?: WitnessOrderByWithRelationInput | WitnessOrderByWithRelationInput[]
    cursor?: WitnessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WitnessScalarFieldEnum | WitnessScalarFieldEnum[]
  }

  /**
   * AdvanceDirective without action
   */
  export type AdvanceDirectiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvanceDirective
     */
    select?: AdvanceDirectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvanceDirectiveInclude<ExtArgs> | null
  }


  /**
   * Model Witness
   */

  export type AggregateWitness = {
    _count: WitnessCountAggregateOutputType | null
    _min: WitnessMinAggregateOutputType | null
    _max: WitnessMaxAggregateOutputType | null
  }

  export type WitnessMinAggregateOutputType = {
    id: string | null
    directiveId: string | null
    name: string | null
    curp: string | null
    email: string | null
    phone: string | null
    ineImageUrl: string | null
    selfieImageUrl: string | null
    identityVerified: boolean | null
    verifiedAt: Date | null
    signatureImageUrl: string | null
    signedAt: Date | null
    sessionId: string | null
    sessionRecordingUrl: string | null
    sessionStartedAt: Date | null
    sessionEndedAt: Date | null
    createdAt: Date | null
  }

  export type WitnessMaxAggregateOutputType = {
    id: string | null
    directiveId: string | null
    name: string | null
    curp: string | null
    email: string | null
    phone: string | null
    ineImageUrl: string | null
    selfieImageUrl: string | null
    identityVerified: boolean | null
    verifiedAt: Date | null
    signatureImageUrl: string | null
    signedAt: Date | null
    sessionId: string | null
    sessionRecordingUrl: string | null
    sessionStartedAt: Date | null
    sessionEndedAt: Date | null
    createdAt: Date | null
  }

  export type WitnessCountAggregateOutputType = {
    id: number
    directiveId: number
    name: number
    curp: number
    email: number
    phone: number
    ineImageUrl: number
    selfieImageUrl: number
    identityVerified: number
    verifiedAt: number
    signatureImageUrl: number
    signedAt: number
    sessionId: number
    sessionRecordingUrl: number
    sessionStartedAt: number
    sessionEndedAt: number
    createdAt: number
    _all: number
  }


  export type WitnessMinAggregateInputType = {
    id?: true
    directiveId?: true
    name?: true
    curp?: true
    email?: true
    phone?: true
    ineImageUrl?: true
    selfieImageUrl?: true
    identityVerified?: true
    verifiedAt?: true
    signatureImageUrl?: true
    signedAt?: true
    sessionId?: true
    sessionRecordingUrl?: true
    sessionStartedAt?: true
    sessionEndedAt?: true
    createdAt?: true
  }

  export type WitnessMaxAggregateInputType = {
    id?: true
    directiveId?: true
    name?: true
    curp?: true
    email?: true
    phone?: true
    ineImageUrl?: true
    selfieImageUrl?: true
    identityVerified?: true
    verifiedAt?: true
    signatureImageUrl?: true
    signedAt?: true
    sessionId?: true
    sessionRecordingUrl?: true
    sessionStartedAt?: true
    sessionEndedAt?: true
    createdAt?: true
  }

  export type WitnessCountAggregateInputType = {
    id?: true
    directiveId?: true
    name?: true
    curp?: true
    email?: true
    phone?: true
    ineImageUrl?: true
    selfieImageUrl?: true
    identityVerified?: true
    verifiedAt?: true
    signatureImageUrl?: true
    signedAt?: true
    sessionId?: true
    sessionRecordingUrl?: true
    sessionStartedAt?: true
    sessionEndedAt?: true
    createdAt?: true
    _all?: true
  }

  export type WitnessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Witness to aggregate.
     */
    where?: WitnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Witnesses to fetch.
     */
    orderBy?: WitnessOrderByWithRelationInput | WitnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WitnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Witnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Witnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Witnesses
    **/
    _count?: true | WitnessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WitnessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WitnessMaxAggregateInputType
  }

  export type GetWitnessAggregateType<T extends WitnessAggregateArgs> = {
        [P in keyof T & keyof AggregateWitness]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWitness[P]>
      : GetScalarType<T[P], AggregateWitness[P]>
  }




  export type WitnessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WitnessWhereInput
    orderBy?: WitnessOrderByWithAggregationInput | WitnessOrderByWithAggregationInput[]
    by: WitnessScalarFieldEnum[] | WitnessScalarFieldEnum
    having?: WitnessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WitnessCountAggregateInputType | true
    _min?: WitnessMinAggregateInputType
    _max?: WitnessMaxAggregateInputType
  }

  export type WitnessGroupByOutputType = {
    id: string
    directiveId: string
    name: string
    curp: string | null
    email: string | null
    phone: string | null
    ineImageUrl: string | null
    selfieImageUrl: string | null
    identityVerified: boolean
    verifiedAt: Date | null
    signatureImageUrl: string | null
    signedAt: Date | null
    sessionId: string | null
    sessionRecordingUrl: string | null
    sessionStartedAt: Date | null
    sessionEndedAt: Date | null
    createdAt: Date
    _count: WitnessCountAggregateOutputType | null
    _min: WitnessMinAggregateOutputType | null
    _max: WitnessMaxAggregateOutputType | null
  }

  type GetWitnessGroupByPayload<T extends WitnessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WitnessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WitnessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WitnessGroupByOutputType[P]>
            : GetScalarType<T[P], WitnessGroupByOutputType[P]>
        }
      >
    >


  export type WitnessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    directiveId?: boolean
    name?: boolean
    curp?: boolean
    email?: boolean
    phone?: boolean
    ineImageUrl?: boolean
    selfieImageUrl?: boolean
    identityVerified?: boolean
    verifiedAt?: boolean
    signatureImageUrl?: boolean
    signedAt?: boolean
    sessionId?: boolean
    sessionRecordingUrl?: boolean
    sessionStartedAt?: boolean
    sessionEndedAt?: boolean
    createdAt?: boolean
    directive?: boolean | AdvanceDirectiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["witness"]>

  export type WitnessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    directiveId?: boolean
    name?: boolean
    curp?: boolean
    email?: boolean
    phone?: boolean
    ineImageUrl?: boolean
    selfieImageUrl?: boolean
    identityVerified?: boolean
    verifiedAt?: boolean
    signatureImageUrl?: boolean
    signedAt?: boolean
    sessionId?: boolean
    sessionRecordingUrl?: boolean
    sessionStartedAt?: boolean
    sessionEndedAt?: boolean
    createdAt?: boolean
    directive?: boolean | AdvanceDirectiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["witness"]>

  export type WitnessSelectScalar = {
    id?: boolean
    directiveId?: boolean
    name?: boolean
    curp?: boolean
    email?: boolean
    phone?: boolean
    ineImageUrl?: boolean
    selfieImageUrl?: boolean
    identityVerified?: boolean
    verifiedAt?: boolean
    signatureImageUrl?: boolean
    signedAt?: boolean
    sessionId?: boolean
    sessionRecordingUrl?: boolean
    sessionStartedAt?: boolean
    sessionEndedAt?: boolean
    createdAt?: boolean
  }

  export type WitnessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    directive?: boolean | AdvanceDirectiveDefaultArgs<ExtArgs>
  }
  export type WitnessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    directive?: boolean | AdvanceDirectiveDefaultArgs<ExtArgs>
  }

  export type $WitnessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Witness"
    objects: {
      directive: Prisma.$AdvanceDirectivePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      directiveId: string
      name: string
      curp: string | null
      email: string | null
      phone: string | null
      ineImageUrl: string | null
      selfieImageUrl: string | null
      identityVerified: boolean
      verifiedAt: Date | null
      signatureImageUrl: string | null
      signedAt: Date | null
      sessionId: string | null
      sessionRecordingUrl: string | null
      sessionStartedAt: Date | null
      sessionEndedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["witness"]>
    composites: {}
  }

  type WitnessGetPayload<S extends boolean | null | undefined | WitnessDefaultArgs> = $Result.GetResult<Prisma.$WitnessPayload, S>

  type WitnessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WitnessFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WitnessCountAggregateInputType | true
    }

  export interface WitnessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Witness'], meta: { name: 'Witness' } }
    /**
     * Find zero or one Witness that matches the filter.
     * @param {WitnessFindUniqueArgs} args - Arguments to find a Witness
     * @example
     * // Get one Witness
     * const witness = await prisma.witness.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WitnessFindUniqueArgs>(args: SelectSubset<T, WitnessFindUniqueArgs<ExtArgs>>): Prisma__WitnessClient<$Result.GetResult<Prisma.$WitnessPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Witness that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WitnessFindUniqueOrThrowArgs} args - Arguments to find a Witness
     * @example
     * // Get one Witness
     * const witness = await prisma.witness.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WitnessFindUniqueOrThrowArgs>(args: SelectSubset<T, WitnessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WitnessClient<$Result.GetResult<Prisma.$WitnessPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Witness that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessFindFirstArgs} args - Arguments to find a Witness
     * @example
     * // Get one Witness
     * const witness = await prisma.witness.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WitnessFindFirstArgs>(args?: SelectSubset<T, WitnessFindFirstArgs<ExtArgs>>): Prisma__WitnessClient<$Result.GetResult<Prisma.$WitnessPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Witness that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessFindFirstOrThrowArgs} args - Arguments to find a Witness
     * @example
     * // Get one Witness
     * const witness = await prisma.witness.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WitnessFindFirstOrThrowArgs>(args?: SelectSubset<T, WitnessFindFirstOrThrowArgs<ExtArgs>>): Prisma__WitnessClient<$Result.GetResult<Prisma.$WitnessPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Witnesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Witnesses
     * const witnesses = await prisma.witness.findMany()
     * 
     * // Get first 10 Witnesses
     * const witnesses = await prisma.witness.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const witnessWithIdOnly = await prisma.witness.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WitnessFindManyArgs>(args?: SelectSubset<T, WitnessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WitnessPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Witness.
     * @param {WitnessCreateArgs} args - Arguments to create a Witness.
     * @example
     * // Create one Witness
     * const Witness = await prisma.witness.create({
     *   data: {
     *     // ... data to create a Witness
     *   }
     * })
     * 
     */
    create<T extends WitnessCreateArgs>(args: SelectSubset<T, WitnessCreateArgs<ExtArgs>>): Prisma__WitnessClient<$Result.GetResult<Prisma.$WitnessPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Witnesses.
     * @param {WitnessCreateManyArgs} args - Arguments to create many Witnesses.
     * @example
     * // Create many Witnesses
     * const witness = await prisma.witness.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WitnessCreateManyArgs>(args?: SelectSubset<T, WitnessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Witnesses and returns the data saved in the database.
     * @param {WitnessCreateManyAndReturnArgs} args - Arguments to create many Witnesses.
     * @example
     * // Create many Witnesses
     * const witness = await prisma.witness.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Witnesses and only return the `id`
     * const witnessWithIdOnly = await prisma.witness.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WitnessCreateManyAndReturnArgs>(args?: SelectSubset<T, WitnessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WitnessPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Witness.
     * @param {WitnessDeleteArgs} args - Arguments to delete one Witness.
     * @example
     * // Delete one Witness
     * const Witness = await prisma.witness.delete({
     *   where: {
     *     // ... filter to delete one Witness
     *   }
     * })
     * 
     */
    delete<T extends WitnessDeleteArgs>(args: SelectSubset<T, WitnessDeleteArgs<ExtArgs>>): Prisma__WitnessClient<$Result.GetResult<Prisma.$WitnessPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Witness.
     * @param {WitnessUpdateArgs} args - Arguments to update one Witness.
     * @example
     * // Update one Witness
     * const witness = await prisma.witness.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WitnessUpdateArgs>(args: SelectSubset<T, WitnessUpdateArgs<ExtArgs>>): Prisma__WitnessClient<$Result.GetResult<Prisma.$WitnessPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Witnesses.
     * @param {WitnessDeleteManyArgs} args - Arguments to filter Witnesses to delete.
     * @example
     * // Delete a few Witnesses
     * const { count } = await prisma.witness.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WitnessDeleteManyArgs>(args?: SelectSubset<T, WitnessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Witnesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Witnesses
     * const witness = await prisma.witness.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WitnessUpdateManyArgs>(args: SelectSubset<T, WitnessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Witness.
     * @param {WitnessUpsertArgs} args - Arguments to update or create a Witness.
     * @example
     * // Update or create a Witness
     * const witness = await prisma.witness.upsert({
     *   create: {
     *     // ... data to create a Witness
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Witness we want to update
     *   }
     * })
     */
    upsert<T extends WitnessUpsertArgs>(args: SelectSubset<T, WitnessUpsertArgs<ExtArgs>>): Prisma__WitnessClient<$Result.GetResult<Prisma.$WitnessPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Witnesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessCountArgs} args - Arguments to filter Witnesses to count.
     * @example
     * // Count the number of Witnesses
     * const count = await prisma.witness.count({
     *   where: {
     *     // ... the filter for the Witnesses we want to count
     *   }
     * })
    **/
    count<T extends WitnessCountArgs>(
      args?: Subset<T, WitnessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WitnessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Witness.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WitnessAggregateArgs>(args: Subset<T, WitnessAggregateArgs>): Prisma.PrismaPromise<GetWitnessAggregateType<T>>

    /**
     * Group by Witness.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WitnessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WitnessGroupByArgs['orderBy'] }
        : { orderBy?: WitnessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WitnessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWitnessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Witness model
   */
  readonly fields: WitnessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Witness.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WitnessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    directive<T extends AdvanceDirectiveDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdvanceDirectiveDefaultArgs<ExtArgs>>): Prisma__AdvanceDirectiveClient<$Result.GetResult<Prisma.$AdvanceDirectivePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Witness model
   */ 
  interface WitnessFieldRefs {
    readonly id: FieldRef<"Witness", 'String'>
    readonly directiveId: FieldRef<"Witness", 'String'>
    readonly name: FieldRef<"Witness", 'String'>
    readonly curp: FieldRef<"Witness", 'String'>
    readonly email: FieldRef<"Witness", 'String'>
    readonly phone: FieldRef<"Witness", 'String'>
    readonly ineImageUrl: FieldRef<"Witness", 'String'>
    readonly selfieImageUrl: FieldRef<"Witness", 'String'>
    readonly identityVerified: FieldRef<"Witness", 'Boolean'>
    readonly verifiedAt: FieldRef<"Witness", 'DateTime'>
    readonly signatureImageUrl: FieldRef<"Witness", 'String'>
    readonly signedAt: FieldRef<"Witness", 'DateTime'>
    readonly sessionId: FieldRef<"Witness", 'String'>
    readonly sessionRecordingUrl: FieldRef<"Witness", 'String'>
    readonly sessionStartedAt: FieldRef<"Witness", 'DateTime'>
    readonly sessionEndedAt: FieldRef<"Witness", 'DateTime'>
    readonly createdAt: FieldRef<"Witness", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Witness findUnique
   */
  export type WitnessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Witness
     */
    select?: WitnessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessInclude<ExtArgs> | null
    /**
     * Filter, which Witness to fetch.
     */
    where: WitnessWhereUniqueInput
  }

  /**
   * Witness findUniqueOrThrow
   */
  export type WitnessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Witness
     */
    select?: WitnessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessInclude<ExtArgs> | null
    /**
     * Filter, which Witness to fetch.
     */
    where: WitnessWhereUniqueInput
  }

  /**
   * Witness findFirst
   */
  export type WitnessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Witness
     */
    select?: WitnessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessInclude<ExtArgs> | null
    /**
     * Filter, which Witness to fetch.
     */
    where?: WitnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Witnesses to fetch.
     */
    orderBy?: WitnessOrderByWithRelationInput | WitnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Witnesses.
     */
    cursor?: WitnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Witnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Witnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Witnesses.
     */
    distinct?: WitnessScalarFieldEnum | WitnessScalarFieldEnum[]
  }

  /**
   * Witness findFirstOrThrow
   */
  export type WitnessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Witness
     */
    select?: WitnessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessInclude<ExtArgs> | null
    /**
     * Filter, which Witness to fetch.
     */
    where?: WitnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Witnesses to fetch.
     */
    orderBy?: WitnessOrderByWithRelationInput | WitnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Witnesses.
     */
    cursor?: WitnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Witnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Witnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Witnesses.
     */
    distinct?: WitnessScalarFieldEnum | WitnessScalarFieldEnum[]
  }

  /**
   * Witness findMany
   */
  export type WitnessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Witness
     */
    select?: WitnessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessInclude<ExtArgs> | null
    /**
     * Filter, which Witnesses to fetch.
     */
    where?: WitnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Witnesses to fetch.
     */
    orderBy?: WitnessOrderByWithRelationInput | WitnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Witnesses.
     */
    cursor?: WitnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Witnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Witnesses.
     */
    skip?: number
    distinct?: WitnessScalarFieldEnum | WitnessScalarFieldEnum[]
  }

  /**
   * Witness create
   */
  export type WitnessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Witness
     */
    select?: WitnessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessInclude<ExtArgs> | null
    /**
     * The data needed to create a Witness.
     */
    data: XOR<WitnessCreateInput, WitnessUncheckedCreateInput>
  }

  /**
   * Witness createMany
   */
  export type WitnessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Witnesses.
     */
    data: WitnessCreateManyInput | WitnessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Witness createManyAndReturn
   */
  export type WitnessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Witness
     */
    select?: WitnessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Witnesses.
     */
    data: WitnessCreateManyInput | WitnessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Witness update
   */
  export type WitnessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Witness
     */
    select?: WitnessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessInclude<ExtArgs> | null
    /**
     * The data needed to update a Witness.
     */
    data: XOR<WitnessUpdateInput, WitnessUncheckedUpdateInput>
    /**
     * Choose, which Witness to update.
     */
    where: WitnessWhereUniqueInput
  }

  /**
   * Witness updateMany
   */
  export type WitnessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Witnesses.
     */
    data: XOR<WitnessUpdateManyMutationInput, WitnessUncheckedUpdateManyInput>
    /**
     * Filter which Witnesses to update
     */
    where?: WitnessWhereInput
  }

  /**
   * Witness upsert
   */
  export type WitnessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Witness
     */
    select?: WitnessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessInclude<ExtArgs> | null
    /**
     * The filter to search for the Witness to update in case it exists.
     */
    where: WitnessWhereUniqueInput
    /**
     * In case the Witness found by the `where` argument doesn't exist, create a new Witness with this data.
     */
    create: XOR<WitnessCreateInput, WitnessUncheckedCreateInput>
    /**
     * In case the Witness was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WitnessUpdateInput, WitnessUncheckedUpdateInput>
  }

  /**
   * Witness delete
   */
  export type WitnessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Witness
     */
    select?: WitnessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessInclude<ExtArgs> | null
    /**
     * Filter which Witness to delete.
     */
    where: WitnessWhereUniqueInput
  }

  /**
   * Witness deleteMany
   */
  export type WitnessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Witnesses to delete
     */
    where?: WitnessWhereInput
  }

  /**
   * Witness without action
   */
  export type WitnessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Witness
     */
    select?: WitnessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessInclude<ExtArgs> | null
  }


  /**
   * Model EmergencyAccess
   */

  export type AggregateEmergencyAccess = {
    _count: EmergencyAccessCountAggregateOutputType | null
    _avg: EmergencyAccessAvgAggregateOutputType | null
    _sum: EmergencyAccessSumAggregateOutputType | null
    _min: EmergencyAccessMinAggregateOutputType | null
    _max: EmergencyAccessMaxAggregateOutputType | null
  }

  export type EmergencyAccessAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type EmergencyAccessSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type EmergencyAccessMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    accessorId: string | null
    accessorName: string | null
    accessorRole: string | null
    accessorLicense: string | null
    institutionId: string | null
    institutionName: string | null
    insuranceId: string | null
    insurancePolicyNo: string | null
    qrTokenUsed: string | null
    ipAddress: string | null
    userAgent: string | null
    latitude: number | null
    longitude: number | null
    locationName: string | null
    notificationsSentAt: Date | null
    accessToken: string | null
    accessedAt: Date | null
    expiresAt: Date | null
  }

  export type EmergencyAccessMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    accessorId: string | null
    accessorName: string | null
    accessorRole: string | null
    accessorLicense: string | null
    institutionId: string | null
    institutionName: string | null
    insuranceId: string | null
    insurancePolicyNo: string | null
    qrTokenUsed: string | null
    ipAddress: string | null
    userAgent: string | null
    latitude: number | null
    longitude: number | null
    locationName: string | null
    notificationsSentAt: Date | null
    accessToken: string | null
    accessedAt: Date | null
    expiresAt: Date | null
  }

  export type EmergencyAccessCountAggregateOutputType = {
    id: number
    patientId: number
    accessorId: number
    accessorName: number
    accessorRole: number
    accessorLicense: number
    institutionId: number
    institutionName: number
    insuranceId: number
    insurancePolicyNo: number
    qrTokenUsed: number
    ipAddress: number
    userAgent: number
    latitude: number
    longitude: number
    locationName: number
    dataAccessed: number
    representativesNotified: number
    notificationsSentAt: number
    accessToken: number
    accessedAt: number
    expiresAt: number
    _all: number
  }


  export type EmergencyAccessAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type EmergencyAccessSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type EmergencyAccessMinAggregateInputType = {
    id?: true
    patientId?: true
    accessorId?: true
    accessorName?: true
    accessorRole?: true
    accessorLicense?: true
    institutionId?: true
    institutionName?: true
    insuranceId?: true
    insurancePolicyNo?: true
    qrTokenUsed?: true
    ipAddress?: true
    userAgent?: true
    latitude?: true
    longitude?: true
    locationName?: true
    notificationsSentAt?: true
    accessToken?: true
    accessedAt?: true
    expiresAt?: true
  }

  export type EmergencyAccessMaxAggregateInputType = {
    id?: true
    patientId?: true
    accessorId?: true
    accessorName?: true
    accessorRole?: true
    accessorLicense?: true
    institutionId?: true
    institutionName?: true
    insuranceId?: true
    insurancePolicyNo?: true
    qrTokenUsed?: true
    ipAddress?: true
    userAgent?: true
    latitude?: true
    longitude?: true
    locationName?: true
    notificationsSentAt?: true
    accessToken?: true
    accessedAt?: true
    expiresAt?: true
  }

  export type EmergencyAccessCountAggregateInputType = {
    id?: true
    patientId?: true
    accessorId?: true
    accessorName?: true
    accessorRole?: true
    accessorLicense?: true
    institutionId?: true
    institutionName?: true
    insuranceId?: true
    insurancePolicyNo?: true
    qrTokenUsed?: true
    ipAddress?: true
    userAgent?: true
    latitude?: true
    longitude?: true
    locationName?: true
    dataAccessed?: true
    representativesNotified?: true
    notificationsSentAt?: true
    accessToken?: true
    accessedAt?: true
    expiresAt?: true
    _all?: true
  }

  export type EmergencyAccessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyAccess to aggregate.
     */
    where?: EmergencyAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyAccesses to fetch.
     */
    orderBy?: EmergencyAccessOrderByWithRelationInput | EmergencyAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmergencyAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmergencyAccesses
    **/
    _count?: true | EmergencyAccessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmergencyAccessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmergencyAccessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmergencyAccessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmergencyAccessMaxAggregateInputType
  }

  export type GetEmergencyAccessAggregateType<T extends EmergencyAccessAggregateArgs> = {
        [P in keyof T & keyof AggregateEmergencyAccess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmergencyAccess[P]>
      : GetScalarType<T[P], AggregateEmergencyAccess[P]>
  }




  export type EmergencyAccessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyAccessWhereInput
    orderBy?: EmergencyAccessOrderByWithAggregationInput | EmergencyAccessOrderByWithAggregationInput[]
    by: EmergencyAccessScalarFieldEnum[] | EmergencyAccessScalarFieldEnum
    having?: EmergencyAccessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmergencyAccessCountAggregateInputType | true
    _avg?: EmergencyAccessAvgAggregateInputType
    _sum?: EmergencyAccessSumAggregateInputType
    _min?: EmergencyAccessMinAggregateInputType
    _max?: EmergencyAccessMaxAggregateInputType
  }

  export type EmergencyAccessGroupByOutputType = {
    id: string
    patientId: string
    accessorId: string | null
    accessorName: string
    accessorRole: string
    accessorLicense: string | null
    institutionId: string | null
    institutionName: string | null
    insuranceId: string | null
    insurancePolicyNo: string | null
    qrTokenUsed: string
    ipAddress: string | null
    userAgent: string | null
    latitude: number | null
    longitude: number | null
    locationName: string | null
    dataAccessed: string[]
    representativesNotified: string[]
    notificationsSentAt: Date | null
    accessToken: string
    accessedAt: Date
    expiresAt: Date
    _count: EmergencyAccessCountAggregateOutputType | null
    _avg: EmergencyAccessAvgAggregateOutputType | null
    _sum: EmergencyAccessSumAggregateOutputType | null
    _min: EmergencyAccessMinAggregateOutputType | null
    _max: EmergencyAccessMaxAggregateOutputType | null
  }

  type GetEmergencyAccessGroupByPayload<T extends EmergencyAccessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmergencyAccessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmergencyAccessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmergencyAccessGroupByOutputType[P]>
            : GetScalarType<T[P], EmergencyAccessGroupByOutputType[P]>
        }
      >
    >


  export type EmergencyAccessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    accessorId?: boolean
    accessorName?: boolean
    accessorRole?: boolean
    accessorLicense?: boolean
    institutionId?: boolean
    institutionName?: boolean
    insuranceId?: boolean
    insurancePolicyNo?: boolean
    qrTokenUsed?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    latitude?: boolean
    longitude?: boolean
    locationName?: boolean
    dataAccessed?: boolean
    representativesNotified?: boolean
    notificationsSentAt?: boolean
    accessToken?: boolean
    accessedAt?: boolean
    expiresAt?: boolean
    patient?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | EmergencyAccess$institutionArgs<ExtArgs>
    insurance?: boolean | EmergencyAccess$insuranceArgs<ExtArgs>
  }, ExtArgs["result"]["emergencyAccess"]>

  export type EmergencyAccessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    accessorId?: boolean
    accessorName?: boolean
    accessorRole?: boolean
    accessorLicense?: boolean
    institutionId?: boolean
    institutionName?: boolean
    insuranceId?: boolean
    insurancePolicyNo?: boolean
    qrTokenUsed?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    latitude?: boolean
    longitude?: boolean
    locationName?: boolean
    dataAccessed?: boolean
    representativesNotified?: boolean
    notificationsSentAt?: boolean
    accessToken?: boolean
    accessedAt?: boolean
    expiresAt?: boolean
    patient?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | EmergencyAccess$institutionArgs<ExtArgs>
    insurance?: boolean | EmergencyAccess$insuranceArgs<ExtArgs>
  }, ExtArgs["result"]["emergencyAccess"]>

  export type EmergencyAccessSelectScalar = {
    id?: boolean
    patientId?: boolean
    accessorId?: boolean
    accessorName?: boolean
    accessorRole?: boolean
    accessorLicense?: boolean
    institutionId?: boolean
    institutionName?: boolean
    insuranceId?: boolean
    insurancePolicyNo?: boolean
    qrTokenUsed?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    latitude?: boolean
    longitude?: boolean
    locationName?: boolean
    dataAccessed?: boolean
    representativesNotified?: boolean
    notificationsSentAt?: boolean
    accessToken?: boolean
    accessedAt?: boolean
    expiresAt?: boolean
  }

  export type EmergencyAccessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | EmergencyAccess$institutionArgs<ExtArgs>
    insurance?: boolean | EmergencyAccess$insuranceArgs<ExtArgs>
  }
  export type EmergencyAccessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | EmergencyAccess$institutionArgs<ExtArgs>
    insurance?: boolean | EmergencyAccess$insuranceArgs<ExtArgs>
  }

  export type $EmergencyAccessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmergencyAccess"
    objects: {
      patient: Prisma.$UserPayload<ExtArgs>
      institution: Prisma.$MedicalInstitutionPayload<ExtArgs> | null
      insurance: Prisma.$InsuranceCompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      accessorId: string | null
      accessorName: string
      accessorRole: string
      accessorLicense: string | null
      institutionId: string | null
      institutionName: string | null
      insuranceId: string | null
      insurancePolicyNo: string | null
      qrTokenUsed: string
      ipAddress: string | null
      userAgent: string | null
      latitude: number | null
      longitude: number | null
      locationName: string | null
      dataAccessed: string[]
      representativesNotified: string[]
      notificationsSentAt: Date | null
      accessToken: string
      accessedAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["emergencyAccess"]>
    composites: {}
  }

  type EmergencyAccessGetPayload<S extends boolean | null | undefined | EmergencyAccessDefaultArgs> = $Result.GetResult<Prisma.$EmergencyAccessPayload, S>

  type EmergencyAccessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmergencyAccessFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmergencyAccessCountAggregateInputType | true
    }

  export interface EmergencyAccessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmergencyAccess'], meta: { name: 'EmergencyAccess' } }
    /**
     * Find zero or one EmergencyAccess that matches the filter.
     * @param {EmergencyAccessFindUniqueArgs} args - Arguments to find a EmergencyAccess
     * @example
     * // Get one EmergencyAccess
     * const emergencyAccess = await prisma.emergencyAccess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmergencyAccessFindUniqueArgs>(args: SelectSubset<T, EmergencyAccessFindUniqueArgs<ExtArgs>>): Prisma__EmergencyAccessClient<$Result.GetResult<Prisma.$EmergencyAccessPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmergencyAccess that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmergencyAccessFindUniqueOrThrowArgs} args - Arguments to find a EmergencyAccess
     * @example
     * // Get one EmergencyAccess
     * const emergencyAccess = await prisma.emergencyAccess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmergencyAccessFindUniqueOrThrowArgs>(args: SelectSubset<T, EmergencyAccessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmergencyAccessClient<$Result.GetResult<Prisma.$EmergencyAccessPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmergencyAccess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyAccessFindFirstArgs} args - Arguments to find a EmergencyAccess
     * @example
     * // Get one EmergencyAccess
     * const emergencyAccess = await prisma.emergencyAccess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmergencyAccessFindFirstArgs>(args?: SelectSubset<T, EmergencyAccessFindFirstArgs<ExtArgs>>): Prisma__EmergencyAccessClient<$Result.GetResult<Prisma.$EmergencyAccessPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmergencyAccess that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyAccessFindFirstOrThrowArgs} args - Arguments to find a EmergencyAccess
     * @example
     * // Get one EmergencyAccess
     * const emergencyAccess = await prisma.emergencyAccess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmergencyAccessFindFirstOrThrowArgs>(args?: SelectSubset<T, EmergencyAccessFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmergencyAccessClient<$Result.GetResult<Prisma.$EmergencyAccessPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmergencyAccesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyAccessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmergencyAccesses
     * const emergencyAccesses = await prisma.emergencyAccess.findMany()
     * 
     * // Get first 10 EmergencyAccesses
     * const emergencyAccesses = await prisma.emergencyAccess.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emergencyAccessWithIdOnly = await prisma.emergencyAccess.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmergencyAccessFindManyArgs>(args?: SelectSubset<T, EmergencyAccessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyAccessPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmergencyAccess.
     * @param {EmergencyAccessCreateArgs} args - Arguments to create a EmergencyAccess.
     * @example
     * // Create one EmergencyAccess
     * const EmergencyAccess = await prisma.emergencyAccess.create({
     *   data: {
     *     // ... data to create a EmergencyAccess
     *   }
     * })
     * 
     */
    create<T extends EmergencyAccessCreateArgs>(args: SelectSubset<T, EmergencyAccessCreateArgs<ExtArgs>>): Prisma__EmergencyAccessClient<$Result.GetResult<Prisma.$EmergencyAccessPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmergencyAccesses.
     * @param {EmergencyAccessCreateManyArgs} args - Arguments to create many EmergencyAccesses.
     * @example
     * // Create many EmergencyAccesses
     * const emergencyAccess = await prisma.emergencyAccess.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmergencyAccessCreateManyArgs>(args?: SelectSubset<T, EmergencyAccessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmergencyAccesses and returns the data saved in the database.
     * @param {EmergencyAccessCreateManyAndReturnArgs} args - Arguments to create many EmergencyAccesses.
     * @example
     * // Create many EmergencyAccesses
     * const emergencyAccess = await prisma.emergencyAccess.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmergencyAccesses and only return the `id`
     * const emergencyAccessWithIdOnly = await prisma.emergencyAccess.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmergencyAccessCreateManyAndReturnArgs>(args?: SelectSubset<T, EmergencyAccessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyAccessPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmergencyAccess.
     * @param {EmergencyAccessDeleteArgs} args - Arguments to delete one EmergencyAccess.
     * @example
     * // Delete one EmergencyAccess
     * const EmergencyAccess = await prisma.emergencyAccess.delete({
     *   where: {
     *     // ... filter to delete one EmergencyAccess
     *   }
     * })
     * 
     */
    delete<T extends EmergencyAccessDeleteArgs>(args: SelectSubset<T, EmergencyAccessDeleteArgs<ExtArgs>>): Prisma__EmergencyAccessClient<$Result.GetResult<Prisma.$EmergencyAccessPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmergencyAccess.
     * @param {EmergencyAccessUpdateArgs} args - Arguments to update one EmergencyAccess.
     * @example
     * // Update one EmergencyAccess
     * const emergencyAccess = await prisma.emergencyAccess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmergencyAccessUpdateArgs>(args: SelectSubset<T, EmergencyAccessUpdateArgs<ExtArgs>>): Prisma__EmergencyAccessClient<$Result.GetResult<Prisma.$EmergencyAccessPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmergencyAccesses.
     * @param {EmergencyAccessDeleteManyArgs} args - Arguments to filter EmergencyAccesses to delete.
     * @example
     * // Delete a few EmergencyAccesses
     * const { count } = await prisma.emergencyAccess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmergencyAccessDeleteManyArgs>(args?: SelectSubset<T, EmergencyAccessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmergencyAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyAccessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmergencyAccesses
     * const emergencyAccess = await prisma.emergencyAccess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmergencyAccessUpdateManyArgs>(args: SelectSubset<T, EmergencyAccessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmergencyAccess.
     * @param {EmergencyAccessUpsertArgs} args - Arguments to update or create a EmergencyAccess.
     * @example
     * // Update or create a EmergencyAccess
     * const emergencyAccess = await prisma.emergencyAccess.upsert({
     *   create: {
     *     // ... data to create a EmergencyAccess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmergencyAccess we want to update
     *   }
     * })
     */
    upsert<T extends EmergencyAccessUpsertArgs>(args: SelectSubset<T, EmergencyAccessUpsertArgs<ExtArgs>>): Prisma__EmergencyAccessClient<$Result.GetResult<Prisma.$EmergencyAccessPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmergencyAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyAccessCountArgs} args - Arguments to filter EmergencyAccesses to count.
     * @example
     * // Count the number of EmergencyAccesses
     * const count = await prisma.emergencyAccess.count({
     *   where: {
     *     // ... the filter for the EmergencyAccesses we want to count
     *   }
     * })
    **/
    count<T extends EmergencyAccessCountArgs>(
      args?: Subset<T, EmergencyAccessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmergencyAccessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmergencyAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyAccessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmergencyAccessAggregateArgs>(args: Subset<T, EmergencyAccessAggregateArgs>): Prisma.PrismaPromise<GetEmergencyAccessAggregateType<T>>

    /**
     * Group by EmergencyAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyAccessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmergencyAccessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmergencyAccessGroupByArgs['orderBy'] }
        : { orderBy?: EmergencyAccessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmergencyAccessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmergencyAccessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmergencyAccess model
   */
  readonly fields: EmergencyAccessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmergencyAccess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmergencyAccessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    institution<T extends EmergencyAccess$institutionArgs<ExtArgs> = {}>(args?: Subset<T, EmergencyAccess$institutionArgs<ExtArgs>>): Prisma__MedicalInstitutionClient<$Result.GetResult<Prisma.$MedicalInstitutionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    insurance<T extends EmergencyAccess$insuranceArgs<ExtArgs> = {}>(args?: Subset<T, EmergencyAccess$insuranceArgs<ExtArgs>>): Prisma__InsuranceCompanyClient<$Result.GetResult<Prisma.$InsuranceCompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmergencyAccess model
   */ 
  interface EmergencyAccessFieldRefs {
    readonly id: FieldRef<"EmergencyAccess", 'String'>
    readonly patientId: FieldRef<"EmergencyAccess", 'String'>
    readonly accessorId: FieldRef<"EmergencyAccess", 'String'>
    readonly accessorName: FieldRef<"EmergencyAccess", 'String'>
    readonly accessorRole: FieldRef<"EmergencyAccess", 'String'>
    readonly accessorLicense: FieldRef<"EmergencyAccess", 'String'>
    readonly institutionId: FieldRef<"EmergencyAccess", 'String'>
    readonly institutionName: FieldRef<"EmergencyAccess", 'String'>
    readonly insuranceId: FieldRef<"EmergencyAccess", 'String'>
    readonly insurancePolicyNo: FieldRef<"EmergencyAccess", 'String'>
    readonly qrTokenUsed: FieldRef<"EmergencyAccess", 'String'>
    readonly ipAddress: FieldRef<"EmergencyAccess", 'String'>
    readonly userAgent: FieldRef<"EmergencyAccess", 'String'>
    readonly latitude: FieldRef<"EmergencyAccess", 'Float'>
    readonly longitude: FieldRef<"EmergencyAccess", 'Float'>
    readonly locationName: FieldRef<"EmergencyAccess", 'String'>
    readonly dataAccessed: FieldRef<"EmergencyAccess", 'String[]'>
    readonly representativesNotified: FieldRef<"EmergencyAccess", 'String[]'>
    readonly notificationsSentAt: FieldRef<"EmergencyAccess", 'DateTime'>
    readonly accessToken: FieldRef<"EmergencyAccess", 'String'>
    readonly accessedAt: FieldRef<"EmergencyAccess", 'DateTime'>
    readonly expiresAt: FieldRef<"EmergencyAccess", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmergencyAccess findUnique
   */
  export type EmergencyAccessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAccess
     */
    select?: EmergencyAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAccessInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyAccess to fetch.
     */
    where: EmergencyAccessWhereUniqueInput
  }

  /**
   * EmergencyAccess findUniqueOrThrow
   */
  export type EmergencyAccessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAccess
     */
    select?: EmergencyAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAccessInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyAccess to fetch.
     */
    where: EmergencyAccessWhereUniqueInput
  }

  /**
   * EmergencyAccess findFirst
   */
  export type EmergencyAccessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAccess
     */
    select?: EmergencyAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAccessInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyAccess to fetch.
     */
    where?: EmergencyAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyAccesses to fetch.
     */
    orderBy?: EmergencyAccessOrderByWithRelationInput | EmergencyAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyAccesses.
     */
    cursor?: EmergencyAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyAccesses.
     */
    distinct?: EmergencyAccessScalarFieldEnum | EmergencyAccessScalarFieldEnum[]
  }

  /**
   * EmergencyAccess findFirstOrThrow
   */
  export type EmergencyAccessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAccess
     */
    select?: EmergencyAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAccessInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyAccess to fetch.
     */
    where?: EmergencyAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyAccesses to fetch.
     */
    orderBy?: EmergencyAccessOrderByWithRelationInput | EmergencyAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyAccesses.
     */
    cursor?: EmergencyAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyAccesses.
     */
    distinct?: EmergencyAccessScalarFieldEnum | EmergencyAccessScalarFieldEnum[]
  }

  /**
   * EmergencyAccess findMany
   */
  export type EmergencyAccessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAccess
     */
    select?: EmergencyAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAccessInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyAccesses to fetch.
     */
    where?: EmergencyAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyAccesses to fetch.
     */
    orderBy?: EmergencyAccessOrderByWithRelationInput | EmergencyAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmergencyAccesses.
     */
    cursor?: EmergencyAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyAccesses.
     */
    skip?: number
    distinct?: EmergencyAccessScalarFieldEnum | EmergencyAccessScalarFieldEnum[]
  }

  /**
   * EmergencyAccess create
   */
  export type EmergencyAccessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAccess
     */
    select?: EmergencyAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAccessInclude<ExtArgs> | null
    /**
     * The data needed to create a EmergencyAccess.
     */
    data: XOR<EmergencyAccessCreateInput, EmergencyAccessUncheckedCreateInput>
  }

  /**
   * EmergencyAccess createMany
   */
  export type EmergencyAccessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmergencyAccesses.
     */
    data: EmergencyAccessCreateManyInput | EmergencyAccessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmergencyAccess createManyAndReturn
   */
  export type EmergencyAccessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAccess
     */
    select?: EmergencyAccessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmergencyAccesses.
     */
    data: EmergencyAccessCreateManyInput | EmergencyAccessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAccessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmergencyAccess update
   */
  export type EmergencyAccessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAccess
     */
    select?: EmergencyAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAccessInclude<ExtArgs> | null
    /**
     * The data needed to update a EmergencyAccess.
     */
    data: XOR<EmergencyAccessUpdateInput, EmergencyAccessUncheckedUpdateInput>
    /**
     * Choose, which EmergencyAccess to update.
     */
    where: EmergencyAccessWhereUniqueInput
  }

  /**
   * EmergencyAccess updateMany
   */
  export type EmergencyAccessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmergencyAccesses.
     */
    data: XOR<EmergencyAccessUpdateManyMutationInput, EmergencyAccessUncheckedUpdateManyInput>
    /**
     * Filter which EmergencyAccesses to update
     */
    where?: EmergencyAccessWhereInput
  }

  /**
   * EmergencyAccess upsert
   */
  export type EmergencyAccessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAccess
     */
    select?: EmergencyAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAccessInclude<ExtArgs> | null
    /**
     * The filter to search for the EmergencyAccess to update in case it exists.
     */
    where: EmergencyAccessWhereUniqueInput
    /**
     * In case the EmergencyAccess found by the `where` argument doesn't exist, create a new EmergencyAccess with this data.
     */
    create: XOR<EmergencyAccessCreateInput, EmergencyAccessUncheckedCreateInput>
    /**
     * In case the EmergencyAccess was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmergencyAccessUpdateInput, EmergencyAccessUncheckedUpdateInput>
  }

  /**
   * EmergencyAccess delete
   */
  export type EmergencyAccessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAccess
     */
    select?: EmergencyAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAccessInclude<ExtArgs> | null
    /**
     * Filter which EmergencyAccess to delete.
     */
    where: EmergencyAccessWhereUniqueInput
  }

  /**
   * EmergencyAccess deleteMany
   */
  export type EmergencyAccessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyAccesses to delete
     */
    where?: EmergencyAccessWhereInput
  }

  /**
   * EmergencyAccess.institution
   */
  export type EmergencyAccess$institutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInstitution
     */
    select?: MedicalInstitutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInstitutionInclude<ExtArgs> | null
    where?: MedicalInstitutionWhereInput
  }

  /**
   * EmergencyAccess.insurance
   */
  export type EmergencyAccess$insuranceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceCompany
     */
    select?: InsuranceCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceCompanyInclude<ExtArgs> | null
    where?: InsuranceCompanyWhereInput
  }

  /**
   * EmergencyAccess without action
   */
  export type EmergencyAccessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAccess
     */
    select?: EmergencyAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAccessInclude<ExtArgs> | null
  }


  /**
   * Model MedicalInstitution
   */

  export type AggregateMedicalInstitution = {
    _count: MedicalInstitutionCountAggregateOutputType | null
    _avg: MedicalInstitutionAvgAggregateOutputType | null
    _sum: MedicalInstitutionSumAggregateOutputType | null
    _min: MedicalInstitutionMinAggregateOutputType | null
    _max: MedicalInstitutionMaxAggregateOutputType | null
  }

  export type MedicalInstitutionAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type MedicalInstitutionSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type MedicalInstitutionMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.InstitutionType | null
    cluesCode: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    latitude: number | null
    longitude: number | null
    phone: string | null
    emergencyPhone: string | null
    email: string | null
    attentionLevel: $Enums.AttentionLevel | null
    hasEmergency: boolean | null
    has24Hours: boolean | null
    hasICU: boolean | null
    hasTrauma: boolean | null
    oauthClientId: string | null
    oauthClientSecret: string | null
    isActive: boolean | null
    isVerified: boolean | null
    verifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicalInstitutionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.InstitutionType | null
    cluesCode: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    latitude: number | null
    longitude: number | null
    phone: string | null
    emergencyPhone: string | null
    email: string | null
    attentionLevel: $Enums.AttentionLevel | null
    hasEmergency: boolean | null
    has24Hours: boolean | null
    hasICU: boolean | null
    hasTrauma: boolean | null
    oauthClientId: string | null
    oauthClientSecret: string | null
    isActive: boolean | null
    isVerified: boolean | null
    verifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicalInstitutionCountAggregateOutputType = {
    id: number
    name: number
    type: number
    cluesCode: number
    address: number
    city: number
    state: number
    zipCode: number
    latitude: number
    longitude: number
    phone: number
    emergencyPhone: number
    email: number
    attentionLevel: number
    specialties: number
    hasEmergency: number
    has24Hours: number
    hasICU: number
    hasTrauma: number
    oauthClientId: number
    oauthClientSecret: number
    isActive: number
    isVerified: number
    verifiedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicalInstitutionAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type MedicalInstitutionSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type MedicalInstitutionMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    cluesCode?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    latitude?: true
    longitude?: true
    phone?: true
    emergencyPhone?: true
    email?: true
    attentionLevel?: true
    hasEmergency?: true
    has24Hours?: true
    hasICU?: true
    hasTrauma?: true
    oauthClientId?: true
    oauthClientSecret?: true
    isActive?: true
    isVerified?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicalInstitutionMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    cluesCode?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    latitude?: true
    longitude?: true
    phone?: true
    emergencyPhone?: true
    email?: true
    attentionLevel?: true
    hasEmergency?: true
    has24Hours?: true
    hasICU?: true
    hasTrauma?: true
    oauthClientId?: true
    oauthClientSecret?: true
    isActive?: true
    isVerified?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicalInstitutionCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    cluesCode?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    latitude?: true
    longitude?: true
    phone?: true
    emergencyPhone?: true
    email?: true
    attentionLevel?: true
    specialties?: true
    hasEmergency?: true
    has24Hours?: true
    hasICU?: true
    hasTrauma?: true
    oauthClientId?: true
    oauthClientSecret?: true
    isActive?: true
    isVerified?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicalInstitutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalInstitution to aggregate.
     */
    where?: MedicalInstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalInstitutions to fetch.
     */
    orderBy?: MedicalInstitutionOrderByWithRelationInput | MedicalInstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalInstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalInstitutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalInstitutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalInstitutions
    **/
    _count?: true | MedicalInstitutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicalInstitutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicalInstitutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalInstitutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalInstitutionMaxAggregateInputType
  }

  export type GetMedicalInstitutionAggregateType<T extends MedicalInstitutionAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalInstitution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalInstitution[P]>
      : GetScalarType<T[P], AggregateMedicalInstitution[P]>
  }




  export type MedicalInstitutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalInstitutionWhereInput
    orderBy?: MedicalInstitutionOrderByWithAggregationInput | MedicalInstitutionOrderByWithAggregationInput[]
    by: MedicalInstitutionScalarFieldEnum[] | MedicalInstitutionScalarFieldEnum
    having?: MedicalInstitutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalInstitutionCountAggregateInputType | true
    _avg?: MedicalInstitutionAvgAggregateInputType
    _sum?: MedicalInstitutionSumAggregateInputType
    _min?: MedicalInstitutionMinAggregateInputType
    _max?: MedicalInstitutionMaxAggregateInputType
  }

  export type MedicalInstitutionGroupByOutputType = {
    id: string
    name: string
    type: $Enums.InstitutionType
    cluesCode: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    latitude: number | null
    longitude: number | null
    phone: string | null
    emergencyPhone: string | null
    email: string | null
    attentionLevel: $Enums.AttentionLevel | null
    specialties: string[]
    hasEmergency: boolean
    has24Hours: boolean
    hasICU: boolean
    hasTrauma: boolean
    oauthClientId: string | null
    oauthClientSecret: string | null
    isActive: boolean
    isVerified: boolean
    verifiedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MedicalInstitutionCountAggregateOutputType | null
    _avg: MedicalInstitutionAvgAggregateOutputType | null
    _sum: MedicalInstitutionSumAggregateOutputType | null
    _min: MedicalInstitutionMinAggregateOutputType | null
    _max: MedicalInstitutionMaxAggregateOutputType | null
  }

  type GetMedicalInstitutionGroupByPayload<T extends MedicalInstitutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalInstitutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalInstitutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalInstitutionGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalInstitutionGroupByOutputType[P]>
        }
      >
    >


  export type MedicalInstitutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    cluesCode?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    latitude?: boolean
    longitude?: boolean
    phone?: boolean
    emergencyPhone?: boolean
    email?: boolean
    attentionLevel?: boolean
    specialties?: boolean
    hasEmergency?: boolean
    has24Hours?: boolean
    hasICU?: boolean
    hasTrauma?: boolean
    oauthClientId?: boolean
    oauthClientSecret?: boolean
    isActive?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emergencyAccesses?: boolean | MedicalInstitution$emergencyAccessesArgs<ExtArgs>
    staff?: boolean | MedicalInstitution$staffArgs<ExtArgs>
    insuranceNetworks?: boolean | MedicalInstitution$insuranceNetworksArgs<ExtArgs>
    _count?: boolean | MedicalInstitutionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalInstitution"]>

  export type MedicalInstitutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    cluesCode?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    latitude?: boolean
    longitude?: boolean
    phone?: boolean
    emergencyPhone?: boolean
    email?: boolean
    attentionLevel?: boolean
    specialties?: boolean
    hasEmergency?: boolean
    has24Hours?: boolean
    hasICU?: boolean
    hasTrauma?: boolean
    oauthClientId?: boolean
    oauthClientSecret?: boolean
    isActive?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["medicalInstitution"]>

  export type MedicalInstitutionSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    cluesCode?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    latitude?: boolean
    longitude?: boolean
    phone?: boolean
    emergencyPhone?: boolean
    email?: boolean
    attentionLevel?: boolean
    specialties?: boolean
    hasEmergency?: boolean
    has24Hours?: boolean
    hasICU?: boolean
    hasTrauma?: boolean
    oauthClientId?: boolean
    oauthClientSecret?: boolean
    isActive?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicalInstitutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emergencyAccesses?: boolean | MedicalInstitution$emergencyAccessesArgs<ExtArgs>
    staff?: boolean | MedicalInstitution$staffArgs<ExtArgs>
    insuranceNetworks?: boolean | MedicalInstitution$insuranceNetworksArgs<ExtArgs>
    _count?: boolean | MedicalInstitutionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MedicalInstitutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MedicalInstitutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicalInstitution"
    objects: {
      emergencyAccesses: Prisma.$EmergencyAccessPayload<ExtArgs>[]
      staff: Prisma.$MedicalStaffPayload<ExtArgs>[]
      insuranceNetworks: Prisma.$InsuranceCompanyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.InstitutionType
      cluesCode: string | null
      address: string | null
      city: string | null
      state: string | null
      zipCode: string | null
      latitude: number | null
      longitude: number | null
      phone: string | null
      emergencyPhone: string | null
      email: string | null
      attentionLevel: $Enums.AttentionLevel | null
      specialties: string[]
      hasEmergency: boolean
      has24Hours: boolean
      hasICU: boolean
      hasTrauma: boolean
      oauthClientId: string | null
      oauthClientSecret: string | null
      isActive: boolean
      isVerified: boolean
      verifiedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicalInstitution"]>
    composites: {}
  }

  type MedicalInstitutionGetPayload<S extends boolean | null | undefined | MedicalInstitutionDefaultArgs> = $Result.GetResult<Prisma.$MedicalInstitutionPayload, S>

  type MedicalInstitutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MedicalInstitutionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MedicalInstitutionCountAggregateInputType | true
    }

  export interface MedicalInstitutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalInstitution'], meta: { name: 'MedicalInstitution' } }
    /**
     * Find zero or one MedicalInstitution that matches the filter.
     * @param {MedicalInstitutionFindUniqueArgs} args - Arguments to find a MedicalInstitution
     * @example
     * // Get one MedicalInstitution
     * const medicalInstitution = await prisma.medicalInstitution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicalInstitutionFindUniqueArgs>(args: SelectSubset<T, MedicalInstitutionFindUniqueArgs<ExtArgs>>): Prisma__MedicalInstitutionClient<$Result.GetResult<Prisma.$MedicalInstitutionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MedicalInstitution that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MedicalInstitutionFindUniqueOrThrowArgs} args - Arguments to find a MedicalInstitution
     * @example
     * // Get one MedicalInstitution
     * const medicalInstitution = await prisma.medicalInstitution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicalInstitutionFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicalInstitutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicalInstitutionClient<$Result.GetResult<Prisma.$MedicalInstitutionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MedicalInstitution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalInstitutionFindFirstArgs} args - Arguments to find a MedicalInstitution
     * @example
     * // Get one MedicalInstitution
     * const medicalInstitution = await prisma.medicalInstitution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicalInstitutionFindFirstArgs>(args?: SelectSubset<T, MedicalInstitutionFindFirstArgs<ExtArgs>>): Prisma__MedicalInstitutionClient<$Result.GetResult<Prisma.$MedicalInstitutionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MedicalInstitution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalInstitutionFindFirstOrThrowArgs} args - Arguments to find a MedicalInstitution
     * @example
     * // Get one MedicalInstitution
     * const medicalInstitution = await prisma.medicalInstitution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicalInstitutionFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicalInstitutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicalInstitutionClient<$Result.GetResult<Prisma.$MedicalInstitutionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MedicalInstitutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalInstitutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalInstitutions
     * const medicalInstitutions = await prisma.medicalInstitution.findMany()
     * 
     * // Get first 10 MedicalInstitutions
     * const medicalInstitutions = await prisma.medicalInstitution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalInstitutionWithIdOnly = await prisma.medicalInstitution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicalInstitutionFindManyArgs>(args?: SelectSubset<T, MedicalInstitutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalInstitutionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MedicalInstitution.
     * @param {MedicalInstitutionCreateArgs} args - Arguments to create a MedicalInstitution.
     * @example
     * // Create one MedicalInstitution
     * const MedicalInstitution = await prisma.medicalInstitution.create({
     *   data: {
     *     // ... data to create a MedicalInstitution
     *   }
     * })
     * 
     */
    create<T extends MedicalInstitutionCreateArgs>(args: SelectSubset<T, MedicalInstitutionCreateArgs<ExtArgs>>): Prisma__MedicalInstitutionClient<$Result.GetResult<Prisma.$MedicalInstitutionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MedicalInstitutions.
     * @param {MedicalInstitutionCreateManyArgs} args - Arguments to create many MedicalInstitutions.
     * @example
     * // Create many MedicalInstitutions
     * const medicalInstitution = await prisma.medicalInstitution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicalInstitutionCreateManyArgs>(args?: SelectSubset<T, MedicalInstitutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicalInstitutions and returns the data saved in the database.
     * @param {MedicalInstitutionCreateManyAndReturnArgs} args - Arguments to create many MedicalInstitutions.
     * @example
     * // Create many MedicalInstitutions
     * const medicalInstitution = await prisma.medicalInstitution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicalInstitutions and only return the `id`
     * const medicalInstitutionWithIdOnly = await prisma.medicalInstitution.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicalInstitutionCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicalInstitutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalInstitutionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MedicalInstitution.
     * @param {MedicalInstitutionDeleteArgs} args - Arguments to delete one MedicalInstitution.
     * @example
     * // Delete one MedicalInstitution
     * const MedicalInstitution = await prisma.medicalInstitution.delete({
     *   where: {
     *     // ... filter to delete one MedicalInstitution
     *   }
     * })
     * 
     */
    delete<T extends MedicalInstitutionDeleteArgs>(args: SelectSubset<T, MedicalInstitutionDeleteArgs<ExtArgs>>): Prisma__MedicalInstitutionClient<$Result.GetResult<Prisma.$MedicalInstitutionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MedicalInstitution.
     * @param {MedicalInstitutionUpdateArgs} args - Arguments to update one MedicalInstitution.
     * @example
     * // Update one MedicalInstitution
     * const medicalInstitution = await prisma.medicalInstitution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicalInstitutionUpdateArgs>(args: SelectSubset<T, MedicalInstitutionUpdateArgs<ExtArgs>>): Prisma__MedicalInstitutionClient<$Result.GetResult<Prisma.$MedicalInstitutionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MedicalInstitutions.
     * @param {MedicalInstitutionDeleteManyArgs} args - Arguments to filter MedicalInstitutions to delete.
     * @example
     * // Delete a few MedicalInstitutions
     * const { count } = await prisma.medicalInstitution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicalInstitutionDeleteManyArgs>(args?: SelectSubset<T, MedicalInstitutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalInstitutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalInstitutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalInstitutions
     * const medicalInstitution = await prisma.medicalInstitution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicalInstitutionUpdateManyArgs>(args: SelectSubset<T, MedicalInstitutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MedicalInstitution.
     * @param {MedicalInstitutionUpsertArgs} args - Arguments to update or create a MedicalInstitution.
     * @example
     * // Update or create a MedicalInstitution
     * const medicalInstitution = await prisma.medicalInstitution.upsert({
     *   create: {
     *     // ... data to create a MedicalInstitution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalInstitution we want to update
     *   }
     * })
     */
    upsert<T extends MedicalInstitutionUpsertArgs>(args: SelectSubset<T, MedicalInstitutionUpsertArgs<ExtArgs>>): Prisma__MedicalInstitutionClient<$Result.GetResult<Prisma.$MedicalInstitutionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MedicalInstitutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalInstitutionCountArgs} args - Arguments to filter MedicalInstitutions to count.
     * @example
     * // Count the number of MedicalInstitutions
     * const count = await prisma.medicalInstitution.count({
     *   where: {
     *     // ... the filter for the MedicalInstitutions we want to count
     *   }
     * })
    **/
    count<T extends MedicalInstitutionCountArgs>(
      args?: Subset<T, MedicalInstitutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalInstitutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalInstitution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalInstitutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalInstitutionAggregateArgs>(args: Subset<T, MedicalInstitutionAggregateArgs>): Prisma.PrismaPromise<GetMedicalInstitutionAggregateType<T>>

    /**
     * Group by MedicalInstitution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalInstitutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalInstitutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalInstitutionGroupByArgs['orderBy'] }
        : { orderBy?: MedicalInstitutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalInstitutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalInstitutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicalInstitution model
   */
  readonly fields: MedicalInstitutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalInstitution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicalInstitutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emergencyAccesses<T extends MedicalInstitution$emergencyAccessesArgs<ExtArgs> = {}>(args?: Subset<T, MedicalInstitution$emergencyAccessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyAccessPayload<ExtArgs>, T, "findMany"> | Null>
    staff<T extends MedicalInstitution$staffArgs<ExtArgs> = {}>(args?: Subset<T, MedicalInstitution$staffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalStaffPayload<ExtArgs>, T, "findMany"> | Null>
    insuranceNetworks<T extends MedicalInstitution$insuranceNetworksArgs<ExtArgs> = {}>(args?: Subset<T, MedicalInstitution$insuranceNetworksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsuranceCompanyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicalInstitution model
   */ 
  interface MedicalInstitutionFieldRefs {
    readonly id: FieldRef<"MedicalInstitution", 'String'>
    readonly name: FieldRef<"MedicalInstitution", 'String'>
    readonly type: FieldRef<"MedicalInstitution", 'InstitutionType'>
    readonly cluesCode: FieldRef<"MedicalInstitution", 'String'>
    readonly address: FieldRef<"MedicalInstitution", 'String'>
    readonly city: FieldRef<"MedicalInstitution", 'String'>
    readonly state: FieldRef<"MedicalInstitution", 'String'>
    readonly zipCode: FieldRef<"MedicalInstitution", 'String'>
    readonly latitude: FieldRef<"MedicalInstitution", 'Float'>
    readonly longitude: FieldRef<"MedicalInstitution", 'Float'>
    readonly phone: FieldRef<"MedicalInstitution", 'String'>
    readonly emergencyPhone: FieldRef<"MedicalInstitution", 'String'>
    readonly email: FieldRef<"MedicalInstitution", 'String'>
    readonly attentionLevel: FieldRef<"MedicalInstitution", 'AttentionLevel'>
    readonly specialties: FieldRef<"MedicalInstitution", 'String[]'>
    readonly hasEmergency: FieldRef<"MedicalInstitution", 'Boolean'>
    readonly has24Hours: FieldRef<"MedicalInstitution", 'Boolean'>
    readonly hasICU: FieldRef<"MedicalInstitution", 'Boolean'>
    readonly hasTrauma: FieldRef<"MedicalInstitution", 'Boolean'>
    readonly oauthClientId: FieldRef<"MedicalInstitution", 'String'>
    readonly oauthClientSecret: FieldRef<"MedicalInstitution", 'String'>
    readonly isActive: FieldRef<"MedicalInstitution", 'Boolean'>
    readonly isVerified: FieldRef<"MedicalInstitution", 'Boolean'>
    readonly verifiedAt: FieldRef<"MedicalInstitution", 'DateTime'>
    readonly createdAt: FieldRef<"MedicalInstitution", 'DateTime'>
    readonly updatedAt: FieldRef<"MedicalInstitution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicalInstitution findUnique
   */
  export type MedicalInstitutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInstitution
     */
    select?: MedicalInstitutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInstitutionInclude<ExtArgs> | null
    /**
     * Filter, which MedicalInstitution to fetch.
     */
    where: MedicalInstitutionWhereUniqueInput
  }

  /**
   * MedicalInstitution findUniqueOrThrow
   */
  export type MedicalInstitutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInstitution
     */
    select?: MedicalInstitutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInstitutionInclude<ExtArgs> | null
    /**
     * Filter, which MedicalInstitution to fetch.
     */
    where: MedicalInstitutionWhereUniqueInput
  }

  /**
   * MedicalInstitution findFirst
   */
  export type MedicalInstitutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInstitution
     */
    select?: MedicalInstitutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInstitutionInclude<ExtArgs> | null
    /**
     * Filter, which MedicalInstitution to fetch.
     */
    where?: MedicalInstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalInstitutions to fetch.
     */
    orderBy?: MedicalInstitutionOrderByWithRelationInput | MedicalInstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalInstitutions.
     */
    cursor?: MedicalInstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalInstitutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalInstitutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalInstitutions.
     */
    distinct?: MedicalInstitutionScalarFieldEnum | MedicalInstitutionScalarFieldEnum[]
  }

  /**
   * MedicalInstitution findFirstOrThrow
   */
  export type MedicalInstitutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInstitution
     */
    select?: MedicalInstitutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInstitutionInclude<ExtArgs> | null
    /**
     * Filter, which MedicalInstitution to fetch.
     */
    where?: MedicalInstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalInstitutions to fetch.
     */
    orderBy?: MedicalInstitutionOrderByWithRelationInput | MedicalInstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalInstitutions.
     */
    cursor?: MedicalInstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalInstitutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalInstitutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalInstitutions.
     */
    distinct?: MedicalInstitutionScalarFieldEnum | MedicalInstitutionScalarFieldEnum[]
  }

  /**
   * MedicalInstitution findMany
   */
  export type MedicalInstitutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInstitution
     */
    select?: MedicalInstitutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInstitutionInclude<ExtArgs> | null
    /**
     * Filter, which MedicalInstitutions to fetch.
     */
    where?: MedicalInstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalInstitutions to fetch.
     */
    orderBy?: MedicalInstitutionOrderByWithRelationInput | MedicalInstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalInstitutions.
     */
    cursor?: MedicalInstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalInstitutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalInstitutions.
     */
    skip?: number
    distinct?: MedicalInstitutionScalarFieldEnum | MedicalInstitutionScalarFieldEnum[]
  }

  /**
   * MedicalInstitution create
   */
  export type MedicalInstitutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInstitution
     */
    select?: MedicalInstitutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInstitutionInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicalInstitution.
     */
    data: XOR<MedicalInstitutionCreateInput, MedicalInstitutionUncheckedCreateInput>
  }

  /**
   * MedicalInstitution createMany
   */
  export type MedicalInstitutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalInstitutions.
     */
    data: MedicalInstitutionCreateManyInput | MedicalInstitutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicalInstitution createManyAndReturn
   */
  export type MedicalInstitutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInstitution
     */
    select?: MedicalInstitutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MedicalInstitutions.
     */
    data: MedicalInstitutionCreateManyInput | MedicalInstitutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicalInstitution update
   */
  export type MedicalInstitutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInstitution
     */
    select?: MedicalInstitutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInstitutionInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicalInstitution.
     */
    data: XOR<MedicalInstitutionUpdateInput, MedicalInstitutionUncheckedUpdateInput>
    /**
     * Choose, which MedicalInstitution to update.
     */
    where: MedicalInstitutionWhereUniqueInput
  }

  /**
   * MedicalInstitution updateMany
   */
  export type MedicalInstitutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalInstitutions.
     */
    data: XOR<MedicalInstitutionUpdateManyMutationInput, MedicalInstitutionUncheckedUpdateManyInput>
    /**
     * Filter which MedicalInstitutions to update
     */
    where?: MedicalInstitutionWhereInput
  }

  /**
   * MedicalInstitution upsert
   */
  export type MedicalInstitutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInstitution
     */
    select?: MedicalInstitutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInstitutionInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicalInstitution to update in case it exists.
     */
    where: MedicalInstitutionWhereUniqueInput
    /**
     * In case the MedicalInstitution found by the `where` argument doesn't exist, create a new MedicalInstitution with this data.
     */
    create: XOR<MedicalInstitutionCreateInput, MedicalInstitutionUncheckedCreateInput>
    /**
     * In case the MedicalInstitution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalInstitutionUpdateInput, MedicalInstitutionUncheckedUpdateInput>
  }

  /**
   * MedicalInstitution delete
   */
  export type MedicalInstitutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInstitution
     */
    select?: MedicalInstitutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInstitutionInclude<ExtArgs> | null
    /**
     * Filter which MedicalInstitution to delete.
     */
    where: MedicalInstitutionWhereUniqueInput
  }

  /**
   * MedicalInstitution deleteMany
   */
  export type MedicalInstitutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalInstitutions to delete
     */
    where?: MedicalInstitutionWhereInput
  }

  /**
   * MedicalInstitution.emergencyAccesses
   */
  export type MedicalInstitution$emergencyAccessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAccess
     */
    select?: EmergencyAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAccessInclude<ExtArgs> | null
    where?: EmergencyAccessWhereInput
    orderBy?: EmergencyAccessOrderByWithRelationInput | EmergencyAccessOrderByWithRelationInput[]
    cursor?: EmergencyAccessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmergencyAccessScalarFieldEnum | EmergencyAccessScalarFieldEnum[]
  }

  /**
   * MedicalInstitution.staff
   */
  export type MedicalInstitution$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStaff
     */
    select?: MedicalStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStaffInclude<ExtArgs> | null
    where?: MedicalStaffWhereInput
    orderBy?: MedicalStaffOrderByWithRelationInput | MedicalStaffOrderByWithRelationInput[]
    cursor?: MedicalStaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalStaffScalarFieldEnum | MedicalStaffScalarFieldEnum[]
  }

  /**
   * MedicalInstitution.insuranceNetworks
   */
  export type MedicalInstitution$insuranceNetworksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceCompany
     */
    select?: InsuranceCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceCompanyInclude<ExtArgs> | null
    where?: InsuranceCompanyWhereInput
    orderBy?: InsuranceCompanyOrderByWithRelationInput | InsuranceCompanyOrderByWithRelationInput[]
    cursor?: InsuranceCompanyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsuranceCompanyScalarFieldEnum | InsuranceCompanyScalarFieldEnum[]
  }

  /**
   * MedicalInstitution without action
   */
  export type MedicalInstitutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInstitution
     */
    select?: MedicalInstitutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInstitutionInclude<ExtArgs> | null
  }


  /**
   * Model InsuranceCompany
   */

  export type AggregateInsuranceCompany = {
    _count: InsuranceCompanyCountAggregateOutputType | null
    _avg: InsuranceCompanyAvgAggregateOutputType | null
    _sum: InsuranceCompanySumAggregateOutputType | null
    _min: InsuranceCompanyMinAggregateOutputType | null
    _max: InsuranceCompanyMaxAggregateOutputType | null
  }

  export type InsuranceCompanyAvgAggregateOutputType = {
    networkSize: number | null
  }

  export type InsuranceCompanySumAggregateOutputType = {
    networkSize: number | null
  }

  export type InsuranceCompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    shortName: string | null
    type: $Enums.InsuranceType | null
    cnsfNumber: string | null
    rfc: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    phone: string | null
    emergencyPhone: string | null
    email: string | null
    website: string | null
    networkSize: number | null
    hasNationalCoverage: boolean | null
    isVerified: boolean | null
    verifiedAt: Date | null
    verifiedBy: string | null
    apiEnabled: boolean | null
    apiEndpoint: string | null
    logoUrl: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InsuranceCompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    shortName: string | null
    type: $Enums.InsuranceType | null
    cnsfNumber: string | null
    rfc: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    phone: string | null
    emergencyPhone: string | null
    email: string | null
    website: string | null
    networkSize: number | null
    hasNationalCoverage: boolean | null
    isVerified: boolean | null
    verifiedAt: Date | null
    verifiedBy: string | null
    apiEnabled: boolean | null
    apiEndpoint: string | null
    logoUrl: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InsuranceCompanyCountAggregateOutputType = {
    id: number
    name: number
    shortName: number
    type: number
    cnsfNumber: number
    rfc: number
    address: number
    city: number
    state: number
    zipCode: number
    phone: number
    emergencyPhone: number
    email: number
    website: number
    coverageTypes: number
    networkSize: number
    hasNationalCoverage: number
    statesCovered: number
    isVerified: number
    verifiedAt: number
    verifiedBy: number
    apiEnabled: number
    apiEndpoint: number
    logoUrl: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InsuranceCompanyAvgAggregateInputType = {
    networkSize?: true
  }

  export type InsuranceCompanySumAggregateInputType = {
    networkSize?: true
  }

  export type InsuranceCompanyMinAggregateInputType = {
    id?: true
    name?: true
    shortName?: true
    type?: true
    cnsfNumber?: true
    rfc?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    phone?: true
    emergencyPhone?: true
    email?: true
    website?: true
    networkSize?: true
    hasNationalCoverage?: true
    isVerified?: true
    verifiedAt?: true
    verifiedBy?: true
    apiEnabled?: true
    apiEndpoint?: true
    logoUrl?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InsuranceCompanyMaxAggregateInputType = {
    id?: true
    name?: true
    shortName?: true
    type?: true
    cnsfNumber?: true
    rfc?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    phone?: true
    emergencyPhone?: true
    email?: true
    website?: true
    networkSize?: true
    hasNationalCoverage?: true
    isVerified?: true
    verifiedAt?: true
    verifiedBy?: true
    apiEnabled?: true
    apiEndpoint?: true
    logoUrl?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InsuranceCompanyCountAggregateInputType = {
    id?: true
    name?: true
    shortName?: true
    type?: true
    cnsfNumber?: true
    rfc?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    phone?: true
    emergencyPhone?: true
    email?: true
    website?: true
    coverageTypes?: true
    networkSize?: true
    hasNationalCoverage?: true
    statesCovered?: true
    isVerified?: true
    verifiedAt?: true
    verifiedBy?: true
    apiEnabled?: true
    apiEndpoint?: true
    logoUrl?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InsuranceCompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsuranceCompany to aggregate.
     */
    where?: InsuranceCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsuranceCompanies to fetch.
     */
    orderBy?: InsuranceCompanyOrderByWithRelationInput | InsuranceCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InsuranceCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsuranceCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsuranceCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InsuranceCompanies
    **/
    _count?: true | InsuranceCompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InsuranceCompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InsuranceCompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsuranceCompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsuranceCompanyMaxAggregateInputType
  }

  export type GetInsuranceCompanyAggregateType<T extends InsuranceCompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateInsuranceCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsuranceCompany[P]>
      : GetScalarType<T[P], AggregateInsuranceCompany[P]>
  }




  export type InsuranceCompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsuranceCompanyWhereInput
    orderBy?: InsuranceCompanyOrderByWithAggregationInput | InsuranceCompanyOrderByWithAggregationInput[]
    by: InsuranceCompanyScalarFieldEnum[] | InsuranceCompanyScalarFieldEnum
    having?: InsuranceCompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsuranceCompanyCountAggregateInputType | true
    _avg?: InsuranceCompanyAvgAggregateInputType
    _sum?: InsuranceCompanySumAggregateInputType
    _min?: InsuranceCompanyMinAggregateInputType
    _max?: InsuranceCompanyMaxAggregateInputType
  }

  export type InsuranceCompanyGroupByOutputType = {
    id: string
    name: string
    shortName: string | null
    type: $Enums.InsuranceType
    cnsfNumber: string | null
    rfc: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    phone: string | null
    emergencyPhone: string | null
    email: string | null
    website: string | null
    coverageTypes: string[]
    networkSize: number | null
    hasNationalCoverage: boolean
    statesCovered: string[]
    isVerified: boolean
    verifiedAt: Date | null
    verifiedBy: string | null
    apiEnabled: boolean
    apiEndpoint: string | null
    logoUrl: string | null
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: InsuranceCompanyCountAggregateOutputType | null
    _avg: InsuranceCompanyAvgAggregateOutputType | null
    _sum: InsuranceCompanySumAggregateOutputType | null
    _min: InsuranceCompanyMinAggregateOutputType | null
    _max: InsuranceCompanyMaxAggregateOutputType | null
  }

  type GetInsuranceCompanyGroupByPayload<T extends InsuranceCompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InsuranceCompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsuranceCompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsuranceCompanyGroupByOutputType[P]>
            : GetScalarType<T[P], InsuranceCompanyGroupByOutputType[P]>
        }
      >
    >


  export type InsuranceCompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shortName?: boolean
    type?: boolean
    cnsfNumber?: boolean
    rfc?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    phone?: boolean
    emergencyPhone?: boolean
    email?: boolean
    website?: boolean
    coverageTypes?: boolean
    networkSize?: boolean
    hasNationalCoverage?: boolean
    statesCovered?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    verifiedBy?: boolean
    apiEnabled?: boolean
    apiEndpoint?: boolean
    logoUrl?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plans?: boolean | InsuranceCompany$plansArgs<ExtArgs>
    networkHospitals?: boolean | InsuranceCompany$networkHospitalsArgs<ExtArgs>
    emergencyAccesses?: boolean | InsuranceCompany$emergencyAccessesArgs<ExtArgs>
    _count?: boolean | InsuranceCompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insuranceCompany"]>

  export type InsuranceCompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shortName?: boolean
    type?: boolean
    cnsfNumber?: boolean
    rfc?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    phone?: boolean
    emergencyPhone?: boolean
    email?: boolean
    website?: boolean
    coverageTypes?: boolean
    networkSize?: boolean
    hasNationalCoverage?: boolean
    statesCovered?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    verifiedBy?: boolean
    apiEnabled?: boolean
    apiEndpoint?: boolean
    logoUrl?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["insuranceCompany"]>

  export type InsuranceCompanySelectScalar = {
    id?: boolean
    name?: boolean
    shortName?: boolean
    type?: boolean
    cnsfNumber?: boolean
    rfc?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    phone?: boolean
    emergencyPhone?: boolean
    email?: boolean
    website?: boolean
    coverageTypes?: boolean
    networkSize?: boolean
    hasNationalCoverage?: boolean
    statesCovered?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    verifiedBy?: boolean
    apiEnabled?: boolean
    apiEndpoint?: boolean
    logoUrl?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InsuranceCompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plans?: boolean | InsuranceCompany$plansArgs<ExtArgs>
    networkHospitals?: boolean | InsuranceCompany$networkHospitalsArgs<ExtArgs>
    emergencyAccesses?: boolean | InsuranceCompany$emergencyAccessesArgs<ExtArgs>
    _count?: boolean | InsuranceCompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InsuranceCompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InsuranceCompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InsuranceCompany"
    objects: {
      plans: Prisma.$InsurancePlanPayload<ExtArgs>[]
      networkHospitals: Prisma.$MedicalInstitutionPayload<ExtArgs>[]
      emergencyAccesses: Prisma.$EmergencyAccessPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      shortName: string | null
      type: $Enums.InsuranceType
      cnsfNumber: string | null
      rfc: string | null
      address: string | null
      city: string | null
      state: string | null
      zipCode: string | null
      phone: string | null
      emergencyPhone: string | null
      email: string | null
      website: string | null
      coverageTypes: string[]
      networkSize: number | null
      hasNationalCoverage: boolean
      statesCovered: string[]
      isVerified: boolean
      verifiedAt: Date | null
      verifiedBy: string | null
      apiEnabled: boolean
      apiEndpoint: string | null
      logoUrl: string | null
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["insuranceCompany"]>
    composites: {}
  }

  type InsuranceCompanyGetPayload<S extends boolean | null | undefined | InsuranceCompanyDefaultArgs> = $Result.GetResult<Prisma.$InsuranceCompanyPayload, S>

  type InsuranceCompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InsuranceCompanyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InsuranceCompanyCountAggregateInputType | true
    }

  export interface InsuranceCompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InsuranceCompany'], meta: { name: 'InsuranceCompany' } }
    /**
     * Find zero or one InsuranceCompany that matches the filter.
     * @param {InsuranceCompanyFindUniqueArgs} args - Arguments to find a InsuranceCompany
     * @example
     * // Get one InsuranceCompany
     * const insuranceCompany = await prisma.insuranceCompany.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InsuranceCompanyFindUniqueArgs>(args: SelectSubset<T, InsuranceCompanyFindUniqueArgs<ExtArgs>>): Prisma__InsuranceCompanyClient<$Result.GetResult<Prisma.$InsuranceCompanyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InsuranceCompany that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InsuranceCompanyFindUniqueOrThrowArgs} args - Arguments to find a InsuranceCompany
     * @example
     * // Get one InsuranceCompany
     * const insuranceCompany = await prisma.insuranceCompany.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InsuranceCompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, InsuranceCompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InsuranceCompanyClient<$Result.GetResult<Prisma.$InsuranceCompanyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InsuranceCompany that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceCompanyFindFirstArgs} args - Arguments to find a InsuranceCompany
     * @example
     * // Get one InsuranceCompany
     * const insuranceCompany = await prisma.insuranceCompany.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InsuranceCompanyFindFirstArgs>(args?: SelectSubset<T, InsuranceCompanyFindFirstArgs<ExtArgs>>): Prisma__InsuranceCompanyClient<$Result.GetResult<Prisma.$InsuranceCompanyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InsuranceCompany that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceCompanyFindFirstOrThrowArgs} args - Arguments to find a InsuranceCompany
     * @example
     * // Get one InsuranceCompany
     * const insuranceCompany = await prisma.insuranceCompany.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InsuranceCompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, InsuranceCompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__InsuranceCompanyClient<$Result.GetResult<Prisma.$InsuranceCompanyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InsuranceCompanies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceCompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InsuranceCompanies
     * const insuranceCompanies = await prisma.insuranceCompany.findMany()
     * 
     * // Get first 10 InsuranceCompanies
     * const insuranceCompanies = await prisma.insuranceCompany.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const insuranceCompanyWithIdOnly = await prisma.insuranceCompany.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InsuranceCompanyFindManyArgs>(args?: SelectSubset<T, InsuranceCompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsuranceCompanyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InsuranceCompany.
     * @param {InsuranceCompanyCreateArgs} args - Arguments to create a InsuranceCompany.
     * @example
     * // Create one InsuranceCompany
     * const InsuranceCompany = await prisma.insuranceCompany.create({
     *   data: {
     *     // ... data to create a InsuranceCompany
     *   }
     * })
     * 
     */
    create<T extends InsuranceCompanyCreateArgs>(args: SelectSubset<T, InsuranceCompanyCreateArgs<ExtArgs>>): Prisma__InsuranceCompanyClient<$Result.GetResult<Prisma.$InsuranceCompanyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InsuranceCompanies.
     * @param {InsuranceCompanyCreateManyArgs} args - Arguments to create many InsuranceCompanies.
     * @example
     * // Create many InsuranceCompanies
     * const insuranceCompany = await prisma.insuranceCompany.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InsuranceCompanyCreateManyArgs>(args?: SelectSubset<T, InsuranceCompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InsuranceCompanies and returns the data saved in the database.
     * @param {InsuranceCompanyCreateManyAndReturnArgs} args - Arguments to create many InsuranceCompanies.
     * @example
     * // Create many InsuranceCompanies
     * const insuranceCompany = await prisma.insuranceCompany.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InsuranceCompanies and only return the `id`
     * const insuranceCompanyWithIdOnly = await prisma.insuranceCompany.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InsuranceCompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, InsuranceCompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsuranceCompanyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InsuranceCompany.
     * @param {InsuranceCompanyDeleteArgs} args - Arguments to delete one InsuranceCompany.
     * @example
     * // Delete one InsuranceCompany
     * const InsuranceCompany = await prisma.insuranceCompany.delete({
     *   where: {
     *     // ... filter to delete one InsuranceCompany
     *   }
     * })
     * 
     */
    delete<T extends InsuranceCompanyDeleteArgs>(args: SelectSubset<T, InsuranceCompanyDeleteArgs<ExtArgs>>): Prisma__InsuranceCompanyClient<$Result.GetResult<Prisma.$InsuranceCompanyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InsuranceCompany.
     * @param {InsuranceCompanyUpdateArgs} args - Arguments to update one InsuranceCompany.
     * @example
     * // Update one InsuranceCompany
     * const insuranceCompany = await prisma.insuranceCompany.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InsuranceCompanyUpdateArgs>(args: SelectSubset<T, InsuranceCompanyUpdateArgs<ExtArgs>>): Prisma__InsuranceCompanyClient<$Result.GetResult<Prisma.$InsuranceCompanyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InsuranceCompanies.
     * @param {InsuranceCompanyDeleteManyArgs} args - Arguments to filter InsuranceCompanies to delete.
     * @example
     * // Delete a few InsuranceCompanies
     * const { count } = await prisma.insuranceCompany.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InsuranceCompanyDeleteManyArgs>(args?: SelectSubset<T, InsuranceCompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InsuranceCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceCompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InsuranceCompanies
     * const insuranceCompany = await prisma.insuranceCompany.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InsuranceCompanyUpdateManyArgs>(args: SelectSubset<T, InsuranceCompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InsuranceCompany.
     * @param {InsuranceCompanyUpsertArgs} args - Arguments to update or create a InsuranceCompany.
     * @example
     * // Update or create a InsuranceCompany
     * const insuranceCompany = await prisma.insuranceCompany.upsert({
     *   create: {
     *     // ... data to create a InsuranceCompany
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InsuranceCompany we want to update
     *   }
     * })
     */
    upsert<T extends InsuranceCompanyUpsertArgs>(args: SelectSubset<T, InsuranceCompanyUpsertArgs<ExtArgs>>): Prisma__InsuranceCompanyClient<$Result.GetResult<Prisma.$InsuranceCompanyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InsuranceCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceCompanyCountArgs} args - Arguments to filter InsuranceCompanies to count.
     * @example
     * // Count the number of InsuranceCompanies
     * const count = await prisma.insuranceCompany.count({
     *   where: {
     *     // ... the filter for the InsuranceCompanies we want to count
     *   }
     * })
    **/
    count<T extends InsuranceCompanyCountArgs>(
      args?: Subset<T, InsuranceCompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsuranceCompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InsuranceCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceCompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsuranceCompanyAggregateArgs>(args: Subset<T, InsuranceCompanyAggregateArgs>): Prisma.PrismaPromise<GetInsuranceCompanyAggregateType<T>>

    /**
     * Group by InsuranceCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceCompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InsuranceCompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InsuranceCompanyGroupByArgs['orderBy'] }
        : { orderBy?: InsuranceCompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InsuranceCompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsuranceCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InsuranceCompany model
   */
  readonly fields: InsuranceCompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InsuranceCompany.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InsuranceCompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plans<T extends InsuranceCompany$plansArgs<ExtArgs> = {}>(args?: Subset<T, InsuranceCompany$plansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsurancePlanPayload<ExtArgs>, T, "findMany"> | Null>
    networkHospitals<T extends InsuranceCompany$networkHospitalsArgs<ExtArgs> = {}>(args?: Subset<T, InsuranceCompany$networkHospitalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalInstitutionPayload<ExtArgs>, T, "findMany"> | Null>
    emergencyAccesses<T extends InsuranceCompany$emergencyAccessesArgs<ExtArgs> = {}>(args?: Subset<T, InsuranceCompany$emergencyAccessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyAccessPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InsuranceCompany model
   */ 
  interface InsuranceCompanyFieldRefs {
    readonly id: FieldRef<"InsuranceCompany", 'String'>
    readonly name: FieldRef<"InsuranceCompany", 'String'>
    readonly shortName: FieldRef<"InsuranceCompany", 'String'>
    readonly type: FieldRef<"InsuranceCompany", 'InsuranceType'>
    readonly cnsfNumber: FieldRef<"InsuranceCompany", 'String'>
    readonly rfc: FieldRef<"InsuranceCompany", 'String'>
    readonly address: FieldRef<"InsuranceCompany", 'String'>
    readonly city: FieldRef<"InsuranceCompany", 'String'>
    readonly state: FieldRef<"InsuranceCompany", 'String'>
    readonly zipCode: FieldRef<"InsuranceCompany", 'String'>
    readonly phone: FieldRef<"InsuranceCompany", 'String'>
    readonly emergencyPhone: FieldRef<"InsuranceCompany", 'String'>
    readonly email: FieldRef<"InsuranceCompany", 'String'>
    readonly website: FieldRef<"InsuranceCompany", 'String'>
    readonly coverageTypes: FieldRef<"InsuranceCompany", 'String[]'>
    readonly networkSize: FieldRef<"InsuranceCompany", 'Int'>
    readonly hasNationalCoverage: FieldRef<"InsuranceCompany", 'Boolean'>
    readonly statesCovered: FieldRef<"InsuranceCompany", 'String[]'>
    readonly isVerified: FieldRef<"InsuranceCompany", 'Boolean'>
    readonly verifiedAt: FieldRef<"InsuranceCompany", 'DateTime'>
    readonly verifiedBy: FieldRef<"InsuranceCompany", 'String'>
    readonly apiEnabled: FieldRef<"InsuranceCompany", 'Boolean'>
    readonly apiEndpoint: FieldRef<"InsuranceCompany", 'String'>
    readonly logoUrl: FieldRef<"InsuranceCompany", 'String'>
    readonly description: FieldRef<"InsuranceCompany", 'String'>
    readonly isActive: FieldRef<"InsuranceCompany", 'Boolean'>
    readonly createdAt: FieldRef<"InsuranceCompany", 'DateTime'>
    readonly updatedAt: FieldRef<"InsuranceCompany", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InsuranceCompany findUnique
   */
  export type InsuranceCompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceCompany
     */
    select?: InsuranceCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceCompanyInclude<ExtArgs> | null
    /**
     * Filter, which InsuranceCompany to fetch.
     */
    where: InsuranceCompanyWhereUniqueInput
  }

  /**
   * InsuranceCompany findUniqueOrThrow
   */
  export type InsuranceCompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceCompany
     */
    select?: InsuranceCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceCompanyInclude<ExtArgs> | null
    /**
     * Filter, which InsuranceCompany to fetch.
     */
    where: InsuranceCompanyWhereUniqueInput
  }

  /**
   * InsuranceCompany findFirst
   */
  export type InsuranceCompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceCompany
     */
    select?: InsuranceCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceCompanyInclude<ExtArgs> | null
    /**
     * Filter, which InsuranceCompany to fetch.
     */
    where?: InsuranceCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsuranceCompanies to fetch.
     */
    orderBy?: InsuranceCompanyOrderByWithRelationInput | InsuranceCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsuranceCompanies.
     */
    cursor?: InsuranceCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsuranceCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsuranceCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsuranceCompanies.
     */
    distinct?: InsuranceCompanyScalarFieldEnum | InsuranceCompanyScalarFieldEnum[]
  }

  /**
   * InsuranceCompany findFirstOrThrow
   */
  export type InsuranceCompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceCompany
     */
    select?: InsuranceCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceCompanyInclude<ExtArgs> | null
    /**
     * Filter, which InsuranceCompany to fetch.
     */
    where?: InsuranceCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsuranceCompanies to fetch.
     */
    orderBy?: InsuranceCompanyOrderByWithRelationInput | InsuranceCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsuranceCompanies.
     */
    cursor?: InsuranceCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsuranceCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsuranceCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsuranceCompanies.
     */
    distinct?: InsuranceCompanyScalarFieldEnum | InsuranceCompanyScalarFieldEnum[]
  }

  /**
   * InsuranceCompany findMany
   */
  export type InsuranceCompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceCompany
     */
    select?: InsuranceCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceCompanyInclude<ExtArgs> | null
    /**
     * Filter, which InsuranceCompanies to fetch.
     */
    where?: InsuranceCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsuranceCompanies to fetch.
     */
    orderBy?: InsuranceCompanyOrderByWithRelationInput | InsuranceCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InsuranceCompanies.
     */
    cursor?: InsuranceCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsuranceCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsuranceCompanies.
     */
    skip?: number
    distinct?: InsuranceCompanyScalarFieldEnum | InsuranceCompanyScalarFieldEnum[]
  }

  /**
   * InsuranceCompany create
   */
  export type InsuranceCompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceCompany
     */
    select?: InsuranceCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceCompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a InsuranceCompany.
     */
    data: XOR<InsuranceCompanyCreateInput, InsuranceCompanyUncheckedCreateInput>
  }

  /**
   * InsuranceCompany createMany
   */
  export type InsuranceCompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InsuranceCompanies.
     */
    data: InsuranceCompanyCreateManyInput | InsuranceCompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InsuranceCompany createManyAndReturn
   */
  export type InsuranceCompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceCompany
     */
    select?: InsuranceCompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InsuranceCompanies.
     */
    data: InsuranceCompanyCreateManyInput | InsuranceCompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InsuranceCompany update
   */
  export type InsuranceCompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceCompany
     */
    select?: InsuranceCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceCompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a InsuranceCompany.
     */
    data: XOR<InsuranceCompanyUpdateInput, InsuranceCompanyUncheckedUpdateInput>
    /**
     * Choose, which InsuranceCompany to update.
     */
    where: InsuranceCompanyWhereUniqueInput
  }

  /**
   * InsuranceCompany updateMany
   */
  export type InsuranceCompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InsuranceCompanies.
     */
    data: XOR<InsuranceCompanyUpdateManyMutationInput, InsuranceCompanyUncheckedUpdateManyInput>
    /**
     * Filter which InsuranceCompanies to update
     */
    where?: InsuranceCompanyWhereInput
  }

  /**
   * InsuranceCompany upsert
   */
  export type InsuranceCompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceCompany
     */
    select?: InsuranceCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceCompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the InsuranceCompany to update in case it exists.
     */
    where: InsuranceCompanyWhereUniqueInput
    /**
     * In case the InsuranceCompany found by the `where` argument doesn't exist, create a new InsuranceCompany with this data.
     */
    create: XOR<InsuranceCompanyCreateInput, InsuranceCompanyUncheckedCreateInput>
    /**
     * In case the InsuranceCompany was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InsuranceCompanyUpdateInput, InsuranceCompanyUncheckedUpdateInput>
  }

  /**
   * InsuranceCompany delete
   */
  export type InsuranceCompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceCompany
     */
    select?: InsuranceCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceCompanyInclude<ExtArgs> | null
    /**
     * Filter which InsuranceCompany to delete.
     */
    where: InsuranceCompanyWhereUniqueInput
  }

  /**
   * InsuranceCompany deleteMany
   */
  export type InsuranceCompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsuranceCompanies to delete
     */
    where?: InsuranceCompanyWhereInput
  }

  /**
   * InsuranceCompany.plans
   */
  export type InsuranceCompany$plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePlan
     */
    select?: InsurancePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePlanInclude<ExtArgs> | null
    where?: InsurancePlanWhereInput
    orderBy?: InsurancePlanOrderByWithRelationInput | InsurancePlanOrderByWithRelationInput[]
    cursor?: InsurancePlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsurancePlanScalarFieldEnum | InsurancePlanScalarFieldEnum[]
  }

  /**
   * InsuranceCompany.networkHospitals
   */
  export type InsuranceCompany$networkHospitalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInstitution
     */
    select?: MedicalInstitutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInstitutionInclude<ExtArgs> | null
    where?: MedicalInstitutionWhereInput
    orderBy?: MedicalInstitutionOrderByWithRelationInput | MedicalInstitutionOrderByWithRelationInput[]
    cursor?: MedicalInstitutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalInstitutionScalarFieldEnum | MedicalInstitutionScalarFieldEnum[]
  }

  /**
   * InsuranceCompany.emergencyAccesses
   */
  export type InsuranceCompany$emergencyAccessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAccess
     */
    select?: EmergencyAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAccessInclude<ExtArgs> | null
    where?: EmergencyAccessWhereInput
    orderBy?: EmergencyAccessOrderByWithRelationInput | EmergencyAccessOrderByWithRelationInput[]
    cursor?: EmergencyAccessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmergencyAccessScalarFieldEnum | EmergencyAccessScalarFieldEnum[]
  }

  /**
   * InsuranceCompany without action
   */
  export type InsuranceCompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceCompany
     */
    select?: InsuranceCompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceCompanyInclude<ExtArgs> | null
  }


  /**
   * Model InsurancePlan
   */

  export type AggregateInsurancePlan = {
    _count: InsurancePlanCountAggregateOutputType | null
    _avg: InsurancePlanAvgAggregateOutputType | null
    _sum: InsurancePlanSumAggregateOutputType | null
    _min: InsurancePlanMinAggregateOutputType | null
    _max: InsurancePlanMaxAggregateOutputType | null
  }

  export type InsurancePlanAvgAggregateOutputType = {
    sumAssured: number | null
    deductible: number | null
    coinsurance: number | null
  }

  export type InsurancePlanSumAggregateOutputType = {
    sumAssured: number | null
    deductible: number | null
    coinsurance: number | null
  }

  export type InsurancePlanMinAggregateOutputType = {
    id: string | null
    insuranceId: string | null
    name: string | null
    code: string | null
    sumAssured: number | null
    deductible: number | null
    coinsurance: number | null
    hospitalLevel: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InsurancePlanMaxAggregateOutputType = {
    id: string | null
    insuranceId: string | null
    name: string | null
    code: string | null
    sumAssured: number | null
    deductible: number | null
    coinsurance: number | null
    hospitalLevel: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InsurancePlanCountAggregateOutputType = {
    id: number
    insuranceId: number
    name: number
    code: number
    sumAssured: number
    deductible: number
    coinsurance: number
    features: number
    exclusions: number
    hospitalLevel: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InsurancePlanAvgAggregateInputType = {
    sumAssured?: true
    deductible?: true
    coinsurance?: true
  }

  export type InsurancePlanSumAggregateInputType = {
    sumAssured?: true
    deductible?: true
    coinsurance?: true
  }

  export type InsurancePlanMinAggregateInputType = {
    id?: true
    insuranceId?: true
    name?: true
    code?: true
    sumAssured?: true
    deductible?: true
    coinsurance?: true
    hospitalLevel?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InsurancePlanMaxAggregateInputType = {
    id?: true
    insuranceId?: true
    name?: true
    code?: true
    sumAssured?: true
    deductible?: true
    coinsurance?: true
    hospitalLevel?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InsurancePlanCountAggregateInputType = {
    id?: true
    insuranceId?: true
    name?: true
    code?: true
    sumAssured?: true
    deductible?: true
    coinsurance?: true
    features?: true
    exclusions?: true
    hospitalLevel?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InsurancePlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsurancePlan to aggregate.
     */
    where?: InsurancePlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsurancePlans to fetch.
     */
    orderBy?: InsurancePlanOrderByWithRelationInput | InsurancePlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InsurancePlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsurancePlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsurancePlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InsurancePlans
    **/
    _count?: true | InsurancePlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InsurancePlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InsurancePlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsurancePlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsurancePlanMaxAggregateInputType
  }

  export type GetInsurancePlanAggregateType<T extends InsurancePlanAggregateArgs> = {
        [P in keyof T & keyof AggregateInsurancePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsurancePlan[P]>
      : GetScalarType<T[P], AggregateInsurancePlan[P]>
  }




  export type InsurancePlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsurancePlanWhereInput
    orderBy?: InsurancePlanOrderByWithAggregationInput | InsurancePlanOrderByWithAggregationInput[]
    by: InsurancePlanScalarFieldEnum[] | InsurancePlanScalarFieldEnum
    having?: InsurancePlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsurancePlanCountAggregateInputType | true
    _avg?: InsurancePlanAvgAggregateInputType
    _sum?: InsurancePlanSumAggregateInputType
    _min?: InsurancePlanMinAggregateInputType
    _max?: InsurancePlanMaxAggregateInputType
  }

  export type InsurancePlanGroupByOutputType = {
    id: string
    insuranceId: string
    name: string
    code: string | null
    sumAssured: number | null
    deductible: number | null
    coinsurance: number | null
    features: string[]
    exclusions: string[]
    hospitalLevel: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: InsurancePlanCountAggregateOutputType | null
    _avg: InsurancePlanAvgAggregateOutputType | null
    _sum: InsurancePlanSumAggregateOutputType | null
    _min: InsurancePlanMinAggregateOutputType | null
    _max: InsurancePlanMaxAggregateOutputType | null
  }

  type GetInsurancePlanGroupByPayload<T extends InsurancePlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InsurancePlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsurancePlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsurancePlanGroupByOutputType[P]>
            : GetScalarType<T[P], InsurancePlanGroupByOutputType[P]>
        }
      >
    >


  export type InsurancePlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insuranceId?: boolean
    name?: boolean
    code?: boolean
    sumAssured?: boolean
    deductible?: boolean
    coinsurance?: boolean
    features?: boolean
    exclusions?: boolean
    hospitalLevel?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    insurance?: boolean | InsuranceCompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insurancePlan"]>

  export type InsurancePlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insuranceId?: boolean
    name?: boolean
    code?: boolean
    sumAssured?: boolean
    deductible?: boolean
    coinsurance?: boolean
    features?: boolean
    exclusions?: boolean
    hospitalLevel?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    insurance?: boolean | InsuranceCompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insurancePlan"]>

  export type InsurancePlanSelectScalar = {
    id?: boolean
    insuranceId?: boolean
    name?: boolean
    code?: boolean
    sumAssured?: boolean
    deductible?: boolean
    coinsurance?: boolean
    features?: boolean
    exclusions?: boolean
    hospitalLevel?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InsurancePlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurance?: boolean | InsuranceCompanyDefaultArgs<ExtArgs>
  }
  export type InsurancePlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurance?: boolean | InsuranceCompanyDefaultArgs<ExtArgs>
  }

  export type $InsurancePlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InsurancePlan"
    objects: {
      insurance: Prisma.$InsuranceCompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      insuranceId: string
      name: string
      code: string | null
      sumAssured: number | null
      deductible: number | null
      coinsurance: number | null
      features: string[]
      exclusions: string[]
      hospitalLevel: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["insurancePlan"]>
    composites: {}
  }

  type InsurancePlanGetPayload<S extends boolean | null | undefined | InsurancePlanDefaultArgs> = $Result.GetResult<Prisma.$InsurancePlanPayload, S>

  type InsurancePlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InsurancePlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InsurancePlanCountAggregateInputType | true
    }

  export interface InsurancePlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InsurancePlan'], meta: { name: 'InsurancePlan' } }
    /**
     * Find zero or one InsurancePlan that matches the filter.
     * @param {InsurancePlanFindUniqueArgs} args - Arguments to find a InsurancePlan
     * @example
     * // Get one InsurancePlan
     * const insurancePlan = await prisma.insurancePlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InsurancePlanFindUniqueArgs>(args: SelectSubset<T, InsurancePlanFindUniqueArgs<ExtArgs>>): Prisma__InsurancePlanClient<$Result.GetResult<Prisma.$InsurancePlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InsurancePlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InsurancePlanFindUniqueOrThrowArgs} args - Arguments to find a InsurancePlan
     * @example
     * // Get one InsurancePlan
     * const insurancePlan = await prisma.insurancePlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InsurancePlanFindUniqueOrThrowArgs>(args: SelectSubset<T, InsurancePlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InsurancePlanClient<$Result.GetResult<Prisma.$InsurancePlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InsurancePlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurancePlanFindFirstArgs} args - Arguments to find a InsurancePlan
     * @example
     * // Get one InsurancePlan
     * const insurancePlan = await prisma.insurancePlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InsurancePlanFindFirstArgs>(args?: SelectSubset<T, InsurancePlanFindFirstArgs<ExtArgs>>): Prisma__InsurancePlanClient<$Result.GetResult<Prisma.$InsurancePlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InsurancePlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurancePlanFindFirstOrThrowArgs} args - Arguments to find a InsurancePlan
     * @example
     * // Get one InsurancePlan
     * const insurancePlan = await prisma.insurancePlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InsurancePlanFindFirstOrThrowArgs>(args?: SelectSubset<T, InsurancePlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__InsurancePlanClient<$Result.GetResult<Prisma.$InsurancePlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InsurancePlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurancePlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InsurancePlans
     * const insurancePlans = await prisma.insurancePlan.findMany()
     * 
     * // Get first 10 InsurancePlans
     * const insurancePlans = await prisma.insurancePlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const insurancePlanWithIdOnly = await prisma.insurancePlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InsurancePlanFindManyArgs>(args?: SelectSubset<T, InsurancePlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsurancePlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InsurancePlan.
     * @param {InsurancePlanCreateArgs} args - Arguments to create a InsurancePlan.
     * @example
     * // Create one InsurancePlan
     * const InsurancePlan = await prisma.insurancePlan.create({
     *   data: {
     *     // ... data to create a InsurancePlan
     *   }
     * })
     * 
     */
    create<T extends InsurancePlanCreateArgs>(args: SelectSubset<T, InsurancePlanCreateArgs<ExtArgs>>): Prisma__InsurancePlanClient<$Result.GetResult<Prisma.$InsurancePlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InsurancePlans.
     * @param {InsurancePlanCreateManyArgs} args - Arguments to create many InsurancePlans.
     * @example
     * // Create many InsurancePlans
     * const insurancePlan = await prisma.insurancePlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InsurancePlanCreateManyArgs>(args?: SelectSubset<T, InsurancePlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InsurancePlans and returns the data saved in the database.
     * @param {InsurancePlanCreateManyAndReturnArgs} args - Arguments to create many InsurancePlans.
     * @example
     * // Create many InsurancePlans
     * const insurancePlan = await prisma.insurancePlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InsurancePlans and only return the `id`
     * const insurancePlanWithIdOnly = await prisma.insurancePlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InsurancePlanCreateManyAndReturnArgs>(args?: SelectSubset<T, InsurancePlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsurancePlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InsurancePlan.
     * @param {InsurancePlanDeleteArgs} args - Arguments to delete one InsurancePlan.
     * @example
     * // Delete one InsurancePlan
     * const InsurancePlan = await prisma.insurancePlan.delete({
     *   where: {
     *     // ... filter to delete one InsurancePlan
     *   }
     * })
     * 
     */
    delete<T extends InsurancePlanDeleteArgs>(args: SelectSubset<T, InsurancePlanDeleteArgs<ExtArgs>>): Prisma__InsurancePlanClient<$Result.GetResult<Prisma.$InsurancePlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InsurancePlan.
     * @param {InsurancePlanUpdateArgs} args - Arguments to update one InsurancePlan.
     * @example
     * // Update one InsurancePlan
     * const insurancePlan = await prisma.insurancePlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InsurancePlanUpdateArgs>(args: SelectSubset<T, InsurancePlanUpdateArgs<ExtArgs>>): Prisma__InsurancePlanClient<$Result.GetResult<Prisma.$InsurancePlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InsurancePlans.
     * @param {InsurancePlanDeleteManyArgs} args - Arguments to filter InsurancePlans to delete.
     * @example
     * // Delete a few InsurancePlans
     * const { count } = await prisma.insurancePlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InsurancePlanDeleteManyArgs>(args?: SelectSubset<T, InsurancePlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InsurancePlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurancePlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InsurancePlans
     * const insurancePlan = await prisma.insurancePlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InsurancePlanUpdateManyArgs>(args: SelectSubset<T, InsurancePlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InsurancePlan.
     * @param {InsurancePlanUpsertArgs} args - Arguments to update or create a InsurancePlan.
     * @example
     * // Update or create a InsurancePlan
     * const insurancePlan = await prisma.insurancePlan.upsert({
     *   create: {
     *     // ... data to create a InsurancePlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InsurancePlan we want to update
     *   }
     * })
     */
    upsert<T extends InsurancePlanUpsertArgs>(args: SelectSubset<T, InsurancePlanUpsertArgs<ExtArgs>>): Prisma__InsurancePlanClient<$Result.GetResult<Prisma.$InsurancePlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InsurancePlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurancePlanCountArgs} args - Arguments to filter InsurancePlans to count.
     * @example
     * // Count the number of InsurancePlans
     * const count = await prisma.insurancePlan.count({
     *   where: {
     *     // ... the filter for the InsurancePlans we want to count
     *   }
     * })
    **/
    count<T extends InsurancePlanCountArgs>(
      args?: Subset<T, InsurancePlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsurancePlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InsurancePlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurancePlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsurancePlanAggregateArgs>(args: Subset<T, InsurancePlanAggregateArgs>): Prisma.PrismaPromise<GetInsurancePlanAggregateType<T>>

    /**
     * Group by InsurancePlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurancePlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InsurancePlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InsurancePlanGroupByArgs['orderBy'] }
        : { orderBy?: InsurancePlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InsurancePlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsurancePlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InsurancePlan model
   */
  readonly fields: InsurancePlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InsurancePlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InsurancePlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insurance<T extends InsuranceCompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InsuranceCompanyDefaultArgs<ExtArgs>>): Prisma__InsuranceCompanyClient<$Result.GetResult<Prisma.$InsuranceCompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InsurancePlan model
   */ 
  interface InsurancePlanFieldRefs {
    readonly id: FieldRef<"InsurancePlan", 'String'>
    readonly insuranceId: FieldRef<"InsurancePlan", 'String'>
    readonly name: FieldRef<"InsurancePlan", 'String'>
    readonly code: FieldRef<"InsurancePlan", 'String'>
    readonly sumAssured: FieldRef<"InsurancePlan", 'Float'>
    readonly deductible: FieldRef<"InsurancePlan", 'Float'>
    readonly coinsurance: FieldRef<"InsurancePlan", 'Float'>
    readonly features: FieldRef<"InsurancePlan", 'String[]'>
    readonly exclusions: FieldRef<"InsurancePlan", 'String[]'>
    readonly hospitalLevel: FieldRef<"InsurancePlan", 'String'>
    readonly isActive: FieldRef<"InsurancePlan", 'Boolean'>
    readonly createdAt: FieldRef<"InsurancePlan", 'DateTime'>
    readonly updatedAt: FieldRef<"InsurancePlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InsurancePlan findUnique
   */
  export type InsurancePlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePlan
     */
    select?: InsurancePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePlanInclude<ExtArgs> | null
    /**
     * Filter, which InsurancePlan to fetch.
     */
    where: InsurancePlanWhereUniqueInput
  }

  /**
   * InsurancePlan findUniqueOrThrow
   */
  export type InsurancePlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePlan
     */
    select?: InsurancePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePlanInclude<ExtArgs> | null
    /**
     * Filter, which InsurancePlan to fetch.
     */
    where: InsurancePlanWhereUniqueInput
  }

  /**
   * InsurancePlan findFirst
   */
  export type InsurancePlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePlan
     */
    select?: InsurancePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePlanInclude<ExtArgs> | null
    /**
     * Filter, which InsurancePlan to fetch.
     */
    where?: InsurancePlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsurancePlans to fetch.
     */
    orderBy?: InsurancePlanOrderByWithRelationInput | InsurancePlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsurancePlans.
     */
    cursor?: InsurancePlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsurancePlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsurancePlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsurancePlans.
     */
    distinct?: InsurancePlanScalarFieldEnum | InsurancePlanScalarFieldEnum[]
  }

  /**
   * InsurancePlan findFirstOrThrow
   */
  export type InsurancePlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePlan
     */
    select?: InsurancePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePlanInclude<ExtArgs> | null
    /**
     * Filter, which InsurancePlan to fetch.
     */
    where?: InsurancePlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsurancePlans to fetch.
     */
    orderBy?: InsurancePlanOrderByWithRelationInput | InsurancePlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsurancePlans.
     */
    cursor?: InsurancePlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsurancePlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsurancePlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsurancePlans.
     */
    distinct?: InsurancePlanScalarFieldEnum | InsurancePlanScalarFieldEnum[]
  }

  /**
   * InsurancePlan findMany
   */
  export type InsurancePlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePlan
     */
    select?: InsurancePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePlanInclude<ExtArgs> | null
    /**
     * Filter, which InsurancePlans to fetch.
     */
    where?: InsurancePlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsurancePlans to fetch.
     */
    orderBy?: InsurancePlanOrderByWithRelationInput | InsurancePlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InsurancePlans.
     */
    cursor?: InsurancePlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsurancePlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsurancePlans.
     */
    skip?: number
    distinct?: InsurancePlanScalarFieldEnum | InsurancePlanScalarFieldEnum[]
  }

  /**
   * InsurancePlan create
   */
  export type InsurancePlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePlan
     */
    select?: InsurancePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePlanInclude<ExtArgs> | null
    /**
     * The data needed to create a InsurancePlan.
     */
    data: XOR<InsurancePlanCreateInput, InsurancePlanUncheckedCreateInput>
  }

  /**
   * InsurancePlan createMany
   */
  export type InsurancePlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InsurancePlans.
     */
    data: InsurancePlanCreateManyInput | InsurancePlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InsurancePlan createManyAndReturn
   */
  export type InsurancePlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePlan
     */
    select?: InsurancePlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InsurancePlans.
     */
    data: InsurancePlanCreateManyInput | InsurancePlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InsurancePlan update
   */
  export type InsurancePlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePlan
     */
    select?: InsurancePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePlanInclude<ExtArgs> | null
    /**
     * The data needed to update a InsurancePlan.
     */
    data: XOR<InsurancePlanUpdateInput, InsurancePlanUncheckedUpdateInput>
    /**
     * Choose, which InsurancePlan to update.
     */
    where: InsurancePlanWhereUniqueInput
  }

  /**
   * InsurancePlan updateMany
   */
  export type InsurancePlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InsurancePlans.
     */
    data: XOR<InsurancePlanUpdateManyMutationInput, InsurancePlanUncheckedUpdateManyInput>
    /**
     * Filter which InsurancePlans to update
     */
    where?: InsurancePlanWhereInput
  }

  /**
   * InsurancePlan upsert
   */
  export type InsurancePlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePlan
     */
    select?: InsurancePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePlanInclude<ExtArgs> | null
    /**
     * The filter to search for the InsurancePlan to update in case it exists.
     */
    where: InsurancePlanWhereUniqueInput
    /**
     * In case the InsurancePlan found by the `where` argument doesn't exist, create a new InsurancePlan with this data.
     */
    create: XOR<InsurancePlanCreateInput, InsurancePlanUncheckedCreateInput>
    /**
     * In case the InsurancePlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InsurancePlanUpdateInput, InsurancePlanUncheckedUpdateInput>
  }

  /**
   * InsurancePlan delete
   */
  export type InsurancePlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePlan
     */
    select?: InsurancePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePlanInclude<ExtArgs> | null
    /**
     * Filter which InsurancePlan to delete.
     */
    where: InsurancePlanWhereUniqueInput
  }

  /**
   * InsurancePlan deleteMany
   */
  export type InsurancePlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsurancePlans to delete
     */
    where?: InsurancePlanWhereInput
  }

  /**
   * InsurancePlan without action
   */
  export type InsurancePlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePlan
     */
    select?: InsurancePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePlanInclude<ExtArgs> | null
  }


  /**
   * Model MedicalStaff
   */

  export type AggregateMedicalStaff = {
    _count: MedicalStaffCountAggregateOutputType | null
    _min: MedicalStaffMinAggregateOutputType | null
    _max: MedicalStaffMaxAggregateOutputType | null
  }

  export type MedicalStaffMinAggregateOutputType = {
    id: string | null
    institutionId: string | null
    name: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.StaffRole | null
    license: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type MedicalStaffMaxAggregateOutputType = {
    id: string | null
    institutionId: string | null
    name: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.StaffRole | null
    license: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type MedicalStaffCountAggregateOutputType = {
    id: number
    institutionId: number
    name: number
    email: number
    passwordHash: number
    role: number
    license: number
    isActive: number
    createdAt: number
    updatedAt: number
    lastLoginAt: number
    _all: number
  }


  export type MedicalStaffMinAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    email?: true
    passwordHash?: true
    role?: true
    license?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type MedicalStaffMaxAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    email?: true
    passwordHash?: true
    role?: true
    license?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type MedicalStaffCountAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    email?: true
    passwordHash?: true
    role?: true
    license?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    _all?: true
  }

  export type MedicalStaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalStaff to aggregate.
     */
    where?: MedicalStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalStaffs to fetch.
     */
    orderBy?: MedicalStaffOrderByWithRelationInput | MedicalStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalStaffs
    **/
    _count?: true | MedicalStaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalStaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalStaffMaxAggregateInputType
  }

  export type GetMedicalStaffAggregateType<T extends MedicalStaffAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalStaff[P]>
      : GetScalarType<T[P], AggregateMedicalStaff[P]>
  }




  export type MedicalStaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalStaffWhereInput
    orderBy?: MedicalStaffOrderByWithAggregationInput | MedicalStaffOrderByWithAggregationInput[]
    by: MedicalStaffScalarFieldEnum[] | MedicalStaffScalarFieldEnum
    having?: MedicalStaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalStaffCountAggregateInputType | true
    _min?: MedicalStaffMinAggregateInputType
    _max?: MedicalStaffMaxAggregateInputType
  }

  export type MedicalStaffGroupByOutputType = {
    id: string
    institutionId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.StaffRole
    license: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    lastLoginAt: Date | null
    _count: MedicalStaffCountAggregateOutputType | null
    _min: MedicalStaffMinAggregateOutputType | null
    _max: MedicalStaffMaxAggregateOutputType | null
  }

  type GetMedicalStaffGroupByPayload<T extends MedicalStaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalStaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalStaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalStaffGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalStaffGroupByOutputType[P]>
        }
      >
    >


  export type MedicalStaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    license?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    institution?: boolean | MedicalInstitutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalStaff"]>

  export type MedicalStaffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    license?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    institution?: boolean | MedicalInstitutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalStaff"]>

  export type MedicalStaffSelectScalar = {
    id?: boolean
    institutionId?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    license?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }

  export type MedicalStaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | MedicalInstitutionDefaultArgs<ExtArgs>
  }
  export type MedicalStaffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | MedicalInstitutionDefaultArgs<ExtArgs>
  }

  export type $MedicalStaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicalStaff"
    objects: {
      institution: Prisma.$MedicalInstitutionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      institutionId: string
      name: string
      email: string
      passwordHash: string
      role: $Enums.StaffRole
      license: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      lastLoginAt: Date | null
    }, ExtArgs["result"]["medicalStaff"]>
    composites: {}
  }

  type MedicalStaffGetPayload<S extends boolean | null | undefined | MedicalStaffDefaultArgs> = $Result.GetResult<Prisma.$MedicalStaffPayload, S>

  type MedicalStaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MedicalStaffFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MedicalStaffCountAggregateInputType | true
    }

  export interface MedicalStaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalStaff'], meta: { name: 'MedicalStaff' } }
    /**
     * Find zero or one MedicalStaff that matches the filter.
     * @param {MedicalStaffFindUniqueArgs} args - Arguments to find a MedicalStaff
     * @example
     * // Get one MedicalStaff
     * const medicalStaff = await prisma.medicalStaff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicalStaffFindUniqueArgs>(args: SelectSubset<T, MedicalStaffFindUniqueArgs<ExtArgs>>): Prisma__MedicalStaffClient<$Result.GetResult<Prisma.$MedicalStaffPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MedicalStaff that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MedicalStaffFindUniqueOrThrowArgs} args - Arguments to find a MedicalStaff
     * @example
     * // Get one MedicalStaff
     * const medicalStaff = await prisma.medicalStaff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicalStaffFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicalStaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicalStaffClient<$Result.GetResult<Prisma.$MedicalStaffPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MedicalStaff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalStaffFindFirstArgs} args - Arguments to find a MedicalStaff
     * @example
     * // Get one MedicalStaff
     * const medicalStaff = await prisma.medicalStaff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicalStaffFindFirstArgs>(args?: SelectSubset<T, MedicalStaffFindFirstArgs<ExtArgs>>): Prisma__MedicalStaffClient<$Result.GetResult<Prisma.$MedicalStaffPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MedicalStaff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalStaffFindFirstOrThrowArgs} args - Arguments to find a MedicalStaff
     * @example
     * // Get one MedicalStaff
     * const medicalStaff = await prisma.medicalStaff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicalStaffFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicalStaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicalStaffClient<$Result.GetResult<Prisma.$MedicalStaffPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MedicalStaffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalStaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalStaffs
     * const medicalStaffs = await prisma.medicalStaff.findMany()
     * 
     * // Get first 10 MedicalStaffs
     * const medicalStaffs = await prisma.medicalStaff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalStaffWithIdOnly = await prisma.medicalStaff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicalStaffFindManyArgs>(args?: SelectSubset<T, MedicalStaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalStaffPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MedicalStaff.
     * @param {MedicalStaffCreateArgs} args - Arguments to create a MedicalStaff.
     * @example
     * // Create one MedicalStaff
     * const MedicalStaff = await prisma.medicalStaff.create({
     *   data: {
     *     // ... data to create a MedicalStaff
     *   }
     * })
     * 
     */
    create<T extends MedicalStaffCreateArgs>(args: SelectSubset<T, MedicalStaffCreateArgs<ExtArgs>>): Prisma__MedicalStaffClient<$Result.GetResult<Prisma.$MedicalStaffPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MedicalStaffs.
     * @param {MedicalStaffCreateManyArgs} args - Arguments to create many MedicalStaffs.
     * @example
     * // Create many MedicalStaffs
     * const medicalStaff = await prisma.medicalStaff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicalStaffCreateManyArgs>(args?: SelectSubset<T, MedicalStaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicalStaffs and returns the data saved in the database.
     * @param {MedicalStaffCreateManyAndReturnArgs} args - Arguments to create many MedicalStaffs.
     * @example
     * // Create many MedicalStaffs
     * const medicalStaff = await prisma.medicalStaff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicalStaffs and only return the `id`
     * const medicalStaffWithIdOnly = await prisma.medicalStaff.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicalStaffCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicalStaffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalStaffPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MedicalStaff.
     * @param {MedicalStaffDeleteArgs} args - Arguments to delete one MedicalStaff.
     * @example
     * // Delete one MedicalStaff
     * const MedicalStaff = await prisma.medicalStaff.delete({
     *   where: {
     *     // ... filter to delete one MedicalStaff
     *   }
     * })
     * 
     */
    delete<T extends MedicalStaffDeleteArgs>(args: SelectSubset<T, MedicalStaffDeleteArgs<ExtArgs>>): Prisma__MedicalStaffClient<$Result.GetResult<Prisma.$MedicalStaffPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MedicalStaff.
     * @param {MedicalStaffUpdateArgs} args - Arguments to update one MedicalStaff.
     * @example
     * // Update one MedicalStaff
     * const medicalStaff = await prisma.medicalStaff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicalStaffUpdateArgs>(args: SelectSubset<T, MedicalStaffUpdateArgs<ExtArgs>>): Prisma__MedicalStaffClient<$Result.GetResult<Prisma.$MedicalStaffPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MedicalStaffs.
     * @param {MedicalStaffDeleteManyArgs} args - Arguments to filter MedicalStaffs to delete.
     * @example
     * // Delete a few MedicalStaffs
     * const { count } = await prisma.medicalStaff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicalStaffDeleteManyArgs>(args?: SelectSubset<T, MedicalStaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalStaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalStaffs
     * const medicalStaff = await prisma.medicalStaff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicalStaffUpdateManyArgs>(args: SelectSubset<T, MedicalStaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MedicalStaff.
     * @param {MedicalStaffUpsertArgs} args - Arguments to update or create a MedicalStaff.
     * @example
     * // Update or create a MedicalStaff
     * const medicalStaff = await prisma.medicalStaff.upsert({
     *   create: {
     *     // ... data to create a MedicalStaff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalStaff we want to update
     *   }
     * })
     */
    upsert<T extends MedicalStaffUpsertArgs>(args: SelectSubset<T, MedicalStaffUpsertArgs<ExtArgs>>): Prisma__MedicalStaffClient<$Result.GetResult<Prisma.$MedicalStaffPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MedicalStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalStaffCountArgs} args - Arguments to filter MedicalStaffs to count.
     * @example
     * // Count the number of MedicalStaffs
     * const count = await prisma.medicalStaff.count({
     *   where: {
     *     // ... the filter for the MedicalStaffs we want to count
     *   }
     * })
    **/
    count<T extends MedicalStaffCountArgs>(
      args?: Subset<T, MedicalStaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalStaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalStaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalStaffAggregateArgs>(args: Subset<T, MedicalStaffAggregateArgs>): Prisma.PrismaPromise<GetMedicalStaffAggregateType<T>>

    /**
     * Group by MedicalStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalStaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalStaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalStaffGroupByArgs['orderBy'] }
        : { orderBy?: MedicalStaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalStaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicalStaff model
   */
  readonly fields: MedicalStaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalStaff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicalStaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends MedicalInstitutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicalInstitutionDefaultArgs<ExtArgs>>): Prisma__MedicalInstitutionClient<$Result.GetResult<Prisma.$MedicalInstitutionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicalStaff model
   */ 
  interface MedicalStaffFieldRefs {
    readonly id: FieldRef<"MedicalStaff", 'String'>
    readonly institutionId: FieldRef<"MedicalStaff", 'String'>
    readonly name: FieldRef<"MedicalStaff", 'String'>
    readonly email: FieldRef<"MedicalStaff", 'String'>
    readonly passwordHash: FieldRef<"MedicalStaff", 'String'>
    readonly role: FieldRef<"MedicalStaff", 'StaffRole'>
    readonly license: FieldRef<"MedicalStaff", 'String'>
    readonly isActive: FieldRef<"MedicalStaff", 'Boolean'>
    readonly createdAt: FieldRef<"MedicalStaff", 'DateTime'>
    readonly updatedAt: FieldRef<"MedicalStaff", 'DateTime'>
    readonly lastLoginAt: FieldRef<"MedicalStaff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicalStaff findUnique
   */
  export type MedicalStaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStaff
     */
    select?: MedicalStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStaffInclude<ExtArgs> | null
    /**
     * Filter, which MedicalStaff to fetch.
     */
    where: MedicalStaffWhereUniqueInput
  }

  /**
   * MedicalStaff findUniqueOrThrow
   */
  export type MedicalStaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStaff
     */
    select?: MedicalStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStaffInclude<ExtArgs> | null
    /**
     * Filter, which MedicalStaff to fetch.
     */
    where: MedicalStaffWhereUniqueInput
  }

  /**
   * MedicalStaff findFirst
   */
  export type MedicalStaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStaff
     */
    select?: MedicalStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStaffInclude<ExtArgs> | null
    /**
     * Filter, which MedicalStaff to fetch.
     */
    where?: MedicalStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalStaffs to fetch.
     */
    orderBy?: MedicalStaffOrderByWithRelationInput | MedicalStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalStaffs.
     */
    cursor?: MedicalStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalStaffs.
     */
    distinct?: MedicalStaffScalarFieldEnum | MedicalStaffScalarFieldEnum[]
  }

  /**
   * MedicalStaff findFirstOrThrow
   */
  export type MedicalStaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStaff
     */
    select?: MedicalStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStaffInclude<ExtArgs> | null
    /**
     * Filter, which MedicalStaff to fetch.
     */
    where?: MedicalStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalStaffs to fetch.
     */
    orderBy?: MedicalStaffOrderByWithRelationInput | MedicalStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalStaffs.
     */
    cursor?: MedicalStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalStaffs.
     */
    distinct?: MedicalStaffScalarFieldEnum | MedicalStaffScalarFieldEnum[]
  }

  /**
   * MedicalStaff findMany
   */
  export type MedicalStaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStaff
     */
    select?: MedicalStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStaffInclude<ExtArgs> | null
    /**
     * Filter, which MedicalStaffs to fetch.
     */
    where?: MedicalStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalStaffs to fetch.
     */
    orderBy?: MedicalStaffOrderByWithRelationInput | MedicalStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalStaffs.
     */
    cursor?: MedicalStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalStaffs.
     */
    skip?: number
    distinct?: MedicalStaffScalarFieldEnum | MedicalStaffScalarFieldEnum[]
  }

  /**
   * MedicalStaff create
   */
  export type MedicalStaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStaff
     */
    select?: MedicalStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStaffInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicalStaff.
     */
    data: XOR<MedicalStaffCreateInput, MedicalStaffUncheckedCreateInput>
  }

  /**
   * MedicalStaff createMany
   */
  export type MedicalStaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalStaffs.
     */
    data: MedicalStaffCreateManyInput | MedicalStaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicalStaff createManyAndReturn
   */
  export type MedicalStaffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStaff
     */
    select?: MedicalStaffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MedicalStaffs.
     */
    data: MedicalStaffCreateManyInput | MedicalStaffCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStaffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicalStaff update
   */
  export type MedicalStaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStaff
     */
    select?: MedicalStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStaffInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicalStaff.
     */
    data: XOR<MedicalStaffUpdateInput, MedicalStaffUncheckedUpdateInput>
    /**
     * Choose, which MedicalStaff to update.
     */
    where: MedicalStaffWhereUniqueInput
  }

  /**
   * MedicalStaff updateMany
   */
  export type MedicalStaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalStaffs.
     */
    data: XOR<MedicalStaffUpdateManyMutationInput, MedicalStaffUncheckedUpdateManyInput>
    /**
     * Filter which MedicalStaffs to update
     */
    where?: MedicalStaffWhereInput
  }

  /**
   * MedicalStaff upsert
   */
  export type MedicalStaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStaff
     */
    select?: MedicalStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStaffInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicalStaff to update in case it exists.
     */
    where: MedicalStaffWhereUniqueInput
    /**
     * In case the MedicalStaff found by the `where` argument doesn't exist, create a new MedicalStaff with this data.
     */
    create: XOR<MedicalStaffCreateInput, MedicalStaffUncheckedCreateInput>
    /**
     * In case the MedicalStaff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalStaffUpdateInput, MedicalStaffUncheckedUpdateInput>
  }

  /**
   * MedicalStaff delete
   */
  export type MedicalStaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStaff
     */
    select?: MedicalStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStaffInclude<ExtArgs> | null
    /**
     * Filter which MedicalStaff to delete.
     */
    where: MedicalStaffWhereUniqueInput
  }

  /**
   * MedicalStaff deleteMany
   */
  export type MedicalStaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalStaffs to delete
     */
    where?: MedicalStaffWhereInput
  }

  /**
   * MedicalStaff without action
   */
  export type MedicalStaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStaff
     */
    select?: MedicalStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStaffInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    actorType: string | null
    actorId: string | null
    actorName: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    actorType: string | null
    actorId: string | null
    actorName: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    actorType: number
    actorId: number
    actorName: number
    action: number
    resource: number
    resourceId: number
    details: number
    oldValue: number
    newValue: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    actorType?: true
    actorId?: true
    actorName?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    actorType?: true
    actorId?: true
    actorName?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    actorType?: true
    actorId?: true
    actorName?: true
    action?: true
    resource?: true
    resourceId?: true
    details?: true
    oldValue?: true
    newValue?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    actorType: string
    actorId: string | null
    actorName: string | null
    action: string
    resource: string
    resourceId: string | null
    details: JsonValue | null
    oldValue: JsonValue | null
    newValue: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    actorType?: boolean
    actorId?: boolean
    actorName?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    oldValue?: boolean
    newValue?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    actorType?: boolean
    actorId?: boolean
    actorName?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    oldValue?: boolean
    newValue?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    actorType?: boolean
    actorId?: boolean
    actorName?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    oldValue?: boolean
    newValue?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      actorType: string
      actorId: string | null
      actorName: string | null
      action: string
      resource: string
      resourceId: string | null
      details: Prisma.JsonValue | null
      oldValue: Prisma.JsonValue | null
      newValue: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly actorType: FieldRef<"AuditLog", 'String'>
    readonly actorId: FieldRef<"AuditLog", 'String'>
    readonly actorName: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resource: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly oldValue: FieldRef<"AuditLog", 'Json'>
    readonly newValue: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model StateLegalTemplate
   */

  export type AggregateStateLegalTemplate = {
    _count: StateLegalTemplateCountAggregateOutputType | null
    _avg: StateLegalTemplateAvgAggregateOutputType | null
    _sum: StateLegalTemplateSumAggregateOutputType | null
    _min: StateLegalTemplateMinAggregateOutputType | null
    _max: StateLegalTemplateMaxAggregateOutputType | null
  }

  export type StateLegalTemplateAvgAggregateOutputType = {
    requiresWitnesses: number | null
  }

  export type StateLegalTemplateSumAggregateOutputType = {
    requiresWitnesses: number | null
  }

  export type StateLegalTemplateMinAggregateOutputType = {
    id: string | null
    stateCode: string | null
    stateName: string | null
    lawName: string | null
    lawDate: Date | null
    lawSummary: string | null
    templateHtml: string | null
    requiresNotary: boolean | null
    requiresWitnesses: number | null
    requiresMedicalCert: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StateLegalTemplateMaxAggregateOutputType = {
    id: string | null
    stateCode: string | null
    stateName: string | null
    lawName: string | null
    lawDate: Date | null
    lawSummary: string | null
    templateHtml: string | null
    requiresNotary: boolean | null
    requiresWitnesses: number | null
    requiresMedicalCert: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StateLegalTemplateCountAggregateOutputType = {
    id: number
    stateCode: number
    stateName: number
    lawName: number
    lawDate: number
    lawSummary: number
    templateHtml: number
    templateFields: number
    requiresNotary: number
    requiresWitnesses: number
    requiresMedicalCert: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StateLegalTemplateAvgAggregateInputType = {
    requiresWitnesses?: true
  }

  export type StateLegalTemplateSumAggregateInputType = {
    requiresWitnesses?: true
  }

  export type StateLegalTemplateMinAggregateInputType = {
    id?: true
    stateCode?: true
    stateName?: true
    lawName?: true
    lawDate?: true
    lawSummary?: true
    templateHtml?: true
    requiresNotary?: true
    requiresWitnesses?: true
    requiresMedicalCert?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StateLegalTemplateMaxAggregateInputType = {
    id?: true
    stateCode?: true
    stateName?: true
    lawName?: true
    lawDate?: true
    lawSummary?: true
    templateHtml?: true
    requiresNotary?: true
    requiresWitnesses?: true
    requiresMedicalCert?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StateLegalTemplateCountAggregateInputType = {
    id?: true
    stateCode?: true
    stateName?: true
    lawName?: true
    lawDate?: true
    lawSummary?: true
    templateHtml?: true
    templateFields?: true
    requiresNotary?: true
    requiresWitnesses?: true
    requiresMedicalCert?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StateLegalTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StateLegalTemplate to aggregate.
     */
    where?: StateLegalTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StateLegalTemplates to fetch.
     */
    orderBy?: StateLegalTemplateOrderByWithRelationInput | StateLegalTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StateLegalTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StateLegalTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StateLegalTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StateLegalTemplates
    **/
    _count?: true | StateLegalTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StateLegalTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StateLegalTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StateLegalTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StateLegalTemplateMaxAggregateInputType
  }

  export type GetStateLegalTemplateAggregateType<T extends StateLegalTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateStateLegalTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStateLegalTemplate[P]>
      : GetScalarType<T[P], AggregateStateLegalTemplate[P]>
  }




  export type StateLegalTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StateLegalTemplateWhereInput
    orderBy?: StateLegalTemplateOrderByWithAggregationInput | StateLegalTemplateOrderByWithAggregationInput[]
    by: StateLegalTemplateScalarFieldEnum[] | StateLegalTemplateScalarFieldEnum
    having?: StateLegalTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StateLegalTemplateCountAggregateInputType | true
    _avg?: StateLegalTemplateAvgAggregateInputType
    _sum?: StateLegalTemplateSumAggregateInputType
    _min?: StateLegalTemplateMinAggregateInputType
    _max?: StateLegalTemplateMaxAggregateInputType
  }

  export type StateLegalTemplateGroupByOutputType = {
    id: string
    stateCode: string
    stateName: string
    lawName: string
    lawDate: Date | null
    lawSummary: string | null
    templateHtml: string | null
    templateFields: JsonValue | null
    requiresNotary: boolean
    requiresWitnesses: number
    requiresMedicalCert: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: StateLegalTemplateCountAggregateOutputType | null
    _avg: StateLegalTemplateAvgAggregateOutputType | null
    _sum: StateLegalTemplateSumAggregateOutputType | null
    _min: StateLegalTemplateMinAggregateOutputType | null
    _max: StateLegalTemplateMaxAggregateOutputType | null
  }

  type GetStateLegalTemplateGroupByPayload<T extends StateLegalTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StateLegalTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StateLegalTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StateLegalTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], StateLegalTemplateGroupByOutputType[P]>
        }
      >
    >


  export type StateLegalTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stateCode?: boolean
    stateName?: boolean
    lawName?: boolean
    lawDate?: boolean
    lawSummary?: boolean
    templateHtml?: boolean
    templateFields?: boolean
    requiresNotary?: boolean
    requiresWitnesses?: boolean
    requiresMedicalCert?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["stateLegalTemplate"]>

  export type StateLegalTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stateCode?: boolean
    stateName?: boolean
    lawName?: boolean
    lawDate?: boolean
    lawSummary?: boolean
    templateHtml?: boolean
    templateFields?: boolean
    requiresNotary?: boolean
    requiresWitnesses?: boolean
    requiresMedicalCert?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["stateLegalTemplate"]>

  export type StateLegalTemplateSelectScalar = {
    id?: boolean
    stateCode?: boolean
    stateName?: boolean
    lawName?: boolean
    lawDate?: boolean
    lawSummary?: boolean
    templateHtml?: boolean
    templateFields?: boolean
    requiresNotary?: boolean
    requiresWitnesses?: boolean
    requiresMedicalCert?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $StateLegalTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StateLegalTemplate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stateCode: string
      stateName: string
      lawName: string
      lawDate: Date | null
      lawSummary: string | null
      templateHtml: string | null
      templateFields: Prisma.JsonValue | null
      requiresNotary: boolean
      requiresWitnesses: number
      requiresMedicalCert: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stateLegalTemplate"]>
    composites: {}
  }

  type StateLegalTemplateGetPayload<S extends boolean | null | undefined | StateLegalTemplateDefaultArgs> = $Result.GetResult<Prisma.$StateLegalTemplatePayload, S>

  type StateLegalTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StateLegalTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StateLegalTemplateCountAggregateInputType | true
    }

  export interface StateLegalTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StateLegalTemplate'], meta: { name: 'StateLegalTemplate' } }
    /**
     * Find zero or one StateLegalTemplate that matches the filter.
     * @param {StateLegalTemplateFindUniqueArgs} args - Arguments to find a StateLegalTemplate
     * @example
     * // Get one StateLegalTemplate
     * const stateLegalTemplate = await prisma.stateLegalTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StateLegalTemplateFindUniqueArgs>(args: SelectSubset<T, StateLegalTemplateFindUniqueArgs<ExtArgs>>): Prisma__StateLegalTemplateClient<$Result.GetResult<Prisma.$StateLegalTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StateLegalTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StateLegalTemplateFindUniqueOrThrowArgs} args - Arguments to find a StateLegalTemplate
     * @example
     * // Get one StateLegalTemplate
     * const stateLegalTemplate = await prisma.stateLegalTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StateLegalTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, StateLegalTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StateLegalTemplateClient<$Result.GetResult<Prisma.$StateLegalTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StateLegalTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateLegalTemplateFindFirstArgs} args - Arguments to find a StateLegalTemplate
     * @example
     * // Get one StateLegalTemplate
     * const stateLegalTemplate = await prisma.stateLegalTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StateLegalTemplateFindFirstArgs>(args?: SelectSubset<T, StateLegalTemplateFindFirstArgs<ExtArgs>>): Prisma__StateLegalTemplateClient<$Result.GetResult<Prisma.$StateLegalTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StateLegalTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateLegalTemplateFindFirstOrThrowArgs} args - Arguments to find a StateLegalTemplate
     * @example
     * // Get one StateLegalTemplate
     * const stateLegalTemplate = await prisma.stateLegalTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StateLegalTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, StateLegalTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__StateLegalTemplateClient<$Result.GetResult<Prisma.$StateLegalTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StateLegalTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateLegalTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StateLegalTemplates
     * const stateLegalTemplates = await prisma.stateLegalTemplate.findMany()
     * 
     * // Get first 10 StateLegalTemplates
     * const stateLegalTemplates = await prisma.stateLegalTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stateLegalTemplateWithIdOnly = await prisma.stateLegalTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StateLegalTemplateFindManyArgs>(args?: SelectSubset<T, StateLegalTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StateLegalTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StateLegalTemplate.
     * @param {StateLegalTemplateCreateArgs} args - Arguments to create a StateLegalTemplate.
     * @example
     * // Create one StateLegalTemplate
     * const StateLegalTemplate = await prisma.stateLegalTemplate.create({
     *   data: {
     *     // ... data to create a StateLegalTemplate
     *   }
     * })
     * 
     */
    create<T extends StateLegalTemplateCreateArgs>(args: SelectSubset<T, StateLegalTemplateCreateArgs<ExtArgs>>): Prisma__StateLegalTemplateClient<$Result.GetResult<Prisma.$StateLegalTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StateLegalTemplates.
     * @param {StateLegalTemplateCreateManyArgs} args - Arguments to create many StateLegalTemplates.
     * @example
     * // Create many StateLegalTemplates
     * const stateLegalTemplate = await prisma.stateLegalTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StateLegalTemplateCreateManyArgs>(args?: SelectSubset<T, StateLegalTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StateLegalTemplates and returns the data saved in the database.
     * @param {StateLegalTemplateCreateManyAndReturnArgs} args - Arguments to create many StateLegalTemplates.
     * @example
     * // Create many StateLegalTemplates
     * const stateLegalTemplate = await prisma.stateLegalTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StateLegalTemplates and only return the `id`
     * const stateLegalTemplateWithIdOnly = await prisma.stateLegalTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StateLegalTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, StateLegalTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StateLegalTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StateLegalTemplate.
     * @param {StateLegalTemplateDeleteArgs} args - Arguments to delete one StateLegalTemplate.
     * @example
     * // Delete one StateLegalTemplate
     * const StateLegalTemplate = await prisma.stateLegalTemplate.delete({
     *   where: {
     *     // ... filter to delete one StateLegalTemplate
     *   }
     * })
     * 
     */
    delete<T extends StateLegalTemplateDeleteArgs>(args: SelectSubset<T, StateLegalTemplateDeleteArgs<ExtArgs>>): Prisma__StateLegalTemplateClient<$Result.GetResult<Prisma.$StateLegalTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StateLegalTemplate.
     * @param {StateLegalTemplateUpdateArgs} args - Arguments to update one StateLegalTemplate.
     * @example
     * // Update one StateLegalTemplate
     * const stateLegalTemplate = await prisma.stateLegalTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StateLegalTemplateUpdateArgs>(args: SelectSubset<T, StateLegalTemplateUpdateArgs<ExtArgs>>): Prisma__StateLegalTemplateClient<$Result.GetResult<Prisma.$StateLegalTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StateLegalTemplates.
     * @param {StateLegalTemplateDeleteManyArgs} args - Arguments to filter StateLegalTemplates to delete.
     * @example
     * // Delete a few StateLegalTemplates
     * const { count } = await prisma.stateLegalTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StateLegalTemplateDeleteManyArgs>(args?: SelectSubset<T, StateLegalTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StateLegalTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateLegalTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StateLegalTemplates
     * const stateLegalTemplate = await prisma.stateLegalTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StateLegalTemplateUpdateManyArgs>(args: SelectSubset<T, StateLegalTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StateLegalTemplate.
     * @param {StateLegalTemplateUpsertArgs} args - Arguments to update or create a StateLegalTemplate.
     * @example
     * // Update or create a StateLegalTemplate
     * const stateLegalTemplate = await prisma.stateLegalTemplate.upsert({
     *   create: {
     *     // ... data to create a StateLegalTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StateLegalTemplate we want to update
     *   }
     * })
     */
    upsert<T extends StateLegalTemplateUpsertArgs>(args: SelectSubset<T, StateLegalTemplateUpsertArgs<ExtArgs>>): Prisma__StateLegalTemplateClient<$Result.GetResult<Prisma.$StateLegalTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StateLegalTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateLegalTemplateCountArgs} args - Arguments to filter StateLegalTemplates to count.
     * @example
     * // Count the number of StateLegalTemplates
     * const count = await prisma.stateLegalTemplate.count({
     *   where: {
     *     // ... the filter for the StateLegalTemplates we want to count
     *   }
     * })
    **/
    count<T extends StateLegalTemplateCountArgs>(
      args?: Subset<T, StateLegalTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StateLegalTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StateLegalTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateLegalTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StateLegalTemplateAggregateArgs>(args: Subset<T, StateLegalTemplateAggregateArgs>): Prisma.PrismaPromise<GetStateLegalTemplateAggregateType<T>>

    /**
     * Group by StateLegalTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateLegalTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StateLegalTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StateLegalTemplateGroupByArgs['orderBy'] }
        : { orderBy?: StateLegalTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StateLegalTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStateLegalTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StateLegalTemplate model
   */
  readonly fields: StateLegalTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StateLegalTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StateLegalTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StateLegalTemplate model
   */ 
  interface StateLegalTemplateFieldRefs {
    readonly id: FieldRef<"StateLegalTemplate", 'String'>
    readonly stateCode: FieldRef<"StateLegalTemplate", 'String'>
    readonly stateName: FieldRef<"StateLegalTemplate", 'String'>
    readonly lawName: FieldRef<"StateLegalTemplate", 'String'>
    readonly lawDate: FieldRef<"StateLegalTemplate", 'DateTime'>
    readonly lawSummary: FieldRef<"StateLegalTemplate", 'String'>
    readonly templateHtml: FieldRef<"StateLegalTemplate", 'String'>
    readonly templateFields: FieldRef<"StateLegalTemplate", 'Json'>
    readonly requiresNotary: FieldRef<"StateLegalTemplate", 'Boolean'>
    readonly requiresWitnesses: FieldRef<"StateLegalTemplate", 'Int'>
    readonly requiresMedicalCert: FieldRef<"StateLegalTemplate", 'Boolean'>
    readonly isActive: FieldRef<"StateLegalTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"StateLegalTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"StateLegalTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StateLegalTemplate findUnique
   */
  export type StateLegalTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateLegalTemplate
     */
    select?: StateLegalTemplateSelect<ExtArgs> | null
    /**
     * Filter, which StateLegalTemplate to fetch.
     */
    where: StateLegalTemplateWhereUniqueInput
  }

  /**
   * StateLegalTemplate findUniqueOrThrow
   */
  export type StateLegalTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateLegalTemplate
     */
    select?: StateLegalTemplateSelect<ExtArgs> | null
    /**
     * Filter, which StateLegalTemplate to fetch.
     */
    where: StateLegalTemplateWhereUniqueInput
  }

  /**
   * StateLegalTemplate findFirst
   */
  export type StateLegalTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateLegalTemplate
     */
    select?: StateLegalTemplateSelect<ExtArgs> | null
    /**
     * Filter, which StateLegalTemplate to fetch.
     */
    where?: StateLegalTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StateLegalTemplates to fetch.
     */
    orderBy?: StateLegalTemplateOrderByWithRelationInput | StateLegalTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StateLegalTemplates.
     */
    cursor?: StateLegalTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StateLegalTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StateLegalTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StateLegalTemplates.
     */
    distinct?: StateLegalTemplateScalarFieldEnum | StateLegalTemplateScalarFieldEnum[]
  }

  /**
   * StateLegalTemplate findFirstOrThrow
   */
  export type StateLegalTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateLegalTemplate
     */
    select?: StateLegalTemplateSelect<ExtArgs> | null
    /**
     * Filter, which StateLegalTemplate to fetch.
     */
    where?: StateLegalTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StateLegalTemplates to fetch.
     */
    orderBy?: StateLegalTemplateOrderByWithRelationInput | StateLegalTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StateLegalTemplates.
     */
    cursor?: StateLegalTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StateLegalTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StateLegalTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StateLegalTemplates.
     */
    distinct?: StateLegalTemplateScalarFieldEnum | StateLegalTemplateScalarFieldEnum[]
  }

  /**
   * StateLegalTemplate findMany
   */
  export type StateLegalTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateLegalTemplate
     */
    select?: StateLegalTemplateSelect<ExtArgs> | null
    /**
     * Filter, which StateLegalTemplates to fetch.
     */
    where?: StateLegalTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StateLegalTemplates to fetch.
     */
    orderBy?: StateLegalTemplateOrderByWithRelationInput | StateLegalTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StateLegalTemplates.
     */
    cursor?: StateLegalTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StateLegalTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StateLegalTemplates.
     */
    skip?: number
    distinct?: StateLegalTemplateScalarFieldEnum | StateLegalTemplateScalarFieldEnum[]
  }

  /**
   * StateLegalTemplate create
   */
  export type StateLegalTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateLegalTemplate
     */
    select?: StateLegalTemplateSelect<ExtArgs> | null
    /**
     * The data needed to create a StateLegalTemplate.
     */
    data: XOR<StateLegalTemplateCreateInput, StateLegalTemplateUncheckedCreateInput>
  }

  /**
   * StateLegalTemplate createMany
   */
  export type StateLegalTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StateLegalTemplates.
     */
    data: StateLegalTemplateCreateManyInput | StateLegalTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StateLegalTemplate createManyAndReturn
   */
  export type StateLegalTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateLegalTemplate
     */
    select?: StateLegalTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StateLegalTemplates.
     */
    data: StateLegalTemplateCreateManyInput | StateLegalTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StateLegalTemplate update
   */
  export type StateLegalTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateLegalTemplate
     */
    select?: StateLegalTemplateSelect<ExtArgs> | null
    /**
     * The data needed to update a StateLegalTemplate.
     */
    data: XOR<StateLegalTemplateUpdateInput, StateLegalTemplateUncheckedUpdateInput>
    /**
     * Choose, which StateLegalTemplate to update.
     */
    where: StateLegalTemplateWhereUniqueInput
  }

  /**
   * StateLegalTemplate updateMany
   */
  export type StateLegalTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StateLegalTemplates.
     */
    data: XOR<StateLegalTemplateUpdateManyMutationInput, StateLegalTemplateUncheckedUpdateManyInput>
    /**
     * Filter which StateLegalTemplates to update
     */
    where?: StateLegalTemplateWhereInput
  }

  /**
   * StateLegalTemplate upsert
   */
  export type StateLegalTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateLegalTemplate
     */
    select?: StateLegalTemplateSelect<ExtArgs> | null
    /**
     * The filter to search for the StateLegalTemplate to update in case it exists.
     */
    where: StateLegalTemplateWhereUniqueInput
    /**
     * In case the StateLegalTemplate found by the `where` argument doesn't exist, create a new StateLegalTemplate with this data.
     */
    create: XOR<StateLegalTemplateCreateInput, StateLegalTemplateUncheckedCreateInput>
    /**
     * In case the StateLegalTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StateLegalTemplateUpdateInput, StateLegalTemplateUncheckedUpdateInput>
  }

  /**
   * StateLegalTemplate delete
   */
  export type StateLegalTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateLegalTemplate
     */
    select?: StateLegalTemplateSelect<ExtArgs> | null
    /**
     * Filter which StateLegalTemplate to delete.
     */
    where: StateLegalTemplateWhereUniqueInput
  }

  /**
   * StateLegalTemplate deleteMany
   */
  export type StateLegalTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StateLegalTemplates to delete
     */
    where?: StateLegalTemplateWhereInput
  }

  /**
   * StateLegalTemplate without action
   */
  export type StateLegalTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateLegalTemplate
     */
    select?: StateLegalTemplateSelect<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    email: string | null
    phone: string | null
    type: $Enums.NotificationType | null
    channel: $Enums.NotificationChannel | null
    subject: string | null
    body: string | null
    status: $Enums.NotificationStatus | null
    sentAt: Date | null
    deliveredAt: Date | null
    failedAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    email: string | null
    phone: string | null
    type: $Enums.NotificationType | null
    channel: $Enums.NotificationChannel | null
    subject: string | null
    body: string | null
    status: $Enums.NotificationStatus | null
    sentAt: Date | null
    deliveredAt: Date | null
    failedAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    email: number
    phone: number
    type: number
    channel: number
    subject: number
    body: number
    status: number
    sentAt: number
    deliveredAt: number
    failedAt: number
    errorMessage: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    phone?: true
    type?: true
    channel?: true
    subject?: true
    body?: true
    status?: true
    sentAt?: true
    deliveredAt?: true
    failedAt?: true
    errorMessage?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    phone?: true
    type?: true
    channel?: true
    subject?: true
    body?: true
    status?: true
    sentAt?: true
    deliveredAt?: true
    failedAt?: true
    errorMessage?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    phone?: true
    type?: true
    channel?: true
    subject?: true
    body?: true
    status?: true
    sentAt?: true
    deliveredAt?: true
    failedAt?: true
    errorMessage?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string | null
    email: string | null
    phone: string | null
    type: $Enums.NotificationType
    channel: $Enums.NotificationChannel
    subject: string | null
    body: string
    status: $Enums.NotificationStatus
    sentAt: Date | null
    deliveredAt: Date | null
    failedAt: Date | null
    errorMessage: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    phone?: boolean
    type?: boolean
    channel?: boolean
    subject?: boolean
    body?: boolean
    status?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    failedAt?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    phone?: boolean
    type?: boolean
    channel?: boolean
    subject?: boolean
    body?: boolean
    status?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    failedAt?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    email?: boolean
    phone?: boolean
    type?: boolean
    channel?: boolean
    subject?: boolean
    body?: boolean
    status?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    failedAt?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
  }


  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      email: string | null
      phone: string | null
      type: $Enums.NotificationType
      channel: $Enums.NotificationChannel
      subject: string | null
      body: string
      status: $Enums.NotificationStatus
      sentAt: Date | null
      deliveredAt: Date | null
      failedAt: Date | null
      errorMessage: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly email: FieldRef<"Notification", 'String'>
    readonly phone: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly channel: FieldRef<"Notification", 'NotificationChannel'>
    readonly subject: FieldRef<"Notification", 'String'>
    readonly body: FieldRef<"Notification", 'String'>
    readonly status: FieldRef<"Notification", 'NotificationStatus'>
    readonly sentAt: FieldRef<"Notification", 'DateTime'>
    readonly deliveredAt: FieldRef<"Notification", 'DateTime'>
    readonly failedAt: FieldRef<"Notification", 'DateTime'>
    readonly errorMessage: FieldRef<"Notification", 'String'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
  }


  /**
   * Model PanicAlert
   */

  export type AggregatePanicAlert = {
    _count: PanicAlertCountAggregateOutputType | null
    _avg: PanicAlertAvgAggregateOutputType | null
    _sum: PanicAlertSumAggregateOutputType | null
    _min: PanicAlertMinAggregateOutputType | null
    _max: PanicAlertMaxAggregateOutputType | null
  }

  export type PanicAlertAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    accuracy: number | null
  }

  export type PanicAlertSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    accuracy: number | null
  }

  export type PanicAlertMinAggregateOutputType = {
    id: string | null
    userId: string | null
    latitude: number | null
    longitude: number | null
    accuracy: number | null
    locationName: string | null
    status: $Enums.PanicStatus | null
    message: string | null
    cancelledAt: Date | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PanicAlertMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    latitude: number | null
    longitude: number | null
    accuracy: number | null
    locationName: string | null
    status: $Enums.PanicStatus | null
    message: string | null
    cancelledAt: Date | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PanicAlertCountAggregateOutputType = {
    id: number
    userId: number
    latitude: number
    longitude: number
    accuracy: number
    locationName: number
    status: number
    message: number
    cancelledAt: number
    resolvedAt: number
    nearbyHospitals: number
    notificationsSent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PanicAlertAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    accuracy?: true
  }

  export type PanicAlertSumAggregateInputType = {
    latitude?: true
    longitude?: true
    accuracy?: true
  }

  export type PanicAlertMinAggregateInputType = {
    id?: true
    userId?: true
    latitude?: true
    longitude?: true
    accuracy?: true
    locationName?: true
    status?: true
    message?: true
    cancelledAt?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PanicAlertMaxAggregateInputType = {
    id?: true
    userId?: true
    latitude?: true
    longitude?: true
    accuracy?: true
    locationName?: true
    status?: true
    message?: true
    cancelledAt?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PanicAlertCountAggregateInputType = {
    id?: true
    userId?: true
    latitude?: true
    longitude?: true
    accuracy?: true
    locationName?: true
    status?: true
    message?: true
    cancelledAt?: true
    resolvedAt?: true
    nearbyHospitals?: true
    notificationsSent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PanicAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PanicAlert to aggregate.
     */
    where?: PanicAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PanicAlerts to fetch.
     */
    orderBy?: PanicAlertOrderByWithRelationInput | PanicAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PanicAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PanicAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PanicAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PanicAlerts
    **/
    _count?: true | PanicAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PanicAlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PanicAlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PanicAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PanicAlertMaxAggregateInputType
  }

  export type GetPanicAlertAggregateType<T extends PanicAlertAggregateArgs> = {
        [P in keyof T & keyof AggregatePanicAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePanicAlert[P]>
      : GetScalarType<T[P], AggregatePanicAlert[P]>
  }




  export type PanicAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PanicAlertWhereInput
    orderBy?: PanicAlertOrderByWithAggregationInput | PanicAlertOrderByWithAggregationInput[]
    by: PanicAlertScalarFieldEnum[] | PanicAlertScalarFieldEnum
    having?: PanicAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PanicAlertCountAggregateInputType | true
    _avg?: PanicAlertAvgAggregateInputType
    _sum?: PanicAlertSumAggregateInputType
    _min?: PanicAlertMinAggregateInputType
    _max?: PanicAlertMaxAggregateInputType
  }

  export type PanicAlertGroupByOutputType = {
    id: string
    userId: string
    latitude: number
    longitude: number
    accuracy: number | null
    locationName: string | null
    status: $Enums.PanicStatus
    message: string | null
    cancelledAt: Date | null
    resolvedAt: Date | null
    nearbyHospitals: JsonValue | null
    notificationsSent: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PanicAlertCountAggregateOutputType | null
    _avg: PanicAlertAvgAggregateOutputType | null
    _sum: PanicAlertSumAggregateOutputType | null
    _min: PanicAlertMinAggregateOutputType | null
    _max: PanicAlertMaxAggregateOutputType | null
  }

  type GetPanicAlertGroupByPayload<T extends PanicAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PanicAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PanicAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PanicAlertGroupByOutputType[P]>
            : GetScalarType<T[P], PanicAlertGroupByOutputType[P]>
        }
      >
    >


  export type PanicAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    latitude?: boolean
    longitude?: boolean
    accuracy?: boolean
    locationName?: boolean
    status?: boolean
    message?: boolean
    cancelledAt?: boolean
    resolvedAt?: boolean
    nearbyHospitals?: boolean
    notificationsSent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["panicAlert"]>

  export type PanicAlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    latitude?: boolean
    longitude?: boolean
    accuracy?: boolean
    locationName?: boolean
    status?: boolean
    message?: boolean
    cancelledAt?: boolean
    resolvedAt?: boolean
    nearbyHospitals?: boolean
    notificationsSent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["panicAlert"]>

  export type PanicAlertSelectScalar = {
    id?: boolean
    userId?: boolean
    latitude?: boolean
    longitude?: boolean
    accuracy?: boolean
    locationName?: boolean
    status?: boolean
    message?: boolean
    cancelledAt?: boolean
    resolvedAt?: boolean
    nearbyHospitals?: boolean
    notificationsSent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PanicAlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PanicAlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PanicAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PanicAlert"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      latitude: number
      longitude: number
      accuracy: number | null
      locationName: string | null
      status: $Enums.PanicStatus
      message: string | null
      cancelledAt: Date | null
      resolvedAt: Date | null
      nearbyHospitals: Prisma.JsonValue | null
      notificationsSent: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["panicAlert"]>
    composites: {}
  }

  type PanicAlertGetPayload<S extends boolean | null | undefined | PanicAlertDefaultArgs> = $Result.GetResult<Prisma.$PanicAlertPayload, S>

  type PanicAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PanicAlertFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PanicAlertCountAggregateInputType | true
    }

  export interface PanicAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PanicAlert'], meta: { name: 'PanicAlert' } }
    /**
     * Find zero or one PanicAlert that matches the filter.
     * @param {PanicAlertFindUniqueArgs} args - Arguments to find a PanicAlert
     * @example
     * // Get one PanicAlert
     * const panicAlert = await prisma.panicAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PanicAlertFindUniqueArgs>(args: SelectSubset<T, PanicAlertFindUniqueArgs<ExtArgs>>): Prisma__PanicAlertClient<$Result.GetResult<Prisma.$PanicAlertPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PanicAlert that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PanicAlertFindUniqueOrThrowArgs} args - Arguments to find a PanicAlert
     * @example
     * // Get one PanicAlert
     * const panicAlert = await prisma.panicAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PanicAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, PanicAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PanicAlertClient<$Result.GetResult<Prisma.$PanicAlertPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PanicAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanicAlertFindFirstArgs} args - Arguments to find a PanicAlert
     * @example
     * // Get one PanicAlert
     * const panicAlert = await prisma.panicAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PanicAlertFindFirstArgs>(args?: SelectSubset<T, PanicAlertFindFirstArgs<ExtArgs>>): Prisma__PanicAlertClient<$Result.GetResult<Prisma.$PanicAlertPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PanicAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanicAlertFindFirstOrThrowArgs} args - Arguments to find a PanicAlert
     * @example
     * // Get one PanicAlert
     * const panicAlert = await prisma.panicAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PanicAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, PanicAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__PanicAlertClient<$Result.GetResult<Prisma.$PanicAlertPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PanicAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanicAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PanicAlerts
     * const panicAlerts = await prisma.panicAlert.findMany()
     * 
     * // Get first 10 PanicAlerts
     * const panicAlerts = await prisma.panicAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const panicAlertWithIdOnly = await prisma.panicAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PanicAlertFindManyArgs>(args?: SelectSubset<T, PanicAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PanicAlertPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PanicAlert.
     * @param {PanicAlertCreateArgs} args - Arguments to create a PanicAlert.
     * @example
     * // Create one PanicAlert
     * const PanicAlert = await prisma.panicAlert.create({
     *   data: {
     *     // ... data to create a PanicAlert
     *   }
     * })
     * 
     */
    create<T extends PanicAlertCreateArgs>(args: SelectSubset<T, PanicAlertCreateArgs<ExtArgs>>): Prisma__PanicAlertClient<$Result.GetResult<Prisma.$PanicAlertPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PanicAlerts.
     * @param {PanicAlertCreateManyArgs} args - Arguments to create many PanicAlerts.
     * @example
     * // Create many PanicAlerts
     * const panicAlert = await prisma.panicAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PanicAlertCreateManyArgs>(args?: SelectSubset<T, PanicAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PanicAlerts and returns the data saved in the database.
     * @param {PanicAlertCreateManyAndReturnArgs} args - Arguments to create many PanicAlerts.
     * @example
     * // Create many PanicAlerts
     * const panicAlert = await prisma.panicAlert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PanicAlerts and only return the `id`
     * const panicAlertWithIdOnly = await prisma.panicAlert.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PanicAlertCreateManyAndReturnArgs>(args?: SelectSubset<T, PanicAlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PanicAlertPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PanicAlert.
     * @param {PanicAlertDeleteArgs} args - Arguments to delete one PanicAlert.
     * @example
     * // Delete one PanicAlert
     * const PanicAlert = await prisma.panicAlert.delete({
     *   where: {
     *     // ... filter to delete one PanicAlert
     *   }
     * })
     * 
     */
    delete<T extends PanicAlertDeleteArgs>(args: SelectSubset<T, PanicAlertDeleteArgs<ExtArgs>>): Prisma__PanicAlertClient<$Result.GetResult<Prisma.$PanicAlertPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PanicAlert.
     * @param {PanicAlertUpdateArgs} args - Arguments to update one PanicAlert.
     * @example
     * // Update one PanicAlert
     * const panicAlert = await prisma.panicAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PanicAlertUpdateArgs>(args: SelectSubset<T, PanicAlertUpdateArgs<ExtArgs>>): Prisma__PanicAlertClient<$Result.GetResult<Prisma.$PanicAlertPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PanicAlerts.
     * @param {PanicAlertDeleteManyArgs} args - Arguments to filter PanicAlerts to delete.
     * @example
     * // Delete a few PanicAlerts
     * const { count } = await prisma.panicAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PanicAlertDeleteManyArgs>(args?: SelectSubset<T, PanicAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PanicAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanicAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PanicAlerts
     * const panicAlert = await prisma.panicAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PanicAlertUpdateManyArgs>(args: SelectSubset<T, PanicAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PanicAlert.
     * @param {PanicAlertUpsertArgs} args - Arguments to update or create a PanicAlert.
     * @example
     * // Update or create a PanicAlert
     * const panicAlert = await prisma.panicAlert.upsert({
     *   create: {
     *     // ... data to create a PanicAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PanicAlert we want to update
     *   }
     * })
     */
    upsert<T extends PanicAlertUpsertArgs>(args: SelectSubset<T, PanicAlertUpsertArgs<ExtArgs>>): Prisma__PanicAlertClient<$Result.GetResult<Prisma.$PanicAlertPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PanicAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanicAlertCountArgs} args - Arguments to filter PanicAlerts to count.
     * @example
     * // Count the number of PanicAlerts
     * const count = await prisma.panicAlert.count({
     *   where: {
     *     // ... the filter for the PanicAlerts we want to count
     *   }
     * })
    **/
    count<T extends PanicAlertCountArgs>(
      args?: Subset<T, PanicAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PanicAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PanicAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanicAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PanicAlertAggregateArgs>(args: Subset<T, PanicAlertAggregateArgs>): Prisma.PrismaPromise<GetPanicAlertAggregateType<T>>

    /**
     * Group by PanicAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanicAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PanicAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PanicAlertGroupByArgs['orderBy'] }
        : { orderBy?: PanicAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PanicAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPanicAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PanicAlert model
   */
  readonly fields: PanicAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PanicAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PanicAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PanicAlert model
   */ 
  interface PanicAlertFieldRefs {
    readonly id: FieldRef<"PanicAlert", 'String'>
    readonly userId: FieldRef<"PanicAlert", 'String'>
    readonly latitude: FieldRef<"PanicAlert", 'Float'>
    readonly longitude: FieldRef<"PanicAlert", 'Float'>
    readonly accuracy: FieldRef<"PanicAlert", 'Float'>
    readonly locationName: FieldRef<"PanicAlert", 'String'>
    readonly status: FieldRef<"PanicAlert", 'PanicStatus'>
    readonly message: FieldRef<"PanicAlert", 'String'>
    readonly cancelledAt: FieldRef<"PanicAlert", 'DateTime'>
    readonly resolvedAt: FieldRef<"PanicAlert", 'DateTime'>
    readonly nearbyHospitals: FieldRef<"PanicAlert", 'Json'>
    readonly notificationsSent: FieldRef<"PanicAlert", 'Json'>
    readonly createdAt: FieldRef<"PanicAlert", 'DateTime'>
    readonly updatedAt: FieldRef<"PanicAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PanicAlert findUnique
   */
  export type PanicAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanicAlert
     */
    select?: PanicAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanicAlertInclude<ExtArgs> | null
    /**
     * Filter, which PanicAlert to fetch.
     */
    where: PanicAlertWhereUniqueInput
  }

  /**
   * PanicAlert findUniqueOrThrow
   */
  export type PanicAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanicAlert
     */
    select?: PanicAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanicAlertInclude<ExtArgs> | null
    /**
     * Filter, which PanicAlert to fetch.
     */
    where: PanicAlertWhereUniqueInput
  }

  /**
   * PanicAlert findFirst
   */
  export type PanicAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanicAlert
     */
    select?: PanicAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanicAlertInclude<ExtArgs> | null
    /**
     * Filter, which PanicAlert to fetch.
     */
    where?: PanicAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PanicAlerts to fetch.
     */
    orderBy?: PanicAlertOrderByWithRelationInput | PanicAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PanicAlerts.
     */
    cursor?: PanicAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PanicAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PanicAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PanicAlerts.
     */
    distinct?: PanicAlertScalarFieldEnum | PanicAlertScalarFieldEnum[]
  }

  /**
   * PanicAlert findFirstOrThrow
   */
  export type PanicAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanicAlert
     */
    select?: PanicAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanicAlertInclude<ExtArgs> | null
    /**
     * Filter, which PanicAlert to fetch.
     */
    where?: PanicAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PanicAlerts to fetch.
     */
    orderBy?: PanicAlertOrderByWithRelationInput | PanicAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PanicAlerts.
     */
    cursor?: PanicAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PanicAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PanicAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PanicAlerts.
     */
    distinct?: PanicAlertScalarFieldEnum | PanicAlertScalarFieldEnum[]
  }

  /**
   * PanicAlert findMany
   */
  export type PanicAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanicAlert
     */
    select?: PanicAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanicAlertInclude<ExtArgs> | null
    /**
     * Filter, which PanicAlerts to fetch.
     */
    where?: PanicAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PanicAlerts to fetch.
     */
    orderBy?: PanicAlertOrderByWithRelationInput | PanicAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PanicAlerts.
     */
    cursor?: PanicAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PanicAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PanicAlerts.
     */
    skip?: number
    distinct?: PanicAlertScalarFieldEnum | PanicAlertScalarFieldEnum[]
  }

  /**
   * PanicAlert create
   */
  export type PanicAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanicAlert
     */
    select?: PanicAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanicAlertInclude<ExtArgs> | null
    /**
     * The data needed to create a PanicAlert.
     */
    data: XOR<PanicAlertCreateInput, PanicAlertUncheckedCreateInput>
  }

  /**
   * PanicAlert createMany
   */
  export type PanicAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PanicAlerts.
     */
    data: PanicAlertCreateManyInput | PanicAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PanicAlert createManyAndReturn
   */
  export type PanicAlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanicAlert
     */
    select?: PanicAlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PanicAlerts.
     */
    data: PanicAlertCreateManyInput | PanicAlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanicAlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PanicAlert update
   */
  export type PanicAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanicAlert
     */
    select?: PanicAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanicAlertInclude<ExtArgs> | null
    /**
     * The data needed to update a PanicAlert.
     */
    data: XOR<PanicAlertUpdateInput, PanicAlertUncheckedUpdateInput>
    /**
     * Choose, which PanicAlert to update.
     */
    where: PanicAlertWhereUniqueInput
  }

  /**
   * PanicAlert updateMany
   */
  export type PanicAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PanicAlerts.
     */
    data: XOR<PanicAlertUpdateManyMutationInput, PanicAlertUncheckedUpdateManyInput>
    /**
     * Filter which PanicAlerts to update
     */
    where?: PanicAlertWhereInput
  }

  /**
   * PanicAlert upsert
   */
  export type PanicAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanicAlert
     */
    select?: PanicAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanicAlertInclude<ExtArgs> | null
    /**
     * The filter to search for the PanicAlert to update in case it exists.
     */
    where: PanicAlertWhereUniqueInput
    /**
     * In case the PanicAlert found by the `where` argument doesn't exist, create a new PanicAlert with this data.
     */
    create: XOR<PanicAlertCreateInput, PanicAlertUncheckedCreateInput>
    /**
     * In case the PanicAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PanicAlertUpdateInput, PanicAlertUncheckedUpdateInput>
  }

  /**
   * PanicAlert delete
   */
  export type PanicAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanicAlert
     */
    select?: PanicAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanicAlertInclude<ExtArgs> | null
    /**
     * Filter which PanicAlert to delete.
     */
    where: PanicAlertWhereUniqueInput
  }

  /**
   * PanicAlert deleteMany
   */
  export type PanicAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PanicAlerts to delete
     */
    where?: PanicAlertWhereInput
  }

  /**
   * PanicAlert without action
   */
  export type PanicAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanicAlert
     */
    select?: PanicAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanicAlertInclude<ExtArgs> | null
  }


  /**
   * Model AdminUser
   */

  export type AggregateAdminUser = {
    _count: AdminUserCountAggregateOutputType | null
    _avg: AdminUserAvgAggregateOutputType | null
    _sum: AdminUserSumAggregateOutputType | null
    _min: AdminUserMinAggregateOutputType | null
    _max: AdminUserMaxAggregateOutputType | null
  }

  export type AdminUserAvgAggregateOutputType = {
    failedAttempts: number | null
  }

  export type AdminUserSumAggregateOutputType = {
    failedAttempts: number | null
  }

  export type AdminUserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    role: $Enums.AdminRole | null
    isActive: boolean | null
    isSuperAdmin: boolean | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    failedAttempts: number | null
    lockedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type AdminUserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    role: $Enums.AdminRole | null
    isActive: boolean | null
    isSuperAdmin: boolean | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    failedAttempts: number | null
    lockedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type AdminUserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    name: number
    role: number
    permissions: number
    isActive: number
    isSuperAdmin: number
    lastLoginAt: number
    lastLoginIp: number
    failedAttempts: number
    lockedUntil: number
    createdAt: number
    updatedAt: number
    createdBy: number
    _all: number
  }


  export type AdminUserAvgAggregateInputType = {
    failedAttempts?: true
  }

  export type AdminUserSumAggregateInputType = {
    failedAttempts?: true
  }

  export type AdminUserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    role?: true
    isActive?: true
    isSuperAdmin?: true
    lastLoginAt?: true
    lastLoginIp?: true
    failedAttempts?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type AdminUserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    role?: true
    isActive?: true
    isSuperAdmin?: true
    lastLoginAt?: true
    lastLoginIp?: true
    failedAttempts?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type AdminUserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    role?: true
    permissions?: true
    isActive?: true
    isSuperAdmin?: true
    lastLoginAt?: true
    lastLoginIp?: true
    failedAttempts?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    _all?: true
  }

  export type AdminUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminUser to aggregate.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminUsers
    **/
    _count?: true | AdminUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminUserMaxAggregateInputType
  }

  export type GetAdminUserAggregateType<T extends AdminUserAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminUser[P]>
      : GetScalarType<T[P], AggregateAdminUser[P]>
  }




  export type AdminUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminUserWhereInput
    orderBy?: AdminUserOrderByWithAggregationInput | AdminUserOrderByWithAggregationInput[]
    by: AdminUserScalarFieldEnum[] | AdminUserScalarFieldEnum
    having?: AdminUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminUserCountAggregateInputType | true
    _avg?: AdminUserAvgAggregateInputType
    _sum?: AdminUserSumAggregateInputType
    _min?: AdminUserMinAggregateInputType
    _max?: AdminUserMaxAggregateInputType
  }

  export type AdminUserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.AdminRole
    permissions: string[]
    isActive: boolean
    isSuperAdmin: boolean
    lastLoginAt: Date | null
    lastLoginIp: string | null
    failedAttempts: number
    lockedUntil: Date | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    _count: AdminUserCountAggregateOutputType | null
    _avg: AdminUserAvgAggregateOutputType | null
    _sum: AdminUserSumAggregateOutputType | null
    _min: AdminUserMinAggregateOutputType | null
    _max: AdminUserMaxAggregateOutputType | null
  }

  type GetAdminUserGroupByPayload<T extends AdminUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminUserGroupByOutputType[P]>
            : GetScalarType<T[P], AdminUserGroupByOutputType[P]>
        }
      >
    >


  export type AdminUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    role?: boolean
    permissions?: boolean
    isActive?: boolean
    isSuperAdmin?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    failedAttempts?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    sessions?: boolean | AdminUser$sessionsArgs<ExtArgs>
    auditActions?: boolean | AdminUser$auditActionsArgs<ExtArgs>
    _count?: boolean | AdminUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminUser"]>

  export type AdminUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    role?: boolean
    permissions?: boolean
    isActive?: boolean
    isSuperAdmin?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    failedAttempts?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }, ExtArgs["result"]["adminUser"]>

  export type AdminUserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    role?: boolean
    permissions?: boolean
    isActive?: boolean
    isSuperAdmin?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    failedAttempts?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }

  export type AdminUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | AdminUser$sessionsArgs<ExtArgs>
    auditActions?: boolean | AdminUser$auditActionsArgs<ExtArgs>
    _count?: boolean | AdminUserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdminUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminUser"
    objects: {
      sessions: Prisma.$AdminSessionPayload<ExtArgs>[]
      auditActions: Prisma.$AdminAuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      name: string
      role: $Enums.AdminRole
      permissions: string[]
      isActive: boolean
      isSuperAdmin: boolean
      lastLoginAt: Date | null
      lastLoginIp: string | null
      failedAttempts: number
      lockedUntil: Date | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["adminUser"]>
    composites: {}
  }

  type AdminUserGetPayload<S extends boolean | null | undefined | AdminUserDefaultArgs> = $Result.GetResult<Prisma.$AdminUserPayload, S>

  type AdminUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminUserCountAggregateInputType | true
    }

  export interface AdminUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminUser'], meta: { name: 'AdminUser' } }
    /**
     * Find zero or one AdminUser that matches the filter.
     * @param {AdminUserFindUniqueArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminUserFindUniqueArgs>(args: SelectSubset<T, AdminUserFindUniqueArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminUserFindUniqueOrThrowArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminUserFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserFindFirstArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminUserFindFirstArgs>(args?: SelectSubset<T, AdminUserFindFirstArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserFindFirstOrThrowArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminUserFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminUsers
     * const adminUsers = await prisma.adminUser.findMany()
     * 
     * // Get first 10 AdminUsers
     * const adminUsers = await prisma.adminUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminUserWithIdOnly = await prisma.adminUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminUserFindManyArgs>(args?: SelectSubset<T, AdminUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminUser.
     * @param {AdminUserCreateArgs} args - Arguments to create a AdminUser.
     * @example
     * // Create one AdminUser
     * const AdminUser = await prisma.adminUser.create({
     *   data: {
     *     // ... data to create a AdminUser
     *   }
     * })
     * 
     */
    create<T extends AdminUserCreateArgs>(args: SelectSubset<T, AdminUserCreateArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminUsers.
     * @param {AdminUserCreateManyArgs} args - Arguments to create many AdminUsers.
     * @example
     * // Create many AdminUsers
     * const adminUser = await prisma.adminUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminUserCreateManyArgs>(args?: SelectSubset<T, AdminUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminUsers and returns the data saved in the database.
     * @param {AdminUserCreateManyAndReturnArgs} args - Arguments to create many AdminUsers.
     * @example
     * // Create many AdminUsers
     * const adminUser = await prisma.adminUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminUsers and only return the `id`
     * const adminUserWithIdOnly = await prisma.adminUser.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminUserCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminUser.
     * @param {AdminUserDeleteArgs} args - Arguments to delete one AdminUser.
     * @example
     * // Delete one AdminUser
     * const AdminUser = await prisma.adminUser.delete({
     *   where: {
     *     // ... filter to delete one AdminUser
     *   }
     * })
     * 
     */
    delete<T extends AdminUserDeleteArgs>(args: SelectSubset<T, AdminUserDeleteArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminUser.
     * @param {AdminUserUpdateArgs} args - Arguments to update one AdminUser.
     * @example
     * // Update one AdminUser
     * const adminUser = await prisma.adminUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUserUpdateArgs>(args: SelectSubset<T, AdminUserUpdateArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminUsers.
     * @param {AdminUserDeleteManyArgs} args - Arguments to filter AdminUsers to delete.
     * @example
     * // Delete a few AdminUsers
     * const { count } = await prisma.adminUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminUserDeleteManyArgs>(args?: SelectSubset<T, AdminUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminUsers
     * const adminUser = await prisma.adminUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUserUpdateManyArgs>(args: SelectSubset<T, AdminUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminUser.
     * @param {AdminUserUpsertArgs} args - Arguments to update or create a AdminUser.
     * @example
     * // Update or create a AdminUser
     * const adminUser = await prisma.adminUser.upsert({
     *   create: {
     *     // ... data to create a AdminUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminUser we want to update
     *   }
     * })
     */
    upsert<T extends AdminUserUpsertArgs>(args: SelectSubset<T, AdminUserUpsertArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserCountArgs} args - Arguments to filter AdminUsers to count.
     * @example
     * // Count the number of AdminUsers
     * const count = await prisma.adminUser.count({
     *   where: {
     *     // ... the filter for the AdminUsers we want to count
     *   }
     * })
    **/
    count<T extends AdminUserCountArgs>(
      args?: Subset<T, AdminUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminUserAggregateArgs>(args: Subset<T, AdminUserAggregateArgs>): Prisma.PrismaPromise<GetAdminUserAggregateType<T>>

    /**
     * Group by AdminUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminUserGroupByArgs['orderBy'] }
        : { orderBy?: AdminUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminUser model
   */
  readonly fields: AdminUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends AdminUser$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "findMany"> | Null>
    auditActions<T extends AdminUser$auditActionsArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$auditActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminUser model
   */ 
  interface AdminUserFieldRefs {
    readonly id: FieldRef<"AdminUser", 'String'>
    readonly email: FieldRef<"AdminUser", 'String'>
    readonly passwordHash: FieldRef<"AdminUser", 'String'>
    readonly name: FieldRef<"AdminUser", 'String'>
    readonly role: FieldRef<"AdminUser", 'AdminRole'>
    readonly permissions: FieldRef<"AdminUser", 'String[]'>
    readonly isActive: FieldRef<"AdminUser", 'Boolean'>
    readonly isSuperAdmin: FieldRef<"AdminUser", 'Boolean'>
    readonly lastLoginAt: FieldRef<"AdminUser", 'DateTime'>
    readonly lastLoginIp: FieldRef<"AdminUser", 'String'>
    readonly failedAttempts: FieldRef<"AdminUser", 'Int'>
    readonly lockedUntil: FieldRef<"AdminUser", 'DateTime'>
    readonly createdAt: FieldRef<"AdminUser", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminUser", 'DateTime'>
    readonly createdBy: FieldRef<"AdminUser", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdminUser findUnique
   */
  export type AdminUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where: AdminUserWhereUniqueInput
  }

  /**
   * AdminUser findUniqueOrThrow
   */
  export type AdminUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where: AdminUserWhereUniqueInput
  }

  /**
   * AdminUser findFirst
   */
  export type AdminUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminUsers.
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminUsers.
     */
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
  }

  /**
   * AdminUser findFirstOrThrow
   */
  export type AdminUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminUsers.
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminUsers.
     */
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
  }

  /**
   * AdminUser findMany
   */
  export type AdminUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUsers to fetch.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminUsers.
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
  }

  /**
   * AdminUser create
   */
  export type AdminUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminUser.
     */
    data: XOR<AdminUserCreateInput, AdminUserUncheckedCreateInput>
  }

  /**
   * AdminUser createMany
   */
  export type AdminUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminUsers.
     */
    data: AdminUserCreateManyInput | AdminUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminUser createManyAndReturn
   */
  export type AdminUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminUsers.
     */
    data: AdminUserCreateManyInput | AdminUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminUser update
   */
  export type AdminUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminUser.
     */
    data: XOR<AdminUserUpdateInput, AdminUserUncheckedUpdateInput>
    /**
     * Choose, which AdminUser to update.
     */
    where: AdminUserWhereUniqueInput
  }

  /**
   * AdminUser updateMany
   */
  export type AdminUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminUsers.
     */
    data: XOR<AdminUserUpdateManyMutationInput, AdminUserUncheckedUpdateManyInput>
    /**
     * Filter which AdminUsers to update
     */
    where?: AdminUserWhereInput
  }

  /**
   * AdminUser upsert
   */
  export type AdminUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminUser to update in case it exists.
     */
    where: AdminUserWhereUniqueInput
    /**
     * In case the AdminUser found by the `where` argument doesn't exist, create a new AdminUser with this data.
     */
    create: XOR<AdminUserCreateInput, AdminUserUncheckedCreateInput>
    /**
     * In case the AdminUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUserUpdateInput, AdminUserUncheckedUpdateInput>
  }

  /**
   * AdminUser delete
   */
  export type AdminUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter which AdminUser to delete.
     */
    where: AdminUserWhereUniqueInput
  }

  /**
   * AdminUser deleteMany
   */
  export type AdminUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminUsers to delete
     */
    where?: AdminUserWhereInput
  }

  /**
   * AdminUser.sessions
   */
  export type AdminUser$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    where?: AdminSessionWhereInput
    orderBy?: AdminSessionOrderByWithRelationInput | AdminSessionOrderByWithRelationInput[]
    cursor?: AdminSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminSessionScalarFieldEnum | AdminSessionScalarFieldEnum[]
  }

  /**
   * AdminUser.auditActions
   */
  export type AdminUser$auditActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    where?: AdminAuditLogWhereInput
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    cursor?: AdminAuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * AdminUser without action
   */
  export type AdminUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
  }


  /**
   * Model AdminSession
   */

  export type AggregateAdminSession = {
    _count: AdminSessionCountAggregateOutputType | null
    _min: AdminSessionMinAggregateOutputType | null
    _max: AdminSessionMaxAggregateOutputType | null
  }

  export type AdminSessionMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    refreshToken: string | null
    userAgent: string | null
    ipAddress: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type AdminSessionMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    refreshToken: string | null
    userAgent: string | null
    ipAddress: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type AdminSessionCountAggregateOutputType = {
    id: number
    adminId: number
    refreshToken: number
    userAgent: number
    ipAddress: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type AdminSessionMinAggregateInputType = {
    id?: true
    adminId?: true
    refreshToken?: true
    userAgent?: true
    ipAddress?: true
    expiresAt?: true
    createdAt?: true
  }

  export type AdminSessionMaxAggregateInputType = {
    id?: true
    adminId?: true
    refreshToken?: true
    userAgent?: true
    ipAddress?: true
    expiresAt?: true
    createdAt?: true
  }

  export type AdminSessionCountAggregateInputType = {
    id?: true
    adminId?: true
    refreshToken?: true
    userAgent?: true
    ipAddress?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type AdminSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminSession to aggregate.
     */
    where?: AdminSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSessions to fetch.
     */
    orderBy?: AdminSessionOrderByWithRelationInput | AdminSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminSessions
    **/
    _count?: true | AdminSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminSessionMaxAggregateInputType
  }

  export type GetAdminSessionAggregateType<T extends AdminSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminSession[P]>
      : GetScalarType<T[P], AggregateAdminSession[P]>
  }




  export type AdminSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminSessionWhereInput
    orderBy?: AdminSessionOrderByWithAggregationInput | AdminSessionOrderByWithAggregationInput[]
    by: AdminSessionScalarFieldEnum[] | AdminSessionScalarFieldEnum
    having?: AdminSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminSessionCountAggregateInputType | true
    _min?: AdminSessionMinAggregateInputType
    _max?: AdminSessionMaxAggregateInputType
  }

  export type AdminSessionGroupByOutputType = {
    id: string
    adminId: string
    refreshToken: string
    userAgent: string | null
    ipAddress: string | null
    expiresAt: Date
    createdAt: Date
    _count: AdminSessionCountAggregateOutputType | null
    _min: AdminSessionMinAggregateOutputType | null
    _max: AdminSessionMaxAggregateOutputType | null
  }

  type GetAdminSessionGroupByPayload<T extends AdminSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminSessionGroupByOutputType[P]>
            : GetScalarType<T[P], AdminSessionGroupByOutputType[P]>
        }
      >
    >


  export type AdminSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    refreshToken?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    admin?: boolean | AdminUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminSession"]>

  export type AdminSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    refreshToken?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    admin?: boolean | AdminUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminSession"]>

  export type AdminSessionSelectScalar = {
    id?: boolean
    adminId?: boolean
    refreshToken?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type AdminSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminUserDefaultArgs<ExtArgs>
  }
  export type AdminSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminUserDefaultArgs<ExtArgs>
  }

  export type $AdminSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminSession"
    objects: {
      admin: Prisma.$AdminUserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      refreshToken: string
      userAgent: string | null
      ipAddress: string | null
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["adminSession"]>
    composites: {}
  }

  type AdminSessionGetPayload<S extends boolean | null | undefined | AdminSessionDefaultArgs> = $Result.GetResult<Prisma.$AdminSessionPayload, S>

  type AdminSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminSessionCountAggregateInputType | true
    }

  export interface AdminSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminSession'], meta: { name: 'AdminSession' } }
    /**
     * Find zero or one AdminSession that matches the filter.
     * @param {AdminSessionFindUniqueArgs} args - Arguments to find a AdminSession
     * @example
     * // Get one AdminSession
     * const adminSession = await prisma.adminSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminSessionFindUniqueArgs>(args: SelectSubset<T, AdminSessionFindUniqueArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminSessionFindUniqueOrThrowArgs} args - Arguments to find a AdminSession
     * @example
     * // Get one AdminSession
     * const adminSession = await prisma.adminSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionFindFirstArgs} args - Arguments to find a AdminSession
     * @example
     * // Get one AdminSession
     * const adminSession = await prisma.adminSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminSessionFindFirstArgs>(args?: SelectSubset<T, AdminSessionFindFirstArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionFindFirstOrThrowArgs} args - Arguments to find a AdminSession
     * @example
     * // Get one AdminSession
     * const adminSession = await prisma.adminSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminSessions
     * const adminSessions = await prisma.adminSession.findMany()
     * 
     * // Get first 10 AdminSessions
     * const adminSessions = await prisma.adminSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminSessionWithIdOnly = await prisma.adminSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminSessionFindManyArgs>(args?: SelectSubset<T, AdminSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminSession.
     * @param {AdminSessionCreateArgs} args - Arguments to create a AdminSession.
     * @example
     * // Create one AdminSession
     * const AdminSession = await prisma.adminSession.create({
     *   data: {
     *     // ... data to create a AdminSession
     *   }
     * })
     * 
     */
    create<T extends AdminSessionCreateArgs>(args: SelectSubset<T, AdminSessionCreateArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminSessions.
     * @param {AdminSessionCreateManyArgs} args - Arguments to create many AdminSessions.
     * @example
     * // Create many AdminSessions
     * const adminSession = await prisma.adminSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminSessionCreateManyArgs>(args?: SelectSubset<T, AdminSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminSessions and returns the data saved in the database.
     * @param {AdminSessionCreateManyAndReturnArgs} args - Arguments to create many AdminSessions.
     * @example
     * // Create many AdminSessions
     * const adminSession = await prisma.adminSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminSessions and only return the `id`
     * const adminSessionWithIdOnly = await prisma.adminSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminSession.
     * @param {AdminSessionDeleteArgs} args - Arguments to delete one AdminSession.
     * @example
     * // Delete one AdminSession
     * const AdminSession = await prisma.adminSession.delete({
     *   where: {
     *     // ... filter to delete one AdminSession
     *   }
     * })
     * 
     */
    delete<T extends AdminSessionDeleteArgs>(args: SelectSubset<T, AdminSessionDeleteArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminSession.
     * @param {AdminSessionUpdateArgs} args - Arguments to update one AdminSession.
     * @example
     * // Update one AdminSession
     * const adminSession = await prisma.adminSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminSessionUpdateArgs>(args: SelectSubset<T, AdminSessionUpdateArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminSessions.
     * @param {AdminSessionDeleteManyArgs} args - Arguments to filter AdminSessions to delete.
     * @example
     * // Delete a few AdminSessions
     * const { count } = await prisma.adminSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminSessionDeleteManyArgs>(args?: SelectSubset<T, AdminSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminSessions
     * const adminSession = await prisma.adminSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminSessionUpdateManyArgs>(args: SelectSubset<T, AdminSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminSession.
     * @param {AdminSessionUpsertArgs} args - Arguments to update or create a AdminSession.
     * @example
     * // Update or create a AdminSession
     * const adminSession = await prisma.adminSession.upsert({
     *   create: {
     *     // ... data to create a AdminSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminSession we want to update
     *   }
     * })
     */
    upsert<T extends AdminSessionUpsertArgs>(args: SelectSubset<T, AdminSessionUpsertArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionCountArgs} args - Arguments to filter AdminSessions to count.
     * @example
     * // Count the number of AdminSessions
     * const count = await prisma.adminSession.count({
     *   where: {
     *     // ... the filter for the AdminSessions we want to count
     *   }
     * })
    **/
    count<T extends AdminSessionCountArgs>(
      args?: Subset<T, AdminSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminSessionAggregateArgs>(args: Subset<T, AdminSessionAggregateArgs>): Prisma.PrismaPromise<GetAdminSessionAggregateType<T>>

    /**
     * Group by AdminSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminSessionGroupByArgs['orderBy'] }
        : { orderBy?: AdminSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminSession model
   */
  readonly fields: AdminSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminUserDefaultArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminSession model
   */ 
  interface AdminSessionFieldRefs {
    readonly id: FieldRef<"AdminSession", 'String'>
    readonly adminId: FieldRef<"AdminSession", 'String'>
    readonly refreshToken: FieldRef<"AdminSession", 'String'>
    readonly userAgent: FieldRef<"AdminSession", 'String'>
    readonly ipAddress: FieldRef<"AdminSession", 'String'>
    readonly expiresAt: FieldRef<"AdminSession", 'DateTime'>
    readonly createdAt: FieldRef<"AdminSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminSession findUnique
   */
  export type AdminSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * Filter, which AdminSession to fetch.
     */
    where: AdminSessionWhereUniqueInput
  }

  /**
   * AdminSession findUniqueOrThrow
   */
  export type AdminSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * Filter, which AdminSession to fetch.
     */
    where: AdminSessionWhereUniqueInput
  }

  /**
   * AdminSession findFirst
   */
  export type AdminSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * Filter, which AdminSession to fetch.
     */
    where?: AdminSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSessions to fetch.
     */
    orderBy?: AdminSessionOrderByWithRelationInput | AdminSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminSessions.
     */
    cursor?: AdminSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminSessions.
     */
    distinct?: AdminSessionScalarFieldEnum | AdminSessionScalarFieldEnum[]
  }

  /**
   * AdminSession findFirstOrThrow
   */
  export type AdminSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * Filter, which AdminSession to fetch.
     */
    where?: AdminSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSessions to fetch.
     */
    orderBy?: AdminSessionOrderByWithRelationInput | AdminSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminSessions.
     */
    cursor?: AdminSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminSessions.
     */
    distinct?: AdminSessionScalarFieldEnum | AdminSessionScalarFieldEnum[]
  }

  /**
   * AdminSession findMany
   */
  export type AdminSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * Filter, which AdminSessions to fetch.
     */
    where?: AdminSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSessions to fetch.
     */
    orderBy?: AdminSessionOrderByWithRelationInput | AdminSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminSessions.
     */
    cursor?: AdminSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSessions.
     */
    skip?: number
    distinct?: AdminSessionScalarFieldEnum | AdminSessionScalarFieldEnum[]
  }

  /**
   * AdminSession create
   */
  export type AdminSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminSession.
     */
    data: XOR<AdminSessionCreateInput, AdminSessionUncheckedCreateInput>
  }

  /**
   * AdminSession createMany
   */
  export type AdminSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminSessions.
     */
    data: AdminSessionCreateManyInput | AdminSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminSession createManyAndReturn
   */
  export type AdminSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminSessions.
     */
    data: AdminSessionCreateManyInput | AdminSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminSession update
   */
  export type AdminSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminSession.
     */
    data: XOR<AdminSessionUpdateInput, AdminSessionUncheckedUpdateInput>
    /**
     * Choose, which AdminSession to update.
     */
    where: AdminSessionWhereUniqueInput
  }

  /**
   * AdminSession updateMany
   */
  export type AdminSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminSessions.
     */
    data: XOR<AdminSessionUpdateManyMutationInput, AdminSessionUncheckedUpdateManyInput>
    /**
     * Filter which AdminSessions to update
     */
    where?: AdminSessionWhereInput
  }

  /**
   * AdminSession upsert
   */
  export type AdminSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminSession to update in case it exists.
     */
    where: AdminSessionWhereUniqueInput
    /**
     * In case the AdminSession found by the `where` argument doesn't exist, create a new AdminSession with this data.
     */
    create: XOR<AdminSessionCreateInput, AdminSessionUncheckedCreateInput>
    /**
     * In case the AdminSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminSessionUpdateInput, AdminSessionUncheckedUpdateInput>
  }

  /**
   * AdminSession delete
   */
  export type AdminSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * Filter which AdminSession to delete.
     */
    where: AdminSessionWhereUniqueInput
  }

  /**
   * AdminSession deleteMany
   */
  export type AdminSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminSessions to delete
     */
    where?: AdminSessionWhereInput
  }

  /**
   * AdminSession without action
   */
  export type AdminSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
  }


  /**
   * Model AdminAuditLog
   */

  export type AggregateAdminAuditLog = {
    _count: AdminAuditLogCountAggregateOutputType | null
    _min: AdminAuditLogMinAggregateOutputType | null
    _max: AdminAuditLogMaxAggregateOutputType | null
  }

  export type AdminAuditLogMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AdminAuditLogMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AdminAuditLogCountAggregateOutputType = {
    id: number
    adminId: number
    action: number
    resource: number
    resourceId: number
    details: number
    oldValue: number
    newValue: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AdminAuditLogMinAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AdminAuditLogMaxAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AdminAuditLogCountAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    resource?: true
    resourceId?: true
    details?: true
    oldValue?: true
    newValue?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AdminAuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAuditLog to aggregate.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminAuditLogs
    **/
    _count?: true | AdminAuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminAuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminAuditLogMaxAggregateInputType
  }

  export type GetAdminAuditLogAggregateType<T extends AdminAuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminAuditLog[P]>
      : GetScalarType<T[P], AggregateAdminAuditLog[P]>
  }




  export type AdminAuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuditLogWhereInput
    orderBy?: AdminAuditLogOrderByWithAggregationInput | AdminAuditLogOrderByWithAggregationInput[]
    by: AdminAuditLogScalarFieldEnum[] | AdminAuditLogScalarFieldEnum
    having?: AdminAuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminAuditLogCountAggregateInputType | true
    _min?: AdminAuditLogMinAggregateInputType
    _max?: AdminAuditLogMaxAggregateInputType
  }

  export type AdminAuditLogGroupByOutputType = {
    id: string
    adminId: string
    action: string
    resource: string
    resourceId: string | null
    details: JsonValue | null
    oldValue: JsonValue | null
    newValue: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AdminAuditLogCountAggregateOutputType | null
    _min: AdminAuditLogMinAggregateOutputType | null
    _max: AdminAuditLogMaxAggregateOutputType | null
  }

  type GetAdminAuditLogGroupByPayload<T extends AdminAuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminAuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminAuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AdminAuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AdminAuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    oldValue?: boolean
    newValue?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    admin?: boolean | AdminUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuditLog"]>

  export type AdminAuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    oldValue?: boolean
    newValue?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    admin?: boolean | AdminUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuditLog"]>

  export type AdminAuditLogSelectScalar = {
    id?: boolean
    adminId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    oldValue?: boolean
    newValue?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AdminAuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminUserDefaultArgs<ExtArgs>
  }
  export type AdminAuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminUserDefaultArgs<ExtArgs>
  }

  export type $AdminAuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminAuditLog"
    objects: {
      admin: Prisma.$AdminUserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      action: string
      resource: string
      resourceId: string | null
      details: Prisma.JsonValue | null
      oldValue: Prisma.JsonValue | null
      newValue: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["adminAuditLog"]>
    composites: {}
  }

  type AdminAuditLogGetPayload<S extends boolean | null | undefined | AdminAuditLogDefaultArgs> = $Result.GetResult<Prisma.$AdminAuditLogPayload, S>

  type AdminAuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminAuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminAuditLogCountAggregateInputType | true
    }

  export interface AdminAuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminAuditLog'], meta: { name: 'AdminAuditLog' } }
    /**
     * Find zero or one AdminAuditLog that matches the filter.
     * @param {AdminAuditLogFindUniqueArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminAuditLogFindUniqueArgs>(args: SelectSubset<T, AdminAuditLogFindUniqueArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminAuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminAuditLogFindUniqueOrThrowArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminAuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminAuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogFindFirstArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminAuditLogFindFirstArgs>(args?: SelectSubset<T, AdminAuditLogFindFirstArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogFindFirstOrThrowArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminAuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminAuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminAuditLogs
     * const adminAuditLogs = await prisma.adminAuditLog.findMany()
     * 
     * // Get first 10 AdminAuditLogs
     * const adminAuditLogs = await prisma.adminAuditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminAuditLogWithIdOnly = await prisma.adminAuditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminAuditLogFindManyArgs>(args?: SelectSubset<T, AdminAuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminAuditLog.
     * @param {AdminAuditLogCreateArgs} args - Arguments to create a AdminAuditLog.
     * @example
     * // Create one AdminAuditLog
     * const AdminAuditLog = await prisma.adminAuditLog.create({
     *   data: {
     *     // ... data to create a AdminAuditLog
     *   }
     * })
     * 
     */
    create<T extends AdminAuditLogCreateArgs>(args: SelectSubset<T, AdminAuditLogCreateArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminAuditLogs.
     * @param {AdminAuditLogCreateManyArgs} args - Arguments to create many AdminAuditLogs.
     * @example
     * // Create many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminAuditLogCreateManyArgs>(args?: SelectSubset<T, AdminAuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminAuditLogs and returns the data saved in the database.
     * @param {AdminAuditLogCreateManyAndReturnArgs} args - Arguments to create many AdminAuditLogs.
     * @example
     * // Create many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminAuditLogs and only return the `id`
     * const adminAuditLogWithIdOnly = await prisma.adminAuditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminAuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminAuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminAuditLog.
     * @param {AdminAuditLogDeleteArgs} args - Arguments to delete one AdminAuditLog.
     * @example
     * // Delete one AdminAuditLog
     * const AdminAuditLog = await prisma.adminAuditLog.delete({
     *   where: {
     *     // ... filter to delete one AdminAuditLog
     *   }
     * })
     * 
     */
    delete<T extends AdminAuditLogDeleteArgs>(args: SelectSubset<T, AdminAuditLogDeleteArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminAuditLog.
     * @param {AdminAuditLogUpdateArgs} args - Arguments to update one AdminAuditLog.
     * @example
     * // Update one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminAuditLogUpdateArgs>(args: SelectSubset<T, AdminAuditLogUpdateArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminAuditLogs.
     * @param {AdminAuditLogDeleteManyArgs} args - Arguments to filter AdminAuditLogs to delete.
     * @example
     * // Delete a few AdminAuditLogs
     * const { count } = await prisma.adminAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminAuditLogDeleteManyArgs>(args?: SelectSubset<T, AdminAuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminAuditLogUpdateManyArgs>(args: SelectSubset<T, AdminAuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminAuditLog.
     * @param {AdminAuditLogUpsertArgs} args - Arguments to update or create a AdminAuditLog.
     * @example
     * // Update or create a AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.upsert({
     *   create: {
     *     // ... data to create a AdminAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminAuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AdminAuditLogUpsertArgs>(args: SelectSubset<T, AdminAuditLogUpsertArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogCountArgs} args - Arguments to filter AdminAuditLogs to count.
     * @example
     * // Count the number of AdminAuditLogs
     * const count = await prisma.adminAuditLog.count({
     *   where: {
     *     // ... the filter for the AdminAuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AdminAuditLogCountArgs>(
      args?: Subset<T, AdminAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminAuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAuditLogAggregateArgs>(args: Subset<T, AdminAuditLogAggregateArgs>): Prisma.PrismaPromise<GetAdminAuditLogAggregateType<T>>

    /**
     * Group by AdminAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AdminAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminAuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminAuditLog model
   */
  readonly fields: AdminAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminAuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminUserDefaultArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminAuditLog model
   */ 
  interface AdminAuditLogFieldRefs {
    readonly id: FieldRef<"AdminAuditLog", 'String'>
    readonly adminId: FieldRef<"AdminAuditLog", 'String'>
    readonly action: FieldRef<"AdminAuditLog", 'String'>
    readonly resource: FieldRef<"AdminAuditLog", 'String'>
    readonly resourceId: FieldRef<"AdminAuditLog", 'String'>
    readonly details: FieldRef<"AdminAuditLog", 'Json'>
    readonly oldValue: FieldRef<"AdminAuditLog", 'Json'>
    readonly newValue: FieldRef<"AdminAuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AdminAuditLog", 'String'>
    readonly userAgent: FieldRef<"AdminAuditLog", 'String'>
    readonly createdAt: FieldRef<"AdminAuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminAuditLog findUnique
   */
  export type AdminAuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog findUniqueOrThrow
   */
  export type AdminAuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog findFirst
   */
  export type AdminAuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAuditLogs.
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAuditLogs.
     */
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * AdminAuditLog findFirstOrThrow
   */
  export type AdminAuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAuditLogs.
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAuditLogs.
     */
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * AdminAuditLog findMany
   */
  export type AdminAuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLogs to fetch.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminAuditLogs.
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * AdminAuditLog create
   */
  export type AdminAuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminAuditLog.
     */
    data: XOR<AdminAuditLogCreateInput, AdminAuditLogUncheckedCreateInput>
  }

  /**
   * AdminAuditLog createMany
   */
  export type AdminAuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminAuditLogs.
     */
    data: AdminAuditLogCreateManyInput | AdminAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminAuditLog createManyAndReturn
   */
  export type AdminAuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminAuditLogs.
     */
    data: AdminAuditLogCreateManyInput | AdminAuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAuditLog update
   */
  export type AdminAuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminAuditLog.
     */
    data: XOR<AdminAuditLogUpdateInput, AdminAuditLogUncheckedUpdateInput>
    /**
     * Choose, which AdminAuditLog to update.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog updateMany
   */
  export type AdminAuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminAuditLogs.
     */
    data: XOR<AdminAuditLogUpdateManyMutationInput, AdminAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AdminAuditLogs to update
     */
    where?: AdminAuditLogWhereInput
  }

  /**
   * AdminAuditLog upsert
   */
  export type AdminAuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminAuditLog to update in case it exists.
     */
    where: AdminAuditLogWhereUniqueInput
    /**
     * In case the AdminAuditLog found by the `where` argument doesn't exist, create a new AdminAuditLog with this data.
     */
    create: XOR<AdminAuditLogCreateInput, AdminAuditLogUncheckedCreateInput>
    /**
     * In case the AdminAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminAuditLogUpdateInput, AdminAuditLogUncheckedUpdateInput>
  }

  /**
   * AdminAuditLog delete
   */
  export type AdminAuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter which AdminAuditLog to delete.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog deleteMany
   */
  export type AdminAuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAuditLogs to delete
     */
    where?: AdminAuditLogWhereInput
  }

  /**
   * AdminAuditLog without action
   */
  export type AdminAuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
  }


  /**
   * Model SubscriptionPlan
   */

  export type AggregateSubscriptionPlan = {
    _count: SubscriptionPlanCountAggregateOutputType | null
    _avg: SubscriptionPlanAvgAggregateOutputType | null
    _sum: SubscriptionPlanSumAggregateOutputType | null
    _min: SubscriptionPlanMinAggregateOutputType | null
    _max: SubscriptionPlanMaxAggregateOutputType | null
  }

  export type SubscriptionPlanAvgAggregateOutputType = {
    priceMonthly: Decimal | null
    priceAnnual: Decimal | null
    trialDays: number | null
    displayOrder: number | null
  }

  export type SubscriptionPlanSumAggregateOutputType = {
    priceMonthly: Decimal | null
    priceAnnual: Decimal | null
    trialDays: number | null
    displayOrder: number | null
  }

  export type SubscriptionPlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    priceMonthly: Decimal | null
    priceAnnual: Decimal | null
    currency: string | null
    stripePriceIdMonthly: string | null
    stripePriceIdAnnual: string | null
    stripeProductId: string | null
    trialDays: number | null
    isActive: boolean | null
    isDefault: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionPlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    priceMonthly: Decimal | null
    priceAnnual: Decimal | null
    currency: string | null
    stripePriceIdMonthly: string | null
    stripePriceIdAnnual: string | null
    stripeProductId: string | null
    trialDays: number | null
    isActive: boolean | null
    isDefault: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionPlanCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    priceMonthly: number
    priceAnnual: number
    currency: number
    stripePriceIdMonthly: number
    stripePriceIdAnnual: number
    stripeProductId: number
    features: number
    limits: number
    trialDays: number
    isActive: number
    isDefault: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionPlanAvgAggregateInputType = {
    priceMonthly?: true
    priceAnnual?: true
    trialDays?: true
    displayOrder?: true
  }

  export type SubscriptionPlanSumAggregateInputType = {
    priceMonthly?: true
    priceAnnual?: true
    trialDays?: true
    displayOrder?: true
  }

  export type SubscriptionPlanMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    priceMonthly?: true
    priceAnnual?: true
    currency?: true
    stripePriceIdMonthly?: true
    stripePriceIdAnnual?: true
    stripeProductId?: true
    trialDays?: true
    isActive?: true
    isDefault?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionPlanMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    priceMonthly?: true
    priceAnnual?: true
    currency?: true
    stripePriceIdMonthly?: true
    stripePriceIdAnnual?: true
    stripeProductId?: true
    trialDays?: true
    isActive?: true
    isDefault?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionPlanCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    priceMonthly?: true
    priceAnnual?: true
    currency?: true
    stripePriceIdMonthly?: true
    stripePriceIdAnnual?: true
    stripeProductId?: true
    features?: true
    limits?: true
    trialDays?: true
    isActive?: true
    isDefault?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlan to aggregate.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionPlans
    **/
    _count?: true | SubscriptionPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionPlanMaxAggregateInputType
  }

  export type GetSubscriptionPlanAggregateType<T extends SubscriptionPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionPlan[P]>
      : GetScalarType<T[P], AggregateSubscriptionPlan[P]>
  }




  export type SubscriptionPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionPlanWhereInput
    orderBy?: SubscriptionPlanOrderByWithAggregationInput | SubscriptionPlanOrderByWithAggregationInput[]
    by: SubscriptionPlanScalarFieldEnum[] | SubscriptionPlanScalarFieldEnum
    having?: SubscriptionPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionPlanCountAggregateInputType | true
    _avg?: SubscriptionPlanAvgAggregateInputType
    _sum?: SubscriptionPlanSumAggregateInputType
    _min?: SubscriptionPlanMinAggregateInputType
    _max?: SubscriptionPlanMaxAggregateInputType
  }

  export type SubscriptionPlanGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    priceMonthly: Decimal | null
    priceAnnual: Decimal | null
    currency: string
    stripePriceIdMonthly: string | null
    stripePriceIdAnnual: string | null
    stripeProductId: string | null
    features: JsonValue
    limits: JsonValue
    trialDays: number
    isActive: boolean
    isDefault: boolean
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionPlanCountAggregateOutputType | null
    _avg: SubscriptionPlanAvgAggregateOutputType | null
    _sum: SubscriptionPlanSumAggregateOutputType | null
    _min: SubscriptionPlanMinAggregateOutputType | null
    _max: SubscriptionPlanMaxAggregateOutputType | null
  }

  type GetSubscriptionPlanGroupByPayload<T extends SubscriptionPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    priceMonthly?: boolean
    priceAnnual?: boolean
    currency?: boolean
    stripePriceIdMonthly?: boolean
    stripePriceIdAnnual?: boolean
    stripeProductId?: boolean
    features?: boolean
    limits?: boolean
    trialDays?: boolean
    isActive?: boolean
    isDefault?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptions?: boolean | SubscriptionPlan$subscriptionsArgs<ExtArgs>
    _count?: boolean | SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    priceMonthly?: boolean
    priceAnnual?: boolean
    currency?: boolean
    stripePriceIdMonthly?: boolean
    stripePriceIdAnnual?: boolean
    stripeProductId?: boolean
    features?: boolean
    limits?: boolean
    trialDays?: boolean
    isActive?: boolean
    isDefault?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    priceMonthly?: boolean
    priceAnnual?: boolean
    currency?: boolean
    stripePriceIdMonthly?: boolean
    stripePriceIdAnnual?: boolean
    stripeProductId?: boolean
    features?: boolean
    limits?: boolean
    trialDays?: boolean
    isActive?: boolean
    isDefault?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | SubscriptionPlan$subscriptionsArgs<ExtArgs>
    _count?: boolean | SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SubscriptionPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionPlan"
    objects: {
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      priceMonthly: Prisma.Decimal | null
      priceAnnual: Prisma.Decimal | null
      currency: string
      stripePriceIdMonthly: string | null
      stripePriceIdAnnual: string | null
      stripeProductId: string | null
      features: Prisma.JsonValue
      limits: Prisma.JsonValue
      trialDays: number
      isActive: boolean
      isDefault: boolean
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscriptionPlan"]>
    composites: {}
  }

  type SubscriptionPlanGetPayload<S extends boolean | null | undefined | SubscriptionPlanDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPlanPayload, S>

  type SubscriptionPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionPlanCountAggregateInputType | true
    }

  export interface SubscriptionPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionPlan'], meta: { name: 'SubscriptionPlan' } }
    /**
     * Find zero or one SubscriptionPlan that matches the filter.
     * @param {SubscriptionPlanFindUniqueArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionPlanFindUniqueArgs>(args: SelectSubset<T, SubscriptionPlanFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SubscriptionPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionPlanFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SubscriptionPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionPlanFindFirstArgs>(args?: SelectSubset<T, SubscriptionPlanFindFirstArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SubscriptionPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SubscriptionPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
     * 
     * // Get first 10 SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionPlanFindManyArgs>(args?: SelectSubset<T, SubscriptionPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SubscriptionPlan.
     * @param {SubscriptionPlanCreateArgs} args - Arguments to create a SubscriptionPlan.
     * @example
     * // Create one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.create({
     *   data: {
     *     // ... data to create a SubscriptionPlan
     *   }
     * })
     * 
     */
    create<T extends SubscriptionPlanCreateArgs>(args: SelectSubset<T, SubscriptionPlanCreateArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SubscriptionPlans.
     * @param {SubscriptionPlanCreateManyArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionPlanCreateManyArgs>(args?: SelectSubset<T, SubscriptionPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionPlans and returns the data saved in the database.
     * @param {SubscriptionPlanCreateManyAndReturnArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionPlans and only return the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SubscriptionPlan.
     * @param {SubscriptionPlanDeleteArgs} args - Arguments to delete one SubscriptionPlan.
     * @example
     * // Delete one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionPlan
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionPlanDeleteArgs>(args: SelectSubset<T, SubscriptionPlanDeleteArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SubscriptionPlan.
     * @param {SubscriptionPlanUpdateArgs} args - Arguments to update one SubscriptionPlan.
     * @example
     * // Update one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionPlanUpdateArgs>(args: SelectSubset<T, SubscriptionPlanUpdateArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SubscriptionPlans.
     * @param {SubscriptionPlanDeleteManyArgs} args - Arguments to filter SubscriptionPlans to delete.
     * @example
     * // Delete a few SubscriptionPlans
     * const { count } = await prisma.subscriptionPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionPlanDeleteManyArgs>(args?: SelectSubset<T, SubscriptionPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionPlanUpdateManyArgs>(args: SelectSubset<T, SubscriptionPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubscriptionPlan.
     * @param {SubscriptionPlanUpsertArgs} args - Arguments to update or create a SubscriptionPlan.
     * @example
     * // Update or create a SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.upsert({
     *   create: {
     *     // ... data to create a SubscriptionPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionPlan we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionPlanUpsertArgs>(args: SelectSubset<T, SubscriptionPlanUpsertArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanCountArgs} args - Arguments to filter SubscriptionPlans to count.
     * @example
     * // Count the number of SubscriptionPlans
     * const count = await prisma.subscriptionPlan.count({
     *   where: {
     *     // ... the filter for the SubscriptionPlans we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionPlanCountArgs>(
      args?: Subset<T, SubscriptionPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionPlanAggregateArgs>(args: Subset<T, SubscriptionPlanAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionPlanAggregateType<T>>

    /**
     * Group by SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionPlanGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionPlan model
   */
  readonly fields: SubscriptionPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptions<T extends SubscriptionPlan$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlan$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionPlan model
   */ 
  interface SubscriptionPlanFieldRefs {
    readonly id: FieldRef<"SubscriptionPlan", 'String'>
    readonly name: FieldRef<"SubscriptionPlan", 'String'>
    readonly slug: FieldRef<"SubscriptionPlan", 'String'>
    readonly description: FieldRef<"SubscriptionPlan", 'String'>
    readonly priceMonthly: FieldRef<"SubscriptionPlan", 'Decimal'>
    readonly priceAnnual: FieldRef<"SubscriptionPlan", 'Decimal'>
    readonly currency: FieldRef<"SubscriptionPlan", 'String'>
    readonly stripePriceIdMonthly: FieldRef<"SubscriptionPlan", 'String'>
    readonly stripePriceIdAnnual: FieldRef<"SubscriptionPlan", 'String'>
    readonly stripeProductId: FieldRef<"SubscriptionPlan", 'String'>
    readonly features: FieldRef<"SubscriptionPlan", 'Json'>
    readonly limits: FieldRef<"SubscriptionPlan", 'Json'>
    readonly trialDays: FieldRef<"SubscriptionPlan", 'Int'>
    readonly isActive: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly isDefault: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly displayOrder: FieldRef<"SubscriptionPlan", 'Int'>
    readonly createdAt: FieldRef<"SubscriptionPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"SubscriptionPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionPlan findUnique
   */
  export type SubscriptionPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan findUniqueOrThrow
   */
  export type SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan findFirst
   */
  export type SubscriptionPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan findFirstOrThrow
   */
  export type SubscriptionPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan findMany
   */
  export type SubscriptionPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlans to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan create
   */
  export type SubscriptionPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionPlan.
     */
    data: XOR<SubscriptionPlanCreateInput, SubscriptionPlanUncheckedCreateInput>
  }

  /**
   * SubscriptionPlan createMany
   */
  export type SubscriptionPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPlan createManyAndReturn
   */
  export type SubscriptionPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPlan update
   */
  export type SubscriptionPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionPlan.
     */
    data: XOR<SubscriptionPlanUpdateInput, SubscriptionPlanUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionPlan to update.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan updateMany
   */
  export type SubscriptionPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionPlans.
     */
    data: XOR<SubscriptionPlanUpdateManyMutationInput, SubscriptionPlanUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionPlans to update
     */
    where?: SubscriptionPlanWhereInput
  }

  /**
   * SubscriptionPlan upsert
   */
  export type SubscriptionPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionPlan to update in case it exists.
     */
    where: SubscriptionPlanWhereUniqueInput
    /**
     * In case the SubscriptionPlan found by the `where` argument doesn't exist, create a new SubscriptionPlan with this data.
     */
    create: XOR<SubscriptionPlanCreateInput, SubscriptionPlanUncheckedCreateInput>
    /**
     * In case the SubscriptionPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionPlanUpdateInput, SubscriptionPlanUncheckedUpdateInput>
  }

  /**
   * SubscriptionPlan delete
   */
  export type SubscriptionPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter which SubscriptionPlan to delete.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan deleteMany
   */
  export type SubscriptionPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlans to delete
     */
    where?: SubscriptionPlanWhereInput
  }

  /**
   * SubscriptionPlan.subscriptions
   */
  export type SubscriptionPlan$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan without action
   */
  export type SubscriptionPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    planId: string | null
    stripeSubscriptionId: string | null
    stripeCustomerId: string | null
    billingCycle: $Enums.BillingCycle | null
    status: $Enums.SubscriptionStatus | null
    trialEndsAt: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    cancelledAt: Date | null
    cancelReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    planId: string | null
    stripeSubscriptionId: string | null
    stripeCustomerId: string | null
    billingCycle: $Enums.BillingCycle | null
    status: $Enums.SubscriptionStatus | null
    trialEndsAt: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    cancelledAt: Date | null
    cancelReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    planId: number
    stripeSubscriptionId: number
    stripeCustomerId: number
    billingCycle: number
    status: number
    trialEndsAt: number
    currentPeriodStart: number
    currentPeriodEnd: number
    cancelAtPeriodEnd: number
    cancelledAt: number
    cancelReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    stripeSubscriptionId?: true
    stripeCustomerId?: true
    billingCycle?: true
    status?: true
    trialEndsAt?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    cancelledAt?: true
    cancelReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    stripeSubscriptionId?: true
    stripeCustomerId?: true
    billingCycle?: true
    status?: true
    trialEndsAt?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    cancelledAt?: true
    cancelReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    stripeSubscriptionId?: true
    stripeCustomerId?: true
    billingCycle?: true
    status?: true
    trialEndsAt?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    cancelledAt?: true
    cancelReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    userId: string
    planId: string
    stripeSubscriptionId: string | null
    stripeCustomerId: string | null
    billingCycle: $Enums.BillingCycle
    status: $Enums.SubscriptionStatus
    trialEndsAt: Date | null
    currentPeriodStart: Date
    currentPeriodEnd: Date
    cancelAtPeriodEnd: boolean
    cancelledAt: Date | null
    cancelReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    stripeSubscriptionId?: boolean
    stripeCustomerId?: boolean
    billingCycle?: boolean
    status?: boolean
    trialEndsAt?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    cancelledAt?: boolean
    cancelReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    payments?: boolean | Subscription$paymentsArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    stripeSubscriptionId?: boolean
    stripeCustomerId?: boolean
    billingCycle?: boolean
    status?: boolean
    trialEndsAt?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    cancelledAt?: boolean
    cancelReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    planId?: boolean
    stripeSubscriptionId?: boolean
    stripeCustomerId?: boolean
    billingCycle?: boolean
    status?: boolean
    trialEndsAt?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    cancelledAt?: boolean
    cancelReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    payments?: boolean | Subscription$paymentsArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      plan: Prisma.$SubscriptionPlanPayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      planId: string
      stripeSubscriptionId: string | null
      stripeCustomerId: string | null
      billingCycle: $Enums.BillingCycle
      status: $Enums.SubscriptionStatus
      trialEndsAt: Date | null
      currentPeriodStart: Date
      currentPeriodEnd: Date
      cancelAtPeriodEnd: boolean
      cancelledAt: Date | null
      cancelReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    plan<T extends SubscriptionPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlanDefaultArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payments<T extends Subscription$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */ 
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly userId: FieldRef<"Subscription", 'String'>
    readonly planId: FieldRef<"Subscription", 'String'>
    readonly stripeSubscriptionId: FieldRef<"Subscription", 'String'>
    readonly stripeCustomerId: FieldRef<"Subscription", 'String'>
    readonly billingCycle: FieldRef<"Subscription", 'BillingCycle'>
    readonly status: FieldRef<"Subscription", 'SubscriptionStatus'>
    readonly trialEndsAt: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodStart: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"Subscription", 'DateTime'>
    readonly cancelAtPeriodEnd: FieldRef<"Subscription", 'Boolean'>
    readonly cancelledAt: FieldRef<"Subscription", 'DateTime'>
    readonly cancelReason: FieldRef<"Subscription", 'String'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription.payments
   */
  export type Subscription$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    subscriptionId: string | null
    stripePaymentIntentId: string | null
    stripeChargeId: string | null
    stripeInvoiceId: string | null
    amount: Decimal | null
    currency: string | null
    paymentMethod: $Enums.PaymentMethodType | null
    last4: string | null
    cardBrand: string | null
    oxxoVoucherUrl: string | null
    oxxoExpiresAt: Date | null
    status: $Enums.PaymentStatus | null
    description: string | null
    failureCode: string | null
    failureMessage: string | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    subscriptionId: string | null
    stripePaymentIntentId: string | null
    stripeChargeId: string | null
    stripeInvoiceId: string | null
    amount: Decimal | null
    currency: string | null
    paymentMethod: $Enums.PaymentMethodType | null
    last4: string | null
    cardBrand: string | null
    oxxoVoucherUrl: string | null
    oxxoExpiresAt: Date | null
    status: $Enums.PaymentStatus | null
    description: string | null
    failureCode: string | null
    failureMessage: string | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    userId: number
    subscriptionId: number
    stripePaymentIntentId: number
    stripeChargeId: number
    stripeInvoiceId: number
    amount: number
    currency: number
    paymentMethod: number
    last4: number
    cardBrand: number
    oxxoVoucherUrl: number
    oxxoExpiresAt: number
    status: number
    description: number
    failureCode: number
    failureMessage: number
    paidAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    userId?: true
    subscriptionId?: true
    stripePaymentIntentId?: true
    stripeChargeId?: true
    stripeInvoiceId?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    last4?: true
    cardBrand?: true
    oxxoVoucherUrl?: true
    oxxoExpiresAt?: true
    status?: true
    description?: true
    failureCode?: true
    failureMessage?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    userId?: true
    subscriptionId?: true
    stripePaymentIntentId?: true
    stripeChargeId?: true
    stripeInvoiceId?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    last4?: true
    cardBrand?: true
    oxxoVoucherUrl?: true
    oxxoExpiresAt?: true
    status?: true
    description?: true
    failureCode?: true
    failureMessage?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    userId?: true
    subscriptionId?: true
    stripePaymentIntentId?: true
    stripeChargeId?: true
    stripeInvoiceId?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    last4?: true
    cardBrand?: true
    oxxoVoucherUrl?: true
    oxxoExpiresAt?: true
    status?: true
    description?: true
    failureCode?: true
    failureMessage?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    userId: string
    subscriptionId: string | null
    stripePaymentIntentId: string | null
    stripeChargeId: string | null
    stripeInvoiceId: string | null
    amount: Decimal
    currency: string
    paymentMethod: $Enums.PaymentMethodType
    last4: string | null
    cardBrand: string | null
    oxxoVoucherUrl: string | null
    oxxoExpiresAt: Date | null
    status: $Enums.PaymentStatus
    description: string | null
    failureCode: string | null
    failureMessage: string | null
    paidAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subscriptionId?: boolean
    stripePaymentIntentId?: boolean
    stripeChargeId?: boolean
    stripeInvoiceId?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    last4?: boolean
    cardBrand?: boolean
    oxxoVoucherUrl?: boolean
    oxxoExpiresAt?: boolean
    status?: boolean
    description?: boolean
    failureCode?: boolean
    failureMessage?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | Payment$subscriptionArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subscriptionId?: boolean
    stripePaymentIntentId?: boolean
    stripeChargeId?: boolean
    stripeInvoiceId?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    last4?: boolean
    cardBrand?: boolean
    oxxoVoucherUrl?: boolean
    oxxoExpiresAt?: boolean
    status?: boolean
    description?: boolean
    failureCode?: boolean
    failureMessage?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | Payment$subscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    userId?: boolean
    subscriptionId?: boolean
    stripePaymentIntentId?: boolean
    stripeChargeId?: boolean
    stripeInvoiceId?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    last4?: boolean
    cardBrand?: boolean
    oxxoVoucherUrl?: boolean
    oxxoExpiresAt?: boolean
    status?: boolean
    description?: boolean
    failureCode?: boolean
    failureMessage?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | Payment$subscriptionArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | Payment$subscriptionArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      subscriptionId: string | null
      stripePaymentIntentId: string | null
      stripeChargeId: string | null
      stripeInvoiceId: string | null
      amount: Prisma.Decimal
      currency: string
      paymentMethod: $Enums.PaymentMethodType
      last4: string | null
      cardBrand: string | null
      oxxoVoucherUrl: string | null
      oxxoExpiresAt: Date | null
      status: $Enums.PaymentStatus
      description: string | null
      failureCode: string | null
      failureMessage: string | null
      paidAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subscription<T extends Payment$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Payment$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    invoice<T extends Payment$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Payment$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly userId: FieldRef<"Payment", 'String'>
    readonly subscriptionId: FieldRef<"Payment", 'String'>
    readonly stripePaymentIntentId: FieldRef<"Payment", 'String'>
    readonly stripeChargeId: FieldRef<"Payment", 'String'>
    readonly stripeInvoiceId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly paymentMethod: FieldRef<"Payment", 'PaymentMethodType'>
    readonly last4: FieldRef<"Payment", 'String'>
    readonly cardBrand: FieldRef<"Payment", 'String'>
    readonly oxxoVoucherUrl: FieldRef<"Payment", 'String'>
    readonly oxxoExpiresAt: FieldRef<"Payment", 'DateTime'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly description: FieldRef<"Payment", 'String'>
    readonly failureCode: FieldRef<"Payment", 'String'>
    readonly failureMessage: FieldRef<"Payment", 'String'>
    readonly paidAt: FieldRef<"Payment", 'DateTime'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment.subscription
   */
  export type Payment$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * Payment.invoice
   */
  export type Payment$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model PaymentMethod
   */

  export type AggregatePaymentMethod = {
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  export type PaymentMethodAvgAggregateOutputType = {
    expMonth: number | null
    expYear: number | null
  }

  export type PaymentMethodSumAggregateOutputType = {
    expMonth: number | null
    expYear: number | null
  }

  export type PaymentMethodMinAggregateOutputType = {
    id: string | null
    userId: string | null
    stripePaymentMethodId: string | null
    type: $Enums.PaymentMethodType | null
    last4: string | null
    brand: string | null
    expMonth: number | null
    expYear: number | null
    cardholderName: string | null
    isDefault: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    stripePaymentMethodId: string | null
    type: $Enums.PaymentMethodType | null
    last4: string | null
    brand: string | null
    expMonth: number | null
    expYear: number | null
    cardholderName: string | null
    isDefault: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodCountAggregateOutputType = {
    id: number
    userId: number
    stripePaymentMethodId: number
    type: number
    last4: number
    brand: number
    expMonth: number
    expYear: number
    cardholderName: number
    isDefault: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentMethodAvgAggregateInputType = {
    expMonth?: true
    expYear?: true
  }

  export type PaymentMethodSumAggregateInputType = {
    expMonth?: true
    expYear?: true
  }

  export type PaymentMethodMinAggregateInputType = {
    id?: true
    userId?: true
    stripePaymentMethodId?: true
    type?: true
    last4?: true
    brand?: true
    expMonth?: true
    expYear?: true
    cardholderName?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodMaxAggregateInputType = {
    id?: true
    userId?: true
    stripePaymentMethodId?: true
    type?: true
    last4?: true
    brand?: true
    expMonth?: true
    expYear?: true
    cardholderName?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodCountAggregateInputType = {
    id?: true
    userId?: true
    stripePaymentMethodId?: true
    type?: true
    last4?: true
    brand?: true
    expMonth?: true
    expYear?: true
    cardholderName?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethod to aggregate.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentMethods
    **/
    _count?: true | PaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentMethodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentMethodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type GetPaymentMethodAggregateType<T extends PaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentMethod[P]>
      : GetScalarType<T[P], AggregatePaymentMethod[P]>
  }




  export type PaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithAggregationInput | PaymentMethodOrderByWithAggregationInput[]
    by: PaymentMethodScalarFieldEnum[] | PaymentMethodScalarFieldEnum
    having?: PaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentMethodCountAggregateInputType | true
    _avg?: PaymentMethodAvgAggregateInputType
    _sum?: PaymentMethodSumAggregateInputType
    _min?: PaymentMethodMinAggregateInputType
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type PaymentMethodGroupByOutputType = {
    id: string
    userId: string
    stripePaymentMethodId: string
    type: $Enums.PaymentMethodType
    last4: string
    brand: string
    expMonth: number
    expYear: number
    cardholderName: string | null
    isDefault: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  type GetPaymentMethodGroupByPayload<T extends PaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type PaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripePaymentMethodId?: boolean
    type?: boolean
    last4?: boolean
    brand?: boolean
    expMonth?: boolean
    expYear?: boolean
    cardholderName?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripePaymentMethodId?: boolean
    type?: boolean
    last4?: boolean
    brand?: boolean
    expMonth?: boolean
    expYear?: boolean
    cardholderName?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectScalar = {
    id?: boolean
    userId?: boolean
    stripePaymentMethodId?: boolean
    type?: boolean
    last4?: boolean
    brand?: boolean
    expMonth?: boolean
    expYear?: boolean
    cardholderName?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentMethodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaymentMethodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentMethod"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      stripePaymentMethodId: string
      type: $Enums.PaymentMethodType
      last4: string
      brand: string
      expMonth: number
      expYear: number
      cardholderName: string | null
      isDefault: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentMethod"]>
    composites: {}
  }

  type PaymentMethodGetPayload<S extends boolean | null | undefined | PaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$PaymentMethodPayload, S>

  type PaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentMethodFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentMethodCountAggregateInputType | true
    }

  export interface PaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentMethod'], meta: { name: 'PaymentMethod' } }
    /**
     * Find zero or one PaymentMethod that matches the filter.
     * @param {PaymentMethodFindUniqueArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentMethodFindUniqueArgs>(args: SelectSubset<T, PaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PaymentMethod that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentMethodFindFirstArgs>(args?: SelectSubset<T, PaymentMethodFindFirstArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany()
     * 
     * // Get first 10 PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentMethodFindManyArgs>(args?: SelectSubset<T, PaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PaymentMethod.
     * @param {PaymentMethodCreateArgs} args - Arguments to create a PaymentMethod.
     * @example
     * // Create one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.create({
     *   data: {
     *     // ... data to create a PaymentMethod
     *   }
     * })
     * 
     */
    create<T extends PaymentMethodCreateArgs>(args: SelectSubset<T, PaymentMethodCreateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PaymentMethods.
     * @param {PaymentMethodCreateManyArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentMethodCreateManyArgs>(args?: SelectSubset<T, PaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentMethods and returns the data saved in the database.
     * @param {PaymentMethodCreateManyAndReturnArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentMethodCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentMethodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PaymentMethod.
     * @param {PaymentMethodDeleteArgs} args - Arguments to delete one PaymentMethod.
     * @example
     * // Delete one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.delete({
     *   where: {
     *     // ... filter to delete one PaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends PaymentMethodDeleteArgs>(args: SelectSubset<T, PaymentMethodDeleteArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PaymentMethod.
     * @param {PaymentMethodUpdateArgs} args - Arguments to update one PaymentMethod.
     * @example
     * // Update one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentMethodUpdateArgs>(args: SelectSubset<T, PaymentMethodUpdateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PaymentMethods.
     * @param {PaymentMethodDeleteManyArgs} args - Arguments to filter PaymentMethods to delete.
     * @example
     * // Delete a few PaymentMethods
     * const { count } = await prisma.paymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentMethodDeleteManyArgs>(args?: SelectSubset<T, PaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentMethodUpdateManyArgs>(args: SelectSubset<T, PaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentMethod.
     * @param {PaymentMethodUpsertArgs} args - Arguments to update or create a PaymentMethod.
     * @example
     * // Update or create a PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.upsert({
     *   create: {
     *     // ... data to create a PaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends PaymentMethodUpsertArgs>(args: SelectSubset<T, PaymentMethodUpsertArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodCountArgs} args - Arguments to filter PaymentMethods to count.
     * @example
     * // Count the number of PaymentMethods
     * const count = await prisma.paymentMethod.count({
     *   where: {
     *     // ... the filter for the PaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends PaymentMethodCountArgs>(
      args?: Subset<T, PaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentMethodAggregateArgs>(args: Subset<T, PaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetPaymentMethodAggregateType<T>>

    /**
     * Group by PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: PaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentMethod model
   */
  readonly fields: PaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentMethod model
   */ 
  interface PaymentMethodFieldRefs {
    readonly id: FieldRef<"PaymentMethod", 'String'>
    readonly userId: FieldRef<"PaymentMethod", 'String'>
    readonly stripePaymentMethodId: FieldRef<"PaymentMethod", 'String'>
    readonly type: FieldRef<"PaymentMethod", 'PaymentMethodType'>
    readonly last4: FieldRef<"PaymentMethod", 'String'>
    readonly brand: FieldRef<"PaymentMethod", 'String'>
    readonly expMonth: FieldRef<"PaymentMethod", 'Int'>
    readonly expYear: FieldRef<"PaymentMethod", 'Int'>
    readonly cardholderName: FieldRef<"PaymentMethod", 'String'>
    readonly isDefault: FieldRef<"PaymentMethod", 'Boolean'>
    readonly isActive: FieldRef<"PaymentMethod", 'Boolean'>
    readonly createdAt: FieldRef<"PaymentMethod", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentMethod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentMethod findUnique
   */
  export type PaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findUniqueOrThrow
   */
  export type PaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findFirst
   */
  export type PaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findFirstOrThrow
   */
  export type PaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findMany
   */
  export type PaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethods to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod create
   */
  export type PaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentMethod.
     */
    data: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
  }

  /**
   * PaymentMethod createMany
   */
  export type PaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod createManyAndReturn
   */
  export type PaymentMethodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentMethod update
   */
  export type PaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentMethod.
     */
    data: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which PaymentMethod to update.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod updateMany
   */
  export type PaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
  }

  /**
   * PaymentMethod upsert
   */
  export type PaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentMethod to update in case it exists.
     */
    where: PaymentMethodWhereUniqueInput
    /**
     * In case the PaymentMethod found by the `where` argument doesn't exist, create a new PaymentMethod with this data.
     */
    create: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
    /**
     * In case the PaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
  }

  /**
   * PaymentMethod delete
   */
  export type PaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter which PaymentMethod to delete.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod deleteMany
   */
  export type PaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethods to delete
     */
    where?: PaymentMethodWhereInput
  }

  /**
   * PaymentMethod without action
   */
  export type PaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
  }


  /**
   * Model FiscalData
   */

  export type AggregateFiscalData = {
    _count: FiscalDataCountAggregateOutputType | null
    _min: FiscalDataMinAggregateOutputType | null
    _max: FiscalDataMaxAggregateOutputType | null
  }

  export type FiscalDataMinAggregateOutputType = {
    id: string | null
    userId: string | null
    rfc: string | null
    razonSocial: string | null
    regimenFiscal: string | null
    usoCFDI: string | null
    codigoPostal: string | null
    calle: string | null
    numExterior: string | null
    numInterior: string | null
    colonia: string | null
    municipio: string | null
    estado: string | null
    emailFacturacion: string | null
    facturamaClientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FiscalDataMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    rfc: string | null
    razonSocial: string | null
    regimenFiscal: string | null
    usoCFDI: string | null
    codigoPostal: string | null
    calle: string | null
    numExterior: string | null
    numInterior: string | null
    colonia: string | null
    municipio: string | null
    estado: string | null
    emailFacturacion: string | null
    facturamaClientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FiscalDataCountAggregateOutputType = {
    id: number
    userId: number
    rfc: number
    razonSocial: number
    regimenFiscal: number
    usoCFDI: number
    codigoPostal: number
    calle: number
    numExterior: number
    numInterior: number
    colonia: number
    municipio: number
    estado: number
    emailFacturacion: number
    facturamaClientId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FiscalDataMinAggregateInputType = {
    id?: true
    userId?: true
    rfc?: true
    razonSocial?: true
    regimenFiscal?: true
    usoCFDI?: true
    codigoPostal?: true
    calle?: true
    numExterior?: true
    numInterior?: true
    colonia?: true
    municipio?: true
    estado?: true
    emailFacturacion?: true
    facturamaClientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FiscalDataMaxAggregateInputType = {
    id?: true
    userId?: true
    rfc?: true
    razonSocial?: true
    regimenFiscal?: true
    usoCFDI?: true
    codigoPostal?: true
    calle?: true
    numExterior?: true
    numInterior?: true
    colonia?: true
    municipio?: true
    estado?: true
    emailFacturacion?: true
    facturamaClientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FiscalDataCountAggregateInputType = {
    id?: true
    userId?: true
    rfc?: true
    razonSocial?: true
    regimenFiscal?: true
    usoCFDI?: true
    codigoPostal?: true
    calle?: true
    numExterior?: true
    numInterior?: true
    colonia?: true
    municipio?: true
    estado?: true
    emailFacturacion?: true
    facturamaClientId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FiscalDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FiscalData to aggregate.
     */
    where?: FiscalDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiscalData to fetch.
     */
    orderBy?: FiscalDataOrderByWithRelationInput | FiscalDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FiscalDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiscalData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiscalData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FiscalData
    **/
    _count?: true | FiscalDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FiscalDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FiscalDataMaxAggregateInputType
  }

  export type GetFiscalDataAggregateType<T extends FiscalDataAggregateArgs> = {
        [P in keyof T & keyof AggregateFiscalData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFiscalData[P]>
      : GetScalarType<T[P], AggregateFiscalData[P]>
  }




  export type FiscalDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FiscalDataWhereInput
    orderBy?: FiscalDataOrderByWithAggregationInput | FiscalDataOrderByWithAggregationInput[]
    by: FiscalDataScalarFieldEnum[] | FiscalDataScalarFieldEnum
    having?: FiscalDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FiscalDataCountAggregateInputType | true
    _min?: FiscalDataMinAggregateInputType
    _max?: FiscalDataMaxAggregateInputType
  }

  export type FiscalDataGroupByOutputType = {
    id: string
    userId: string
    rfc: string
    razonSocial: string
    regimenFiscal: string
    usoCFDI: string
    codigoPostal: string
    calle: string | null
    numExterior: string | null
    numInterior: string | null
    colonia: string | null
    municipio: string | null
    estado: string | null
    emailFacturacion: string
    facturamaClientId: string | null
    createdAt: Date
    updatedAt: Date
    _count: FiscalDataCountAggregateOutputType | null
    _min: FiscalDataMinAggregateOutputType | null
    _max: FiscalDataMaxAggregateOutputType | null
  }

  type GetFiscalDataGroupByPayload<T extends FiscalDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FiscalDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FiscalDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FiscalDataGroupByOutputType[P]>
            : GetScalarType<T[P], FiscalDataGroupByOutputType[P]>
        }
      >
    >


  export type FiscalDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    rfc?: boolean
    razonSocial?: boolean
    regimenFiscal?: boolean
    usoCFDI?: boolean
    codigoPostal?: boolean
    calle?: boolean
    numExterior?: boolean
    numInterior?: boolean
    colonia?: boolean
    municipio?: boolean
    estado?: boolean
    emailFacturacion?: boolean
    facturamaClientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    invoices?: boolean | FiscalData$invoicesArgs<ExtArgs>
    _count?: boolean | FiscalDataCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fiscalData"]>

  export type FiscalDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    rfc?: boolean
    razonSocial?: boolean
    regimenFiscal?: boolean
    usoCFDI?: boolean
    codigoPostal?: boolean
    calle?: boolean
    numExterior?: boolean
    numInterior?: boolean
    colonia?: boolean
    municipio?: boolean
    estado?: boolean
    emailFacturacion?: boolean
    facturamaClientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fiscalData"]>

  export type FiscalDataSelectScalar = {
    id?: boolean
    userId?: boolean
    rfc?: boolean
    razonSocial?: boolean
    regimenFiscal?: boolean
    usoCFDI?: boolean
    codigoPostal?: boolean
    calle?: boolean
    numExterior?: boolean
    numInterior?: boolean
    colonia?: boolean
    municipio?: boolean
    estado?: boolean
    emailFacturacion?: boolean
    facturamaClientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FiscalDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    invoices?: boolean | FiscalData$invoicesArgs<ExtArgs>
    _count?: boolean | FiscalDataCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FiscalDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FiscalDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FiscalData"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      rfc: string
      razonSocial: string
      regimenFiscal: string
      usoCFDI: string
      codigoPostal: string
      calle: string | null
      numExterior: string | null
      numInterior: string | null
      colonia: string | null
      municipio: string | null
      estado: string | null
      emailFacturacion: string
      facturamaClientId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fiscalData"]>
    composites: {}
  }

  type FiscalDataGetPayload<S extends boolean | null | undefined | FiscalDataDefaultArgs> = $Result.GetResult<Prisma.$FiscalDataPayload, S>

  type FiscalDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FiscalDataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FiscalDataCountAggregateInputType | true
    }

  export interface FiscalDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FiscalData'], meta: { name: 'FiscalData' } }
    /**
     * Find zero or one FiscalData that matches the filter.
     * @param {FiscalDataFindUniqueArgs} args - Arguments to find a FiscalData
     * @example
     * // Get one FiscalData
     * const fiscalData = await prisma.fiscalData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FiscalDataFindUniqueArgs>(args: SelectSubset<T, FiscalDataFindUniqueArgs<ExtArgs>>): Prisma__FiscalDataClient<$Result.GetResult<Prisma.$FiscalDataPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FiscalData that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FiscalDataFindUniqueOrThrowArgs} args - Arguments to find a FiscalData
     * @example
     * // Get one FiscalData
     * const fiscalData = await prisma.fiscalData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FiscalDataFindUniqueOrThrowArgs>(args: SelectSubset<T, FiscalDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FiscalDataClient<$Result.GetResult<Prisma.$FiscalDataPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FiscalData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalDataFindFirstArgs} args - Arguments to find a FiscalData
     * @example
     * // Get one FiscalData
     * const fiscalData = await prisma.fiscalData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FiscalDataFindFirstArgs>(args?: SelectSubset<T, FiscalDataFindFirstArgs<ExtArgs>>): Prisma__FiscalDataClient<$Result.GetResult<Prisma.$FiscalDataPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FiscalData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalDataFindFirstOrThrowArgs} args - Arguments to find a FiscalData
     * @example
     * // Get one FiscalData
     * const fiscalData = await prisma.fiscalData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FiscalDataFindFirstOrThrowArgs>(args?: SelectSubset<T, FiscalDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__FiscalDataClient<$Result.GetResult<Prisma.$FiscalDataPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FiscalData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FiscalData
     * const fiscalData = await prisma.fiscalData.findMany()
     * 
     * // Get first 10 FiscalData
     * const fiscalData = await prisma.fiscalData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fiscalDataWithIdOnly = await prisma.fiscalData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FiscalDataFindManyArgs>(args?: SelectSubset<T, FiscalDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FiscalDataPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FiscalData.
     * @param {FiscalDataCreateArgs} args - Arguments to create a FiscalData.
     * @example
     * // Create one FiscalData
     * const FiscalData = await prisma.fiscalData.create({
     *   data: {
     *     // ... data to create a FiscalData
     *   }
     * })
     * 
     */
    create<T extends FiscalDataCreateArgs>(args: SelectSubset<T, FiscalDataCreateArgs<ExtArgs>>): Prisma__FiscalDataClient<$Result.GetResult<Prisma.$FiscalDataPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FiscalData.
     * @param {FiscalDataCreateManyArgs} args - Arguments to create many FiscalData.
     * @example
     * // Create many FiscalData
     * const fiscalData = await prisma.fiscalData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FiscalDataCreateManyArgs>(args?: SelectSubset<T, FiscalDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FiscalData and returns the data saved in the database.
     * @param {FiscalDataCreateManyAndReturnArgs} args - Arguments to create many FiscalData.
     * @example
     * // Create many FiscalData
     * const fiscalData = await prisma.fiscalData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FiscalData and only return the `id`
     * const fiscalDataWithIdOnly = await prisma.fiscalData.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FiscalDataCreateManyAndReturnArgs>(args?: SelectSubset<T, FiscalDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FiscalDataPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FiscalData.
     * @param {FiscalDataDeleteArgs} args - Arguments to delete one FiscalData.
     * @example
     * // Delete one FiscalData
     * const FiscalData = await prisma.fiscalData.delete({
     *   where: {
     *     // ... filter to delete one FiscalData
     *   }
     * })
     * 
     */
    delete<T extends FiscalDataDeleteArgs>(args: SelectSubset<T, FiscalDataDeleteArgs<ExtArgs>>): Prisma__FiscalDataClient<$Result.GetResult<Prisma.$FiscalDataPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FiscalData.
     * @param {FiscalDataUpdateArgs} args - Arguments to update one FiscalData.
     * @example
     * // Update one FiscalData
     * const fiscalData = await prisma.fiscalData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FiscalDataUpdateArgs>(args: SelectSubset<T, FiscalDataUpdateArgs<ExtArgs>>): Prisma__FiscalDataClient<$Result.GetResult<Prisma.$FiscalDataPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FiscalData.
     * @param {FiscalDataDeleteManyArgs} args - Arguments to filter FiscalData to delete.
     * @example
     * // Delete a few FiscalData
     * const { count } = await prisma.fiscalData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FiscalDataDeleteManyArgs>(args?: SelectSubset<T, FiscalDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FiscalData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FiscalData
     * const fiscalData = await prisma.fiscalData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FiscalDataUpdateManyArgs>(args: SelectSubset<T, FiscalDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FiscalData.
     * @param {FiscalDataUpsertArgs} args - Arguments to update or create a FiscalData.
     * @example
     * // Update or create a FiscalData
     * const fiscalData = await prisma.fiscalData.upsert({
     *   create: {
     *     // ... data to create a FiscalData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FiscalData we want to update
     *   }
     * })
     */
    upsert<T extends FiscalDataUpsertArgs>(args: SelectSubset<T, FiscalDataUpsertArgs<ExtArgs>>): Prisma__FiscalDataClient<$Result.GetResult<Prisma.$FiscalDataPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FiscalData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalDataCountArgs} args - Arguments to filter FiscalData to count.
     * @example
     * // Count the number of FiscalData
     * const count = await prisma.fiscalData.count({
     *   where: {
     *     // ... the filter for the FiscalData we want to count
     *   }
     * })
    **/
    count<T extends FiscalDataCountArgs>(
      args?: Subset<T, FiscalDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FiscalDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FiscalData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FiscalDataAggregateArgs>(args: Subset<T, FiscalDataAggregateArgs>): Prisma.PrismaPromise<GetFiscalDataAggregateType<T>>

    /**
     * Group by FiscalData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FiscalDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FiscalDataGroupByArgs['orderBy'] }
        : { orderBy?: FiscalDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FiscalDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFiscalDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FiscalData model
   */
  readonly fields: FiscalDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FiscalData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FiscalDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    invoices<T extends FiscalData$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, FiscalData$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FiscalData model
   */ 
  interface FiscalDataFieldRefs {
    readonly id: FieldRef<"FiscalData", 'String'>
    readonly userId: FieldRef<"FiscalData", 'String'>
    readonly rfc: FieldRef<"FiscalData", 'String'>
    readonly razonSocial: FieldRef<"FiscalData", 'String'>
    readonly regimenFiscal: FieldRef<"FiscalData", 'String'>
    readonly usoCFDI: FieldRef<"FiscalData", 'String'>
    readonly codigoPostal: FieldRef<"FiscalData", 'String'>
    readonly calle: FieldRef<"FiscalData", 'String'>
    readonly numExterior: FieldRef<"FiscalData", 'String'>
    readonly numInterior: FieldRef<"FiscalData", 'String'>
    readonly colonia: FieldRef<"FiscalData", 'String'>
    readonly municipio: FieldRef<"FiscalData", 'String'>
    readonly estado: FieldRef<"FiscalData", 'String'>
    readonly emailFacturacion: FieldRef<"FiscalData", 'String'>
    readonly facturamaClientId: FieldRef<"FiscalData", 'String'>
    readonly createdAt: FieldRef<"FiscalData", 'DateTime'>
    readonly updatedAt: FieldRef<"FiscalData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FiscalData findUnique
   */
  export type FiscalDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalData
     */
    select?: FiscalDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalDataInclude<ExtArgs> | null
    /**
     * Filter, which FiscalData to fetch.
     */
    where: FiscalDataWhereUniqueInput
  }

  /**
   * FiscalData findUniqueOrThrow
   */
  export type FiscalDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalData
     */
    select?: FiscalDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalDataInclude<ExtArgs> | null
    /**
     * Filter, which FiscalData to fetch.
     */
    where: FiscalDataWhereUniqueInput
  }

  /**
   * FiscalData findFirst
   */
  export type FiscalDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalData
     */
    select?: FiscalDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalDataInclude<ExtArgs> | null
    /**
     * Filter, which FiscalData to fetch.
     */
    where?: FiscalDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiscalData to fetch.
     */
    orderBy?: FiscalDataOrderByWithRelationInput | FiscalDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FiscalData.
     */
    cursor?: FiscalDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiscalData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiscalData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FiscalData.
     */
    distinct?: FiscalDataScalarFieldEnum | FiscalDataScalarFieldEnum[]
  }

  /**
   * FiscalData findFirstOrThrow
   */
  export type FiscalDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalData
     */
    select?: FiscalDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalDataInclude<ExtArgs> | null
    /**
     * Filter, which FiscalData to fetch.
     */
    where?: FiscalDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiscalData to fetch.
     */
    orderBy?: FiscalDataOrderByWithRelationInput | FiscalDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FiscalData.
     */
    cursor?: FiscalDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiscalData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiscalData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FiscalData.
     */
    distinct?: FiscalDataScalarFieldEnum | FiscalDataScalarFieldEnum[]
  }

  /**
   * FiscalData findMany
   */
  export type FiscalDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalData
     */
    select?: FiscalDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalDataInclude<ExtArgs> | null
    /**
     * Filter, which FiscalData to fetch.
     */
    where?: FiscalDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiscalData to fetch.
     */
    orderBy?: FiscalDataOrderByWithRelationInput | FiscalDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FiscalData.
     */
    cursor?: FiscalDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiscalData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiscalData.
     */
    skip?: number
    distinct?: FiscalDataScalarFieldEnum | FiscalDataScalarFieldEnum[]
  }

  /**
   * FiscalData create
   */
  export type FiscalDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalData
     */
    select?: FiscalDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalDataInclude<ExtArgs> | null
    /**
     * The data needed to create a FiscalData.
     */
    data: XOR<FiscalDataCreateInput, FiscalDataUncheckedCreateInput>
  }

  /**
   * FiscalData createMany
   */
  export type FiscalDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FiscalData.
     */
    data: FiscalDataCreateManyInput | FiscalDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FiscalData createManyAndReturn
   */
  export type FiscalDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalData
     */
    select?: FiscalDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FiscalData.
     */
    data: FiscalDataCreateManyInput | FiscalDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FiscalData update
   */
  export type FiscalDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalData
     */
    select?: FiscalDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalDataInclude<ExtArgs> | null
    /**
     * The data needed to update a FiscalData.
     */
    data: XOR<FiscalDataUpdateInput, FiscalDataUncheckedUpdateInput>
    /**
     * Choose, which FiscalData to update.
     */
    where: FiscalDataWhereUniqueInput
  }

  /**
   * FiscalData updateMany
   */
  export type FiscalDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FiscalData.
     */
    data: XOR<FiscalDataUpdateManyMutationInput, FiscalDataUncheckedUpdateManyInput>
    /**
     * Filter which FiscalData to update
     */
    where?: FiscalDataWhereInput
  }

  /**
   * FiscalData upsert
   */
  export type FiscalDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalData
     */
    select?: FiscalDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalDataInclude<ExtArgs> | null
    /**
     * The filter to search for the FiscalData to update in case it exists.
     */
    where: FiscalDataWhereUniqueInput
    /**
     * In case the FiscalData found by the `where` argument doesn't exist, create a new FiscalData with this data.
     */
    create: XOR<FiscalDataCreateInput, FiscalDataUncheckedCreateInput>
    /**
     * In case the FiscalData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FiscalDataUpdateInput, FiscalDataUncheckedUpdateInput>
  }

  /**
   * FiscalData delete
   */
  export type FiscalDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalData
     */
    select?: FiscalDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalDataInclude<ExtArgs> | null
    /**
     * Filter which FiscalData to delete.
     */
    where: FiscalDataWhereUniqueInput
  }

  /**
   * FiscalData deleteMany
   */
  export type FiscalDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FiscalData to delete
     */
    where?: FiscalDataWhereInput
  }

  /**
   * FiscalData.invoices
   */
  export type FiscalData$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * FiscalData without action
   */
  export type FiscalDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalData
     */
    select?: FiscalDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalDataInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    subtotal: Decimal | null
    iva: Decimal | null
    total: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    subtotal: Decimal | null
    iva: Decimal | null
    total: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    paymentId: string | null
    fiscalDataId: string | null
    facturamaInvoiceId: string | null
    uuid: string | null
    serie: string | null
    folio: string | null
    subtotal: Decimal | null
    iva: Decimal | null
    total: Decimal | null
    xmlUrl: string | null
    pdfUrl: string | null
    status: $Enums.InvoiceStatus | null
    issuedAt: Date | null
    cancelledAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    paymentId: string | null
    fiscalDataId: string | null
    facturamaInvoiceId: string | null
    uuid: string | null
    serie: string | null
    folio: string | null
    subtotal: Decimal | null
    iva: Decimal | null
    total: Decimal | null
    xmlUrl: string | null
    pdfUrl: string | null
    status: $Enums.InvoiceStatus | null
    issuedAt: Date | null
    cancelledAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    userId: number
    paymentId: number
    fiscalDataId: number
    facturamaInvoiceId: number
    uuid: number
    serie: number
    folio: number
    subtotal: number
    iva: number
    total: number
    xmlUrl: number
    pdfUrl: number
    status: number
    issuedAt: number
    cancelledAt: number
    errorMessage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    subtotal?: true
    iva?: true
    total?: true
  }

  export type InvoiceSumAggregateInputType = {
    subtotal?: true
    iva?: true
    total?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    userId?: true
    paymentId?: true
    fiscalDataId?: true
    facturamaInvoiceId?: true
    uuid?: true
    serie?: true
    folio?: true
    subtotal?: true
    iva?: true
    total?: true
    xmlUrl?: true
    pdfUrl?: true
    status?: true
    issuedAt?: true
    cancelledAt?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    userId?: true
    paymentId?: true
    fiscalDataId?: true
    facturamaInvoiceId?: true
    uuid?: true
    serie?: true
    folio?: true
    subtotal?: true
    iva?: true
    total?: true
    xmlUrl?: true
    pdfUrl?: true
    status?: true
    issuedAt?: true
    cancelledAt?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    userId?: true
    paymentId?: true
    fiscalDataId?: true
    facturamaInvoiceId?: true
    uuid?: true
    serie?: true
    folio?: true
    subtotal?: true
    iva?: true
    total?: true
    xmlUrl?: true
    pdfUrl?: true
    status?: true
    issuedAt?: true
    cancelledAt?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    userId: string
    paymentId: string
    fiscalDataId: string | null
    facturamaInvoiceId: string | null
    uuid: string | null
    serie: string | null
    folio: string | null
    subtotal: Decimal
    iva: Decimal
    total: Decimal
    xmlUrl: string | null
    pdfUrl: string | null
    status: $Enums.InvoiceStatus
    issuedAt: Date | null
    cancelledAt: Date | null
    errorMessage: string | null
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    paymentId?: boolean
    fiscalDataId?: boolean
    facturamaInvoiceId?: boolean
    uuid?: boolean
    serie?: boolean
    folio?: boolean
    subtotal?: boolean
    iva?: boolean
    total?: boolean
    xmlUrl?: boolean
    pdfUrl?: boolean
    status?: boolean
    issuedAt?: boolean
    cancelledAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    fiscalData?: boolean | Invoice$fiscalDataArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    paymentId?: boolean
    fiscalDataId?: boolean
    facturamaInvoiceId?: boolean
    uuid?: boolean
    serie?: boolean
    folio?: boolean
    subtotal?: boolean
    iva?: boolean
    total?: boolean
    xmlUrl?: boolean
    pdfUrl?: boolean
    status?: boolean
    issuedAt?: boolean
    cancelledAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    fiscalData?: boolean | Invoice$fiscalDataArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    userId?: boolean
    paymentId?: boolean
    fiscalDataId?: boolean
    facturamaInvoiceId?: boolean
    uuid?: boolean
    serie?: boolean
    folio?: boolean
    subtotal?: boolean
    iva?: boolean
    total?: boolean
    xmlUrl?: boolean
    pdfUrl?: boolean
    status?: boolean
    issuedAt?: boolean
    cancelledAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    fiscalData?: boolean | Invoice$fiscalDataArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    fiscalData?: boolean | Invoice$fiscalDataArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      payment: Prisma.$PaymentPayload<ExtArgs>
      fiscalData: Prisma.$FiscalDataPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      paymentId: string
      fiscalDataId: string | null
      facturamaInvoiceId: string | null
      uuid: string | null
      serie: string | null
      folio: string | null
      subtotal: Prisma.Decimal
      iva: Prisma.Decimal
      total: Prisma.Decimal
      xmlUrl: string | null
      pdfUrl: string | null
      status: $Enums.InvoiceStatus
      issuedAt: Date | null
      cancelledAt: Date | null
      errorMessage: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDefaultArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    fiscalData<T extends Invoice$fiscalDataArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$fiscalDataArgs<ExtArgs>>): Prisma__FiscalDataClient<$Result.GetResult<Prisma.$FiscalDataPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly userId: FieldRef<"Invoice", 'String'>
    readonly paymentId: FieldRef<"Invoice", 'String'>
    readonly fiscalDataId: FieldRef<"Invoice", 'String'>
    readonly facturamaInvoiceId: FieldRef<"Invoice", 'String'>
    readonly uuid: FieldRef<"Invoice", 'String'>
    readonly serie: FieldRef<"Invoice", 'String'>
    readonly folio: FieldRef<"Invoice", 'String'>
    readonly subtotal: FieldRef<"Invoice", 'Decimal'>
    readonly iva: FieldRef<"Invoice", 'Decimal'>
    readonly total: FieldRef<"Invoice", 'Decimal'>
    readonly xmlUrl: FieldRef<"Invoice", 'String'>
    readonly pdfUrl: FieldRef<"Invoice", 'String'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly issuedAt: FieldRef<"Invoice", 'DateTime'>
    readonly cancelledAt: FieldRef<"Invoice", 'DateTime'>
    readonly errorMessage: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice.fiscalData
   */
  export type Invoice$fiscalDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalData
     */
    select?: FiscalDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalDataInclude<ExtArgs> | null
    where?: FiscalDataWhereInput
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    curp: 'curp',
    name: 'name',
    dateOfBirth: 'dateOfBirth',
    sex: 'sex',
    phone: 'phone',
    address: 'address',
    isActive: 'isActive',
    isVerified: 'isVerified',
    verificationToken: 'verificationToken',
    verificationExpires: 'verificationExpires',
    resetToken: 'resetToken',
    resetExpires: 'resetExpires',
    webauthnChallenge: 'webauthnChallenge',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLoginAt: 'lastLoginAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    refreshToken: 'refreshToken',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const WebAuthnCredentialScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    credentialId: 'credentialId',
    credentialPublicKey: 'credentialPublicKey',
    counter: 'counter',
    deviceType: 'deviceType',
    deviceName: 'deviceName',
    transports: 'transports',
    createdAt: 'createdAt',
    lastUsedAt: 'lastUsedAt'
  };

  export type WebAuthnCredentialScalarFieldEnum = (typeof WebAuthnCredentialScalarFieldEnum)[keyof typeof WebAuthnCredentialScalarFieldEnum]


  export const PatientProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    bloodType: 'bloodType',
    allergiesEnc: 'allergiesEnc',
    conditionsEnc: 'conditionsEnc',
    medicationsEnc: 'medicationsEnc',
    insuranceProvider: 'insuranceProvider',
    insurancePolicy: 'insurancePolicy',
    insurancePhone: 'insurancePhone',
    photoUrl: 'photoUrl',
    isDonor: 'isDonor',
    donorPreferencesEnc: 'donorPreferencesEnc',
    donorVideoUrl: 'donorVideoUrl',
    qrToken: 'qrToken',
    qrGeneratedAt: 'qrGeneratedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PatientProfileScalarFieldEnum = (typeof PatientProfileScalarFieldEnum)[keyof typeof PatientProfileScalarFieldEnum]


  export const RepresentativeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    phone: 'phone',
    email: 'email',
    relation: 'relation',
    priority: 'priority',
    isDonorSpokesperson: 'isDonorSpokesperson',
    notifyOnEmergency: 'notifyOnEmergency',
    notifyOnAccess: 'notifyOnAccess',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RepresentativeScalarFieldEnum = (typeof RepresentativeScalarFieldEnum)[keyof typeof RepresentativeScalarFieldEnum]


  export const AdvanceDirectiveScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    status: 'status',
    documentUrl: 'documentUrl',
    documentHash: 'documentHash',
    originalFileName: 'originalFileName',
    nom151Sealed: 'nom151Sealed',
    nom151Timestamp: 'nom151Timestamp',
    nom151Certificate: 'nom151Certificate',
    nom151Provider: 'nom151Provider',
    acceptsCPR: 'acceptsCPR',
    acceptsIntubation: 'acceptsIntubation',
    acceptsDialysis: 'acceptsDialysis',
    acceptsTransfusion: 'acceptsTransfusion',
    acceptsArtificialNutrition: 'acceptsArtificialNutrition',
    palliativeCareOnly: 'palliativeCareOnly',
    additionalNotes: 'additionalNotes',
    originState: 'originState',
    legalBasisSummary: 'legalBasisSummary',
    validatedAt: 'validatedAt',
    validatedBy: 'validatedBy',
    validationMethod: 'validationMethod',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    revokedAt: 'revokedAt',
    expiresAt: 'expiresAt'
  };

  export type AdvanceDirectiveScalarFieldEnum = (typeof AdvanceDirectiveScalarFieldEnum)[keyof typeof AdvanceDirectiveScalarFieldEnum]


  export const WitnessScalarFieldEnum: {
    id: 'id',
    directiveId: 'directiveId',
    name: 'name',
    curp: 'curp',
    email: 'email',
    phone: 'phone',
    ineImageUrl: 'ineImageUrl',
    selfieImageUrl: 'selfieImageUrl',
    identityVerified: 'identityVerified',
    verifiedAt: 'verifiedAt',
    signatureImageUrl: 'signatureImageUrl',
    signedAt: 'signedAt',
    sessionId: 'sessionId',
    sessionRecordingUrl: 'sessionRecordingUrl',
    sessionStartedAt: 'sessionStartedAt',
    sessionEndedAt: 'sessionEndedAt',
    createdAt: 'createdAt'
  };

  export type WitnessScalarFieldEnum = (typeof WitnessScalarFieldEnum)[keyof typeof WitnessScalarFieldEnum]


  export const EmergencyAccessScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    accessorId: 'accessorId',
    accessorName: 'accessorName',
    accessorRole: 'accessorRole',
    accessorLicense: 'accessorLicense',
    institutionId: 'institutionId',
    institutionName: 'institutionName',
    insuranceId: 'insuranceId',
    insurancePolicyNo: 'insurancePolicyNo',
    qrTokenUsed: 'qrTokenUsed',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    latitude: 'latitude',
    longitude: 'longitude',
    locationName: 'locationName',
    dataAccessed: 'dataAccessed',
    representativesNotified: 'representativesNotified',
    notificationsSentAt: 'notificationsSentAt',
    accessToken: 'accessToken',
    accessedAt: 'accessedAt',
    expiresAt: 'expiresAt'
  };

  export type EmergencyAccessScalarFieldEnum = (typeof EmergencyAccessScalarFieldEnum)[keyof typeof EmergencyAccessScalarFieldEnum]


  export const MedicalInstitutionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    cluesCode: 'cluesCode',
    address: 'address',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    latitude: 'latitude',
    longitude: 'longitude',
    phone: 'phone',
    emergencyPhone: 'emergencyPhone',
    email: 'email',
    attentionLevel: 'attentionLevel',
    specialties: 'specialties',
    hasEmergency: 'hasEmergency',
    has24Hours: 'has24Hours',
    hasICU: 'hasICU',
    hasTrauma: 'hasTrauma',
    oauthClientId: 'oauthClientId',
    oauthClientSecret: 'oauthClientSecret',
    isActive: 'isActive',
    isVerified: 'isVerified',
    verifiedAt: 'verifiedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicalInstitutionScalarFieldEnum = (typeof MedicalInstitutionScalarFieldEnum)[keyof typeof MedicalInstitutionScalarFieldEnum]


  export const InsuranceCompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    shortName: 'shortName',
    type: 'type',
    cnsfNumber: 'cnsfNumber',
    rfc: 'rfc',
    address: 'address',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    phone: 'phone',
    emergencyPhone: 'emergencyPhone',
    email: 'email',
    website: 'website',
    coverageTypes: 'coverageTypes',
    networkSize: 'networkSize',
    hasNationalCoverage: 'hasNationalCoverage',
    statesCovered: 'statesCovered',
    isVerified: 'isVerified',
    verifiedAt: 'verifiedAt',
    verifiedBy: 'verifiedBy',
    apiEnabled: 'apiEnabled',
    apiEndpoint: 'apiEndpoint',
    logoUrl: 'logoUrl',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InsuranceCompanyScalarFieldEnum = (typeof InsuranceCompanyScalarFieldEnum)[keyof typeof InsuranceCompanyScalarFieldEnum]


  export const InsurancePlanScalarFieldEnum: {
    id: 'id',
    insuranceId: 'insuranceId',
    name: 'name',
    code: 'code',
    sumAssured: 'sumAssured',
    deductible: 'deductible',
    coinsurance: 'coinsurance',
    features: 'features',
    exclusions: 'exclusions',
    hospitalLevel: 'hospitalLevel',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InsurancePlanScalarFieldEnum = (typeof InsurancePlanScalarFieldEnum)[keyof typeof InsurancePlanScalarFieldEnum]


  export const MedicalStaffScalarFieldEnum: {
    id: 'id',
    institutionId: 'institutionId',
    name: 'name',
    email: 'email',
    passwordHash: 'passwordHash',
    role: 'role',
    license: 'license',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLoginAt: 'lastLoginAt'
  };

  export type MedicalStaffScalarFieldEnum = (typeof MedicalStaffScalarFieldEnum)[keyof typeof MedicalStaffScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    actorType: 'actorType',
    actorId: 'actorId',
    actorName: 'actorName',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    details: 'details',
    oldValue: 'oldValue',
    newValue: 'newValue',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const StateLegalTemplateScalarFieldEnum: {
    id: 'id',
    stateCode: 'stateCode',
    stateName: 'stateName',
    lawName: 'lawName',
    lawDate: 'lawDate',
    lawSummary: 'lawSummary',
    templateHtml: 'templateHtml',
    templateFields: 'templateFields',
    requiresNotary: 'requiresNotary',
    requiresWitnesses: 'requiresWitnesses',
    requiresMedicalCert: 'requiresMedicalCert',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StateLegalTemplateScalarFieldEnum = (typeof StateLegalTemplateScalarFieldEnum)[keyof typeof StateLegalTemplateScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    email: 'email',
    phone: 'phone',
    type: 'type',
    channel: 'channel',
    subject: 'subject',
    body: 'body',
    status: 'status',
    sentAt: 'sentAt',
    deliveredAt: 'deliveredAt',
    failedAt: 'failedAt',
    errorMessage: 'errorMessage',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const PanicAlertScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    latitude: 'latitude',
    longitude: 'longitude',
    accuracy: 'accuracy',
    locationName: 'locationName',
    status: 'status',
    message: 'message',
    cancelledAt: 'cancelledAt',
    resolvedAt: 'resolvedAt',
    nearbyHospitals: 'nearbyHospitals',
    notificationsSent: 'notificationsSent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PanicAlertScalarFieldEnum = (typeof PanicAlertScalarFieldEnum)[keyof typeof PanicAlertScalarFieldEnum]


  export const AdminUserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    name: 'name',
    role: 'role',
    permissions: 'permissions',
    isActive: 'isActive',
    isSuperAdmin: 'isSuperAdmin',
    lastLoginAt: 'lastLoginAt',
    lastLoginIp: 'lastLoginIp',
    failedAttempts: 'failedAttempts',
    lockedUntil: 'lockedUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy'
  };

  export type AdminUserScalarFieldEnum = (typeof AdminUserScalarFieldEnum)[keyof typeof AdminUserScalarFieldEnum]


  export const AdminSessionScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    refreshToken: 'refreshToken',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type AdminSessionScalarFieldEnum = (typeof AdminSessionScalarFieldEnum)[keyof typeof AdminSessionScalarFieldEnum]


  export const AdminAuditLogScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    details: 'details',
    oldValue: 'oldValue',
    newValue: 'newValue',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AdminAuditLogScalarFieldEnum = (typeof AdminAuditLogScalarFieldEnum)[keyof typeof AdminAuditLogScalarFieldEnum]


  export const SubscriptionPlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    priceMonthly: 'priceMonthly',
    priceAnnual: 'priceAnnual',
    currency: 'currency',
    stripePriceIdMonthly: 'stripePriceIdMonthly',
    stripePriceIdAnnual: 'stripePriceIdAnnual',
    stripeProductId: 'stripeProductId',
    features: 'features',
    limits: 'limits',
    trialDays: 'trialDays',
    isActive: 'isActive',
    isDefault: 'isDefault',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionPlanScalarFieldEnum = (typeof SubscriptionPlanScalarFieldEnum)[keyof typeof SubscriptionPlanScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    planId: 'planId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    stripeCustomerId: 'stripeCustomerId',
    billingCycle: 'billingCycle',
    status: 'status',
    trialEndsAt: 'trialEndsAt',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    cancelAtPeriodEnd: 'cancelAtPeriodEnd',
    cancelledAt: 'cancelledAt',
    cancelReason: 'cancelReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    subscriptionId: 'subscriptionId',
    stripePaymentIntentId: 'stripePaymentIntentId',
    stripeChargeId: 'stripeChargeId',
    stripeInvoiceId: 'stripeInvoiceId',
    amount: 'amount',
    currency: 'currency',
    paymentMethod: 'paymentMethod',
    last4: 'last4',
    cardBrand: 'cardBrand',
    oxxoVoucherUrl: 'oxxoVoucherUrl',
    oxxoExpiresAt: 'oxxoExpiresAt',
    status: 'status',
    description: 'description',
    failureCode: 'failureCode',
    failureMessage: 'failureMessage',
    paidAt: 'paidAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const PaymentMethodScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    stripePaymentMethodId: 'stripePaymentMethodId',
    type: 'type',
    last4: 'last4',
    brand: 'brand',
    expMonth: 'expMonth',
    expYear: 'expYear',
    cardholderName: 'cardholderName',
    isDefault: 'isDefault',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentMethodScalarFieldEnum = (typeof PaymentMethodScalarFieldEnum)[keyof typeof PaymentMethodScalarFieldEnum]


  export const FiscalDataScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    rfc: 'rfc',
    razonSocial: 'razonSocial',
    regimenFiscal: 'regimenFiscal',
    usoCFDI: 'usoCFDI',
    codigoPostal: 'codigoPostal',
    calle: 'calle',
    numExterior: 'numExterior',
    numInterior: 'numInterior',
    colonia: 'colonia',
    municipio: 'municipio',
    estado: 'estado',
    emailFacturacion: 'emailFacturacion',
    facturamaClientId: 'facturamaClientId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FiscalDataScalarFieldEnum = (typeof FiscalDataScalarFieldEnum)[keyof typeof FiscalDataScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    paymentId: 'paymentId',
    fiscalDataId: 'fiscalDataId',
    facturamaInvoiceId: 'facturamaInvoiceId',
    uuid: 'uuid',
    serie: 'serie',
    folio: 'folio',
    subtotal: 'subtotal',
    iva: 'iva',
    total: 'total',
    xmlUrl: 'xmlUrl',
    pdfUrl: 'pdfUrl',
    status: 'status',
    issuedAt: 'issuedAt',
    cancelledAt: 'cancelledAt',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DirectiveType'
   */
  export type EnumDirectiveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DirectiveType'>
    


  /**
   * Reference to a field of type 'DirectiveType[]'
   */
  export type ListEnumDirectiveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DirectiveType[]'>
    


  /**
   * Reference to a field of type 'DirectiveStatus'
   */
  export type EnumDirectiveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DirectiveStatus'>
    


  /**
   * Reference to a field of type 'DirectiveStatus[]'
   */
  export type ListEnumDirectiveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DirectiveStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'InstitutionType'
   */
  export type EnumInstitutionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstitutionType'>
    


  /**
   * Reference to a field of type 'InstitutionType[]'
   */
  export type ListEnumInstitutionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstitutionType[]'>
    


  /**
   * Reference to a field of type 'AttentionLevel'
   */
  export type EnumAttentionLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttentionLevel'>
    


  /**
   * Reference to a field of type 'AttentionLevel[]'
   */
  export type ListEnumAttentionLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttentionLevel[]'>
    


  /**
   * Reference to a field of type 'InsuranceType'
   */
  export type EnumInsuranceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsuranceType'>
    


  /**
   * Reference to a field of type 'InsuranceType[]'
   */
  export type ListEnumInsuranceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsuranceType[]'>
    


  /**
   * Reference to a field of type 'StaffRole'
   */
  export type EnumStaffRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StaffRole'>
    


  /**
   * Reference to a field of type 'StaffRole[]'
   */
  export type ListEnumStaffRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StaffRole[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'NotificationChannel'
   */
  export type EnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannel'>
    


  /**
   * Reference to a field of type 'NotificationChannel[]'
   */
  export type ListEnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannel[]'>
    


  /**
   * Reference to a field of type 'NotificationStatus'
   */
  export type EnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus'>
    


  /**
   * Reference to a field of type 'NotificationStatus[]'
   */
  export type ListEnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus[]'>
    


  /**
   * Reference to a field of type 'PanicStatus'
   */
  export type EnumPanicStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PanicStatus'>
    


  /**
   * Reference to a field of type 'PanicStatus[]'
   */
  export type ListEnumPanicStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PanicStatus[]'>
    


  /**
   * Reference to a field of type 'AdminRole'
   */
  export type EnumAdminRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminRole'>
    


  /**
   * Reference to a field of type 'AdminRole[]'
   */
  export type ListEnumAdminRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminRole[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'BillingCycle'
   */
  export type EnumBillingCycleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingCycle'>
    


  /**
   * Reference to a field of type 'BillingCycle[]'
   */
  export type ListEnumBillingCycleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingCycle[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethodType'
   */
  export type EnumPaymentMethodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethodType'>
    


  /**
   * Reference to a field of type 'PaymentMethodType[]'
   */
  export type ListEnumPaymentMethodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethodType[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    curp?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    sex?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    isVerified?: BoolFilter<"User"> | boolean
    verificationToken?: StringNullableFilter<"User"> | string | null
    verificationExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    webauthnChallenge?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    profile?: XOR<PatientProfileNullableRelationFilter, PatientProfileWhereInput> | null
    directives?: AdvanceDirectiveListRelationFilter
    representatives?: RepresentativeListRelationFilter
    emergencyAccesses?: EmergencyAccessListRelationFilter
    panicAlerts?: PanicAlertListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    sessions?: SessionListRelationFilter
    webauthnCredentials?: WebAuthnCredentialListRelationFilter
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
    payments?: PaymentListRelationFilter
    paymentMethods?: PaymentMethodListRelationFilter
    fiscalData?: XOR<FiscalDataNullableRelationFilter, FiscalDataWhereInput> | null
    invoices?: InvoiceListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    curp?: SortOrder
    name?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    sex?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    verificationToken?: SortOrderInput | SortOrder
    verificationExpires?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetExpires?: SortOrderInput | SortOrder
    webauthnChallenge?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    profile?: PatientProfileOrderByWithRelationInput
    directives?: AdvanceDirectiveOrderByRelationAggregateInput
    representatives?: RepresentativeOrderByRelationAggregateInput
    emergencyAccesses?: EmergencyAccessOrderByRelationAggregateInput
    panicAlerts?: PanicAlertOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    webauthnCredentials?: WebAuthnCredentialOrderByRelationAggregateInput
    subscription?: SubscriptionOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
    paymentMethods?: PaymentMethodOrderByRelationAggregateInput
    fiscalData?: FiscalDataOrderByWithRelationInput
    invoices?: InvoiceOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    curp?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    sex?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    isVerified?: BoolFilter<"User"> | boolean
    verificationToken?: StringNullableFilter<"User"> | string | null
    verificationExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    webauthnChallenge?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    profile?: XOR<PatientProfileNullableRelationFilter, PatientProfileWhereInput> | null
    directives?: AdvanceDirectiveListRelationFilter
    representatives?: RepresentativeListRelationFilter
    emergencyAccesses?: EmergencyAccessListRelationFilter
    panicAlerts?: PanicAlertListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    sessions?: SessionListRelationFilter
    webauthnCredentials?: WebAuthnCredentialListRelationFilter
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
    payments?: PaymentListRelationFilter
    paymentMethods?: PaymentMethodListRelationFilter
    fiscalData?: XOR<FiscalDataNullableRelationFilter, FiscalDataWhereInput> | null
    invoices?: InvoiceListRelationFilter
  }, "id" | "email" | "curp">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    curp?: SortOrder
    name?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    sex?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    verificationToken?: SortOrderInput | SortOrder
    verificationExpires?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetExpires?: SortOrderInput | SortOrder
    webauthnChallenge?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    curp?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    sex?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    verificationToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    verificationExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    resetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    webauthnChallenge?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    refreshToken?: StringFilter<"Session"> | string
    userAgent?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    refreshToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    userAgent?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "refreshToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    refreshToken?: StringWithAggregatesFilter<"Session"> | string
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type WebAuthnCredentialWhereInput = {
    AND?: WebAuthnCredentialWhereInput | WebAuthnCredentialWhereInput[]
    OR?: WebAuthnCredentialWhereInput[]
    NOT?: WebAuthnCredentialWhereInput | WebAuthnCredentialWhereInput[]
    id?: StringFilter<"WebAuthnCredential"> | string
    userId?: StringFilter<"WebAuthnCredential"> | string
    credentialId?: StringFilter<"WebAuthnCredential"> | string
    credentialPublicKey?: BytesFilter<"WebAuthnCredential"> | Buffer
    counter?: BigIntFilter<"WebAuthnCredential"> | bigint | number
    deviceType?: StringNullableFilter<"WebAuthnCredential"> | string | null
    deviceName?: StringNullableFilter<"WebAuthnCredential"> | string | null
    transports?: StringNullableListFilter<"WebAuthnCredential">
    createdAt?: DateTimeFilter<"WebAuthnCredential"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"WebAuthnCredential"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type WebAuthnCredentialOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
    credentialPublicKey?: SortOrder
    counter?: SortOrder
    deviceType?: SortOrderInput | SortOrder
    deviceName?: SortOrderInput | SortOrder
    transports?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type WebAuthnCredentialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    credentialId?: string
    AND?: WebAuthnCredentialWhereInput | WebAuthnCredentialWhereInput[]
    OR?: WebAuthnCredentialWhereInput[]
    NOT?: WebAuthnCredentialWhereInput | WebAuthnCredentialWhereInput[]
    userId?: StringFilter<"WebAuthnCredential"> | string
    credentialPublicKey?: BytesFilter<"WebAuthnCredential"> | Buffer
    counter?: BigIntFilter<"WebAuthnCredential"> | bigint | number
    deviceType?: StringNullableFilter<"WebAuthnCredential"> | string | null
    deviceName?: StringNullableFilter<"WebAuthnCredential"> | string | null
    transports?: StringNullableListFilter<"WebAuthnCredential">
    createdAt?: DateTimeFilter<"WebAuthnCredential"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"WebAuthnCredential"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "credentialId">

  export type WebAuthnCredentialOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
    credentialPublicKey?: SortOrder
    counter?: SortOrder
    deviceType?: SortOrderInput | SortOrder
    deviceName?: SortOrderInput | SortOrder
    transports?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    _count?: WebAuthnCredentialCountOrderByAggregateInput
    _avg?: WebAuthnCredentialAvgOrderByAggregateInput
    _max?: WebAuthnCredentialMaxOrderByAggregateInput
    _min?: WebAuthnCredentialMinOrderByAggregateInput
    _sum?: WebAuthnCredentialSumOrderByAggregateInput
  }

  export type WebAuthnCredentialScalarWhereWithAggregatesInput = {
    AND?: WebAuthnCredentialScalarWhereWithAggregatesInput | WebAuthnCredentialScalarWhereWithAggregatesInput[]
    OR?: WebAuthnCredentialScalarWhereWithAggregatesInput[]
    NOT?: WebAuthnCredentialScalarWhereWithAggregatesInput | WebAuthnCredentialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebAuthnCredential"> | string
    userId?: StringWithAggregatesFilter<"WebAuthnCredential"> | string
    credentialId?: StringWithAggregatesFilter<"WebAuthnCredential"> | string
    credentialPublicKey?: BytesWithAggregatesFilter<"WebAuthnCredential"> | Buffer
    counter?: BigIntWithAggregatesFilter<"WebAuthnCredential"> | bigint | number
    deviceType?: StringNullableWithAggregatesFilter<"WebAuthnCredential"> | string | null
    deviceName?: StringNullableWithAggregatesFilter<"WebAuthnCredential"> | string | null
    transports?: StringNullableListFilter<"WebAuthnCredential">
    createdAt?: DateTimeWithAggregatesFilter<"WebAuthnCredential"> | Date | string
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"WebAuthnCredential"> | Date | string | null
  }

  export type PatientProfileWhereInput = {
    AND?: PatientProfileWhereInput | PatientProfileWhereInput[]
    OR?: PatientProfileWhereInput[]
    NOT?: PatientProfileWhereInput | PatientProfileWhereInput[]
    id?: StringFilter<"PatientProfile"> | string
    userId?: StringFilter<"PatientProfile"> | string
    bloodType?: StringNullableFilter<"PatientProfile"> | string | null
    allergiesEnc?: StringNullableFilter<"PatientProfile"> | string | null
    conditionsEnc?: StringNullableFilter<"PatientProfile"> | string | null
    medicationsEnc?: StringNullableFilter<"PatientProfile"> | string | null
    insuranceProvider?: StringNullableFilter<"PatientProfile"> | string | null
    insurancePolicy?: StringNullableFilter<"PatientProfile"> | string | null
    insurancePhone?: StringNullableFilter<"PatientProfile"> | string | null
    photoUrl?: StringNullableFilter<"PatientProfile"> | string | null
    isDonor?: BoolFilter<"PatientProfile"> | boolean
    donorPreferencesEnc?: StringNullableFilter<"PatientProfile"> | string | null
    donorVideoUrl?: StringNullableFilter<"PatientProfile"> | string | null
    qrToken?: StringFilter<"PatientProfile"> | string
    qrGeneratedAt?: DateTimeFilter<"PatientProfile"> | Date | string
    createdAt?: DateTimeFilter<"PatientProfile"> | Date | string
    updatedAt?: DateTimeFilter<"PatientProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PatientProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    bloodType?: SortOrderInput | SortOrder
    allergiesEnc?: SortOrderInput | SortOrder
    conditionsEnc?: SortOrderInput | SortOrder
    medicationsEnc?: SortOrderInput | SortOrder
    insuranceProvider?: SortOrderInput | SortOrder
    insurancePolicy?: SortOrderInput | SortOrder
    insurancePhone?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    isDonor?: SortOrder
    donorPreferencesEnc?: SortOrderInput | SortOrder
    donorVideoUrl?: SortOrderInput | SortOrder
    qrToken?: SortOrder
    qrGeneratedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PatientProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    qrToken?: string
    AND?: PatientProfileWhereInput | PatientProfileWhereInput[]
    OR?: PatientProfileWhereInput[]
    NOT?: PatientProfileWhereInput | PatientProfileWhereInput[]
    bloodType?: StringNullableFilter<"PatientProfile"> | string | null
    allergiesEnc?: StringNullableFilter<"PatientProfile"> | string | null
    conditionsEnc?: StringNullableFilter<"PatientProfile"> | string | null
    medicationsEnc?: StringNullableFilter<"PatientProfile"> | string | null
    insuranceProvider?: StringNullableFilter<"PatientProfile"> | string | null
    insurancePolicy?: StringNullableFilter<"PatientProfile"> | string | null
    insurancePhone?: StringNullableFilter<"PatientProfile"> | string | null
    photoUrl?: StringNullableFilter<"PatientProfile"> | string | null
    isDonor?: BoolFilter<"PatientProfile"> | boolean
    donorPreferencesEnc?: StringNullableFilter<"PatientProfile"> | string | null
    donorVideoUrl?: StringNullableFilter<"PatientProfile"> | string | null
    qrGeneratedAt?: DateTimeFilter<"PatientProfile"> | Date | string
    createdAt?: DateTimeFilter<"PatientProfile"> | Date | string
    updatedAt?: DateTimeFilter<"PatientProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId" | "qrToken">

  export type PatientProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    bloodType?: SortOrderInput | SortOrder
    allergiesEnc?: SortOrderInput | SortOrder
    conditionsEnc?: SortOrderInput | SortOrder
    medicationsEnc?: SortOrderInput | SortOrder
    insuranceProvider?: SortOrderInput | SortOrder
    insurancePolicy?: SortOrderInput | SortOrder
    insurancePhone?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    isDonor?: SortOrder
    donorPreferencesEnc?: SortOrderInput | SortOrder
    donorVideoUrl?: SortOrderInput | SortOrder
    qrToken?: SortOrder
    qrGeneratedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PatientProfileCountOrderByAggregateInput
    _max?: PatientProfileMaxOrderByAggregateInput
    _min?: PatientProfileMinOrderByAggregateInput
  }

  export type PatientProfileScalarWhereWithAggregatesInput = {
    AND?: PatientProfileScalarWhereWithAggregatesInput | PatientProfileScalarWhereWithAggregatesInput[]
    OR?: PatientProfileScalarWhereWithAggregatesInput[]
    NOT?: PatientProfileScalarWhereWithAggregatesInput | PatientProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PatientProfile"> | string
    userId?: StringWithAggregatesFilter<"PatientProfile"> | string
    bloodType?: StringNullableWithAggregatesFilter<"PatientProfile"> | string | null
    allergiesEnc?: StringNullableWithAggregatesFilter<"PatientProfile"> | string | null
    conditionsEnc?: StringNullableWithAggregatesFilter<"PatientProfile"> | string | null
    medicationsEnc?: StringNullableWithAggregatesFilter<"PatientProfile"> | string | null
    insuranceProvider?: StringNullableWithAggregatesFilter<"PatientProfile"> | string | null
    insurancePolicy?: StringNullableWithAggregatesFilter<"PatientProfile"> | string | null
    insurancePhone?: StringNullableWithAggregatesFilter<"PatientProfile"> | string | null
    photoUrl?: StringNullableWithAggregatesFilter<"PatientProfile"> | string | null
    isDonor?: BoolWithAggregatesFilter<"PatientProfile"> | boolean
    donorPreferencesEnc?: StringNullableWithAggregatesFilter<"PatientProfile"> | string | null
    donorVideoUrl?: StringNullableWithAggregatesFilter<"PatientProfile"> | string | null
    qrToken?: StringWithAggregatesFilter<"PatientProfile"> | string
    qrGeneratedAt?: DateTimeWithAggregatesFilter<"PatientProfile"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"PatientProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PatientProfile"> | Date | string
  }

  export type RepresentativeWhereInput = {
    AND?: RepresentativeWhereInput | RepresentativeWhereInput[]
    OR?: RepresentativeWhereInput[]
    NOT?: RepresentativeWhereInput | RepresentativeWhereInput[]
    id?: StringFilter<"Representative"> | string
    userId?: StringFilter<"Representative"> | string
    name?: StringFilter<"Representative"> | string
    phone?: StringFilter<"Representative"> | string
    email?: StringNullableFilter<"Representative"> | string | null
    relation?: StringFilter<"Representative"> | string
    priority?: IntFilter<"Representative"> | number
    isDonorSpokesperson?: BoolFilter<"Representative"> | boolean
    notifyOnEmergency?: BoolFilter<"Representative"> | boolean
    notifyOnAccess?: BoolFilter<"Representative"> | boolean
    createdAt?: DateTimeFilter<"Representative"> | Date | string
    updatedAt?: DateTimeFilter<"Representative"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RepresentativeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    relation?: SortOrder
    priority?: SortOrder
    isDonorSpokesperson?: SortOrder
    notifyOnEmergency?: SortOrder
    notifyOnAccess?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RepresentativeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RepresentativeWhereInput | RepresentativeWhereInput[]
    OR?: RepresentativeWhereInput[]
    NOT?: RepresentativeWhereInput | RepresentativeWhereInput[]
    userId?: StringFilter<"Representative"> | string
    name?: StringFilter<"Representative"> | string
    phone?: StringFilter<"Representative"> | string
    email?: StringNullableFilter<"Representative"> | string | null
    relation?: StringFilter<"Representative"> | string
    priority?: IntFilter<"Representative"> | number
    isDonorSpokesperson?: BoolFilter<"Representative"> | boolean
    notifyOnEmergency?: BoolFilter<"Representative"> | boolean
    notifyOnAccess?: BoolFilter<"Representative"> | boolean
    createdAt?: DateTimeFilter<"Representative"> | Date | string
    updatedAt?: DateTimeFilter<"Representative"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type RepresentativeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    relation?: SortOrder
    priority?: SortOrder
    isDonorSpokesperson?: SortOrder
    notifyOnEmergency?: SortOrder
    notifyOnAccess?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RepresentativeCountOrderByAggregateInput
    _avg?: RepresentativeAvgOrderByAggregateInput
    _max?: RepresentativeMaxOrderByAggregateInput
    _min?: RepresentativeMinOrderByAggregateInput
    _sum?: RepresentativeSumOrderByAggregateInput
  }

  export type RepresentativeScalarWhereWithAggregatesInput = {
    AND?: RepresentativeScalarWhereWithAggregatesInput | RepresentativeScalarWhereWithAggregatesInput[]
    OR?: RepresentativeScalarWhereWithAggregatesInput[]
    NOT?: RepresentativeScalarWhereWithAggregatesInput | RepresentativeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Representative"> | string
    userId?: StringWithAggregatesFilter<"Representative"> | string
    name?: StringWithAggregatesFilter<"Representative"> | string
    phone?: StringWithAggregatesFilter<"Representative"> | string
    email?: StringNullableWithAggregatesFilter<"Representative"> | string | null
    relation?: StringWithAggregatesFilter<"Representative"> | string
    priority?: IntWithAggregatesFilter<"Representative"> | number
    isDonorSpokesperson?: BoolWithAggregatesFilter<"Representative"> | boolean
    notifyOnEmergency?: BoolWithAggregatesFilter<"Representative"> | boolean
    notifyOnAccess?: BoolWithAggregatesFilter<"Representative"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Representative"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Representative"> | Date | string
  }

  export type AdvanceDirectiveWhereInput = {
    AND?: AdvanceDirectiveWhereInput | AdvanceDirectiveWhereInput[]
    OR?: AdvanceDirectiveWhereInput[]
    NOT?: AdvanceDirectiveWhereInput | AdvanceDirectiveWhereInput[]
    id?: StringFilter<"AdvanceDirective"> | string
    userId?: StringFilter<"AdvanceDirective"> | string
    type?: EnumDirectiveTypeFilter<"AdvanceDirective"> | $Enums.DirectiveType
    status?: EnumDirectiveStatusFilter<"AdvanceDirective"> | $Enums.DirectiveStatus
    documentUrl?: StringNullableFilter<"AdvanceDirective"> | string | null
    documentHash?: StringNullableFilter<"AdvanceDirective"> | string | null
    originalFileName?: StringNullableFilter<"AdvanceDirective"> | string | null
    nom151Sealed?: BoolFilter<"AdvanceDirective"> | boolean
    nom151Timestamp?: DateTimeNullableFilter<"AdvanceDirective"> | Date | string | null
    nom151Certificate?: StringNullableFilter<"AdvanceDirective"> | string | null
    nom151Provider?: StringNullableFilter<"AdvanceDirective"> | string | null
    acceptsCPR?: BoolNullableFilter<"AdvanceDirective"> | boolean | null
    acceptsIntubation?: BoolNullableFilter<"AdvanceDirective"> | boolean | null
    acceptsDialysis?: BoolNullableFilter<"AdvanceDirective"> | boolean | null
    acceptsTransfusion?: BoolNullableFilter<"AdvanceDirective"> | boolean | null
    acceptsArtificialNutrition?: BoolNullableFilter<"AdvanceDirective"> | boolean | null
    palliativeCareOnly?: BoolNullableFilter<"AdvanceDirective"> | boolean | null
    additionalNotes?: StringNullableFilter<"AdvanceDirective"> | string | null
    originState?: StringNullableFilter<"AdvanceDirective"> | string | null
    legalBasisSummary?: StringNullableFilter<"AdvanceDirective"> | string | null
    validatedAt?: DateTimeNullableFilter<"AdvanceDirective"> | Date | string | null
    validatedBy?: StringNullableFilter<"AdvanceDirective"> | string | null
    validationMethod?: StringNullableFilter<"AdvanceDirective"> | string | null
    createdAt?: DateTimeFilter<"AdvanceDirective"> | Date | string
    updatedAt?: DateTimeFilter<"AdvanceDirective"> | Date | string
    revokedAt?: DateTimeNullableFilter<"AdvanceDirective"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"AdvanceDirective"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    witnesses?: WitnessListRelationFilter
  }

  export type AdvanceDirectiveOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    documentUrl?: SortOrderInput | SortOrder
    documentHash?: SortOrderInput | SortOrder
    originalFileName?: SortOrderInput | SortOrder
    nom151Sealed?: SortOrder
    nom151Timestamp?: SortOrderInput | SortOrder
    nom151Certificate?: SortOrderInput | SortOrder
    nom151Provider?: SortOrderInput | SortOrder
    acceptsCPR?: SortOrderInput | SortOrder
    acceptsIntubation?: SortOrderInput | SortOrder
    acceptsDialysis?: SortOrderInput | SortOrder
    acceptsTransfusion?: SortOrderInput | SortOrder
    acceptsArtificialNutrition?: SortOrderInput | SortOrder
    palliativeCareOnly?: SortOrderInput | SortOrder
    additionalNotes?: SortOrderInput | SortOrder
    originState?: SortOrderInput | SortOrder
    legalBasisSummary?: SortOrderInput | SortOrder
    validatedAt?: SortOrderInput | SortOrder
    validatedBy?: SortOrderInput | SortOrder
    validationMethod?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    witnesses?: WitnessOrderByRelationAggregateInput
  }

  export type AdvanceDirectiveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdvanceDirectiveWhereInput | AdvanceDirectiveWhereInput[]
    OR?: AdvanceDirectiveWhereInput[]
    NOT?: AdvanceDirectiveWhereInput | AdvanceDirectiveWhereInput[]
    userId?: StringFilter<"AdvanceDirective"> | string
    type?: EnumDirectiveTypeFilter<"AdvanceDirective"> | $Enums.DirectiveType
    status?: EnumDirectiveStatusFilter<"AdvanceDirective"> | $Enums.DirectiveStatus
    documentUrl?: StringNullableFilter<"AdvanceDirective"> | string | null
    documentHash?: StringNullableFilter<"AdvanceDirective"> | string | null
    originalFileName?: StringNullableFilter<"AdvanceDirective"> | string | null
    nom151Sealed?: BoolFilter<"AdvanceDirective"> | boolean
    nom151Timestamp?: DateTimeNullableFilter<"AdvanceDirective"> | Date | string | null
    nom151Certificate?: StringNullableFilter<"AdvanceDirective"> | string | null
    nom151Provider?: StringNullableFilter<"AdvanceDirective"> | string | null
    acceptsCPR?: BoolNullableFilter<"AdvanceDirective"> | boolean | null
    acceptsIntubation?: BoolNullableFilter<"AdvanceDirective"> | boolean | null
    acceptsDialysis?: BoolNullableFilter<"AdvanceDirective"> | boolean | null
    acceptsTransfusion?: BoolNullableFilter<"AdvanceDirective"> | boolean | null
    acceptsArtificialNutrition?: BoolNullableFilter<"AdvanceDirective"> | boolean | null
    palliativeCareOnly?: BoolNullableFilter<"AdvanceDirective"> | boolean | null
    additionalNotes?: StringNullableFilter<"AdvanceDirective"> | string | null
    originState?: StringNullableFilter<"AdvanceDirective"> | string | null
    legalBasisSummary?: StringNullableFilter<"AdvanceDirective"> | string | null
    validatedAt?: DateTimeNullableFilter<"AdvanceDirective"> | Date | string | null
    validatedBy?: StringNullableFilter<"AdvanceDirective"> | string | null
    validationMethod?: StringNullableFilter<"AdvanceDirective"> | string | null
    createdAt?: DateTimeFilter<"AdvanceDirective"> | Date | string
    updatedAt?: DateTimeFilter<"AdvanceDirective"> | Date | string
    revokedAt?: DateTimeNullableFilter<"AdvanceDirective"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"AdvanceDirective"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    witnesses?: WitnessListRelationFilter
  }, "id">

  export type AdvanceDirectiveOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    documentUrl?: SortOrderInput | SortOrder
    documentHash?: SortOrderInput | SortOrder
    originalFileName?: SortOrderInput | SortOrder
    nom151Sealed?: SortOrder
    nom151Timestamp?: SortOrderInput | SortOrder
    nom151Certificate?: SortOrderInput | SortOrder
    nom151Provider?: SortOrderInput | SortOrder
    acceptsCPR?: SortOrderInput | SortOrder
    acceptsIntubation?: SortOrderInput | SortOrder
    acceptsDialysis?: SortOrderInput | SortOrder
    acceptsTransfusion?: SortOrderInput | SortOrder
    acceptsArtificialNutrition?: SortOrderInput | SortOrder
    palliativeCareOnly?: SortOrderInput | SortOrder
    additionalNotes?: SortOrderInput | SortOrder
    originState?: SortOrderInput | SortOrder
    legalBasisSummary?: SortOrderInput | SortOrder
    validatedAt?: SortOrderInput | SortOrder
    validatedBy?: SortOrderInput | SortOrder
    validationMethod?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: AdvanceDirectiveCountOrderByAggregateInput
    _max?: AdvanceDirectiveMaxOrderByAggregateInput
    _min?: AdvanceDirectiveMinOrderByAggregateInput
  }

  export type AdvanceDirectiveScalarWhereWithAggregatesInput = {
    AND?: AdvanceDirectiveScalarWhereWithAggregatesInput | AdvanceDirectiveScalarWhereWithAggregatesInput[]
    OR?: AdvanceDirectiveScalarWhereWithAggregatesInput[]
    NOT?: AdvanceDirectiveScalarWhereWithAggregatesInput | AdvanceDirectiveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdvanceDirective"> | string
    userId?: StringWithAggregatesFilter<"AdvanceDirective"> | string
    type?: EnumDirectiveTypeWithAggregatesFilter<"AdvanceDirective"> | $Enums.DirectiveType
    status?: EnumDirectiveStatusWithAggregatesFilter<"AdvanceDirective"> | $Enums.DirectiveStatus
    documentUrl?: StringNullableWithAggregatesFilter<"AdvanceDirective"> | string | null
    documentHash?: StringNullableWithAggregatesFilter<"AdvanceDirective"> | string | null
    originalFileName?: StringNullableWithAggregatesFilter<"AdvanceDirective"> | string | null
    nom151Sealed?: BoolWithAggregatesFilter<"AdvanceDirective"> | boolean
    nom151Timestamp?: DateTimeNullableWithAggregatesFilter<"AdvanceDirective"> | Date | string | null
    nom151Certificate?: StringNullableWithAggregatesFilter<"AdvanceDirective"> | string | null
    nom151Provider?: StringNullableWithAggregatesFilter<"AdvanceDirective"> | string | null
    acceptsCPR?: BoolNullableWithAggregatesFilter<"AdvanceDirective"> | boolean | null
    acceptsIntubation?: BoolNullableWithAggregatesFilter<"AdvanceDirective"> | boolean | null
    acceptsDialysis?: BoolNullableWithAggregatesFilter<"AdvanceDirective"> | boolean | null
    acceptsTransfusion?: BoolNullableWithAggregatesFilter<"AdvanceDirective"> | boolean | null
    acceptsArtificialNutrition?: BoolNullableWithAggregatesFilter<"AdvanceDirective"> | boolean | null
    palliativeCareOnly?: BoolNullableWithAggregatesFilter<"AdvanceDirective"> | boolean | null
    additionalNotes?: StringNullableWithAggregatesFilter<"AdvanceDirective"> | string | null
    originState?: StringNullableWithAggregatesFilter<"AdvanceDirective"> | string | null
    legalBasisSummary?: StringNullableWithAggregatesFilter<"AdvanceDirective"> | string | null
    validatedAt?: DateTimeNullableWithAggregatesFilter<"AdvanceDirective"> | Date | string | null
    validatedBy?: StringNullableWithAggregatesFilter<"AdvanceDirective"> | string | null
    validationMethod?: StringNullableWithAggregatesFilter<"AdvanceDirective"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AdvanceDirective"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdvanceDirective"> | Date | string
    revokedAt?: DateTimeNullableWithAggregatesFilter<"AdvanceDirective"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"AdvanceDirective"> | Date | string | null
  }

  export type WitnessWhereInput = {
    AND?: WitnessWhereInput | WitnessWhereInput[]
    OR?: WitnessWhereInput[]
    NOT?: WitnessWhereInput | WitnessWhereInput[]
    id?: StringFilter<"Witness"> | string
    directiveId?: StringFilter<"Witness"> | string
    name?: StringFilter<"Witness"> | string
    curp?: StringNullableFilter<"Witness"> | string | null
    email?: StringNullableFilter<"Witness"> | string | null
    phone?: StringNullableFilter<"Witness"> | string | null
    ineImageUrl?: StringNullableFilter<"Witness"> | string | null
    selfieImageUrl?: StringNullableFilter<"Witness"> | string | null
    identityVerified?: BoolFilter<"Witness"> | boolean
    verifiedAt?: DateTimeNullableFilter<"Witness"> | Date | string | null
    signatureImageUrl?: StringNullableFilter<"Witness"> | string | null
    signedAt?: DateTimeNullableFilter<"Witness"> | Date | string | null
    sessionId?: StringNullableFilter<"Witness"> | string | null
    sessionRecordingUrl?: StringNullableFilter<"Witness"> | string | null
    sessionStartedAt?: DateTimeNullableFilter<"Witness"> | Date | string | null
    sessionEndedAt?: DateTimeNullableFilter<"Witness"> | Date | string | null
    createdAt?: DateTimeFilter<"Witness"> | Date | string
    directive?: XOR<AdvanceDirectiveRelationFilter, AdvanceDirectiveWhereInput>
  }

  export type WitnessOrderByWithRelationInput = {
    id?: SortOrder
    directiveId?: SortOrder
    name?: SortOrder
    curp?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    ineImageUrl?: SortOrderInput | SortOrder
    selfieImageUrl?: SortOrderInput | SortOrder
    identityVerified?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    signatureImageUrl?: SortOrderInput | SortOrder
    signedAt?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    sessionRecordingUrl?: SortOrderInput | SortOrder
    sessionStartedAt?: SortOrderInput | SortOrder
    sessionEndedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    directive?: AdvanceDirectiveOrderByWithRelationInput
  }

  export type WitnessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WitnessWhereInput | WitnessWhereInput[]
    OR?: WitnessWhereInput[]
    NOT?: WitnessWhereInput | WitnessWhereInput[]
    directiveId?: StringFilter<"Witness"> | string
    name?: StringFilter<"Witness"> | string
    curp?: StringNullableFilter<"Witness"> | string | null
    email?: StringNullableFilter<"Witness"> | string | null
    phone?: StringNullableFilter<"Witness"> | string | null
    ineImageUrl?: StringNullableFilter<"Witness"> | string | null
    selfieImageUrl?: StringNullableFilter<"Witness"> | string | null
    identityVerified?: BoolFilter<"Witness"> | boolean
    verifiedAt?: DateTimeNullableFilter<"Witness"> | Date | string | null
    signatureImageUrl?: StringNullableFilter<"Witness"> | string | null
    signedAt?: DateTimeNullableFilter<"Witness"> | Date | string | null
    sessionId?: StringNullableFilter<"Witness"> | string | null
    sessionRecordingUrl?: StringNullableFilter<"Witness"> | string | null
    sessionStartedAt?: DateTimeNullableFilter<"Witness"> | Date | string | null
    sessionEndedAt?: DateTimeNullableFilter<"Witness"> | Date | string | null
    createdAt?: DateTimeFilter<"Witness"> | Date | string
    directive?: XOR<AdvanceDirectiveRelationFilter, AdvanceDirectiveWhereInput>
  }, "id">

  export type WitnessOrderByWithAggregationInput = {
    id?: SortOrder
    directiveId?: SortOrder
    name?: SortOrder
    curp?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    ineImageUrl?: SortOrderInput | SortOrder
    selfieImageUrl?: SortOrderInput | SortOrder
    identityVerified?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    signatureImageUrl?: SortOrderInput | SortOrder
    signedAt?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    sessionRecordingUrl?: SortOrderInput | SortOrder
    sessionStartedAt?: SortOrderInput | SortOrder
    sessionEndedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WitnessCountOrderByAggregateInput
    _max?: WitnessMaxOrderByAggregateInput
    _min?: WitnessMinOrderByAggregateInput
  }

  export type WitnessScalarWhereWithAggregatesInput = {
    AND?: WitnessScalarWhereWithAggregatesInput | WitnessScalarWhereWithAggregatesInput[]
    OR?: WitnessScalarWhereWithAggregatesInput[]
    NOT?: WitnessScalarWhereWithAggregatesInput | WitnessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Witness"> | string
    directiveId?: StringWithAggregatesFilter<"Witness"> | string
    name?: StringWithAggregatesFilter<"Witness"> | string
    curp?: StringNullableWithAggregatesFilter<"Witness"> | string | null
    email?: StringNullableWithAggregatesFilter<"Witness"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Witness"> | string | null
    ineImageUrl?: StringNullableWithAggregatesFilter<"Witness"> | string | null
    selfieImageUrl?: StringNullableWithAggregatesFilter<"Witness"> | string | null
    identityVerified?: BoolWithAggregatesFilter<"Witness"> | boolean
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"Witness"> | Date | string | null
    signatureImageUrl?: StringNullableWithAggregatesFilter<"Witness"> | string | null
    signedAt?: DateTimeNullableWithAggregatesFilter<"Witness"> | Date | string | null
    sessionId?: StringNullableWithAggregatesFilter<"Witness"> | string | null
    sessionRecordingUrl?: StringNullableWithAggregatesFilter<"Witness"> | string | null
    sessionStartedAt?: DateTimeNullableWithAggregatesFilter<"Witness"> | Date | string | null
    sessionEndedAt?: DateTimeNullableWithAggregatesFilter<"Witness"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Witness"> | Date | string
  }

  export type EmergencyAccessWhereInput = {
    AND?: EmergencyAccessWhereInput | EmergencyAccessWhereInput[]
    OR?: EmergencyAccessWhereInput[]
    NOT?: EmergencyAccessWhereInput | EmergencyAccessWhereInput[]
    id?: StringFilter<"EmergencyAccess"> | string
    patientId?: StringFilter<"EmergencyAccess"> | string
    accessorId?: StringNullableFilter<"EmergencyAccess"> | string | null
    accessorName?: StringFilter<"EmergencyAccess"> | string
    accessorRole?: StringFilter<"EmergencyAccess"> | string
    accessorLicense?: StringNullableFilter<"EmergencyAccess"> | string | null
    institutionId?: StringNullableFilter<"EmergencyAccess"> | string | null
    institutionName?: StringNullableFilter<"EmergencyAccess"> | string | null
    insuranceId?: StringNullableFilter<"EmergencyAccess"> | string | null
    insurancePolicyNo?: StringNullableFilter<"EmergencyAccess"> | string | null
    qrTokenUsed?: StringFilter<"EmergencyAccess"> | string
    ipAddress?: StringNullableFilter<"EmergencyAccess"> | string | null
    userAgent?: StringNullableFilter<"EmergencyAccess"> | string | null
    latitude?: FloatNullableFilter<"EmergencyAccess"> | number | null
    longitude?: FloatNullableFilter<"EmergencyAccess"> | number | null
    locationName?: StringNullableFilter<"EmergencyAccess"> | string | null
    dataAccessed?: StringNullableListFilter<"EmergencyAccess">
    representativesNotified?: StringNullableListFilter<"EmergencyAccess">
    notificationsSentAt?: DateTimeNullableFilter<"EmergencyAccess"> | Date | string | null
    accessToken?: StringFilter<"EmergencyAccess"> | string
    accessedAt?: DateTimeFilter<"EmergencyAccess"> | Date | string
    expiresAt?: DateTimeFilter<"EmergencyAccess"> | Date | string
    patient?: XOR<UserRelationFilter, UserWhereInput>
    institution?: XOR<MedicalInstitutionNullableRelationFilter, MedicalInstitutionWhereInput> | null
    insurance?: XOR<InsuranceCompanyNullableRelationFilter, InsuranceCompanyWhereInput> | null
  }

  export type EmergencyAccessOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    accessorId?: SortOrderInput | SortOrder
    accessorName?: SortOrder
    accessorRole?: SortOrder
    accessorLicense?: SortOrderInput | SortOrder
    institutionId?: SortOrderInput | SortOrder
    institutionName?: SortOrderInput | SortOrder
    insuranceId?: SortOrderInput | SortOrder
    insurancePolicyNo?: SortOrderInput | SortOrder
    qrTokenUsed?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    locationName?: SortOrderInput | SortOrder
    dataAccessed?: SortOrder
    representativesNotified?: SortOrder
    notificationsSentAt?: SortOrderInput | SortOrder
    accessToken?: SortOrder
    accessedAt?: SortOrder
    expiresAt?: SortOrder
    patient?: UserOrderByWithRelationInput
    institution?: MedicalInstitutionOrderByWithRelationInput
    insurance?: InsuranceCompanyOrderByWithRelationInput
  }

  export type EmergencyAccessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accessToken?: string
    AND?: EmergencyAccessWhereInput | EmergencyAccessWhereInput[]
    OR?: EmergencyAccessWhereInput[]
    NOT?: EmergencyAccessWhereInput | EmergencyAccessWhereInput[]
    patientId?: StringFilter<"EmergencyAccess"> | string
    accessorId?: StringNullableFilter<"EmergencyAccess"> | string | null
    accessorName?: StringFilter<"EmergencyAccess"> | string
    accessorRole?: StringFilter<"EmergencyAccess"> | string
    accessorLicense?: StringNullableFilter<"EmergencyAccess"> | string | null
    institutionId?: StringNullableFilter<"EmergencyAccess"> | string | null
    institutionName?: StringNullableFilter<"EmergencyAccess"> | string | null
    insuranceId?: StringNullableFilter<"EmergencyAccess"> | string | null
    insurancePolicyNo?: StringNullableFilter<"EmergencyAccess"> | string | null
    qrTokenUsed?: StringFilter<"EmergencyAccess"> | string
    ipAddress?: StringNullableFilter<"EmergencyAccess"> | string | null
    userAgent?: StringNullableFilter<"EmergencyAccess"> | string | null
    latitude?: FloatNullableFilter<"EmergencyAccess"> | number | null
    longitude?: FloatNullableFilter<"EmergencyAccess"> | number | null
    locationName?: StringNullableFilter<"EmergencyAccess"> | string | null
    dataAccessed?: StringNullableListFilter<"EmergencyAccess">
    representativesNotified?: StringNullableListFilter<"EmergencyAccess">
    notificationsSentAt?: DateTimeNullableFilter<"EmergencyAccess"> | Date | string | null
    accessedAt?: DateTimeFilter<"EmergencyAccess"> | Date | string
    expiresAt?: DateTimeFilter<"EmergencyAccess"> | Date | string
    patient?: XOR<UserRelationFilter, UserWhereInput>
    institution?: XOR<MedicalInstitutionNullableRelationFilter, MedicalInstitutionWhereInput> | null
    insurance?: XOR<InsuranceCompanyNullableRelationFilter, InsuranceCompanyWhereInput> | null
  }, "id" | "accessToken">

  export type EmergencyAccessOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    accessorId?: SortOrderInput | SortOrder
    accessorName?: SortOrder
    accessorRole?: SortOrder
    accessorLicense?: SortOrderInput | SortOrder
    institutionId?: SortOrderInput | SortOrder
    institutionName?: SortOrderInput | SortOrder
    insuranceId?: SortOrderInput | SortOrder
    insurancePolicyNo?: SortOrderInput | SortOrder
    qrTokenUsed?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    locationName?: SortOrderInput | SortOrder
    dataAccessed?: SortOrder
    representativesNotified?: SortOrder
    notificationsSentAt?: SortOrderInput | SortOrder
    accessToken?: SortOrder
    accessedAt?: SortOrder
    expiresAt?: SortOrder
    _count?: EmergencyAccessCountOrderByAggregateInput
    _avg?: EmergencyAccessAvgOrderByAggregateInput
    _max?: EmergencyAccessMaxOrderByAggregateInput
    _min?: EmergencyAccessMinOrderByAggregateInput
    _sum?: EmergencyAccessSumOrderByAggregateInput
  }

  export type EmergencyAccessScalarWhereWithAggregatesInput = {
    AND?: EmergencyAccessScalarWhereWithAggregatesInput | EmergencyAccessScalarWhereWithAggregatesInput[]
    OR?: EmergencyAccessScalarWhereWithAggregatesInput[]
    NOT?: EmergencyAccessScalarWhereWithAggregatesInput | EmergencyAccessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmergencyAccess"> | string
    patientId?: StringWithAggregatesFilter<"EmergencyAccess"> | string
    accessorId?: StringNullableWithAggregatesFilter<"EmergencyAccess"> | string | null
    accessorName?: StringWithAggregatesFilter<"EmergencyAccess"> | string
    accessorRole?: StringWithAggregatesFilter<"EmergencyAccess"> | string
    accessorLicense?: StringNullableWithAggregatesFilter<"EmergencyAccess"> | string | null
    institutionId?: StringNullableWithAggregatesFilter<"EmergencyAccess"> | string | null
    institutionName?: StringNullableWithAggregatesFilter<"EmergencyAccess"> | string | null
    insuranceId?: StringNullableWithAggregatesFilter<"EmergencyAccess"> | string | null
    insurancePolicyNo?: StringNullableWithAggregatesFilter<"EmergencyAccess"> | string | null
    qrTokenUsed?: StringWithAggregatesFilter<"EmergencyAccess"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"EmergencyAccess"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"EmergencyAccess"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"EmergencyAccess"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"EmergencyAccess"> | number | null
    locationName?: StringNullableWithAggregatesFilter<"EmergencyAccess"> | string | null
    dataAccessed?: StringNullableListFilter<"EmergencyAccess">
    representativesNotified?: StringNullableListFilter<"EmergencyAccess">
    notificationsSentAt?: DateTimeNullableWithAggregatesFilter<"EmergencyAccess"> | Date | string | null
    accessToken?: StringWithAggregatesFilter<"EmergencyAccess"> | string
    accessedAt?: DateTimeWithAggregatesFilter<"EmergencyAccess"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"EmergencyAccess"> | Date | string
  }

  export type MedicalInstitutionWhereInput = {
    AND?: MedicalInstitutionWhereInput | MedicalInstitutionWhereInput[]
    OR?: MedicalInstitutionWhereInput[]
    NOT?: MedicalInstitutionWhereInput | MedicalInstitutionWhereInput[]
    id?: StringFilter<"MedicalInstitution"> | string
    name?: StringFilter<"MedicalInstitution"> | string
    type?: EnumInstitutionTypeFilter<"MedicalInstitution"> | $Enums.InstitutionType
    cluesCode?: StringNullableFilter<"MedicalInstitution"> | string | null
    address?: StringNullableFilter<"MedicalInstitution"> | string | null
    city?: StringNullableFilter<"MedicalInstitution"> | string | null
    state?: StringNullableFilter<"MedicalInstitution"> | string | null
    zipCode?: StringNullableFilter<"MedicalInstitution"> | string | null
    latitude?: FloatNullableFilter<"MedicalInstitution"> | number | null
    longitude?: FloatNullableFilter<"MedicalInstitution"> | number | null
    phone?: StringNullableFilter<"MedicalInstitution"> | string | null
    emergencyPhone?: StringNullableFilter<"MedicalInstitution"> | string | null
    email?: StringNullableFilter<"MedicalInstitution"> | string | null
    attentionLevel?: EnumAttentionLevelNullableFilter<"MedicalInstitution"> | $Enums.AttentionLevel | null
    specialties?: StringNullableListFilter<"MedicalInstitution">
    hasEmergency?: BoolFilter<"MedicalInstitution"> | boolean
    has24Hours?: BoolFilter<"MedicalInstitution"> | boolean
    hasICU?: BoolFilter<"MedicalInstitution"> | boolean
    hasTrauma?: BoolFilter<"MedicalInstitution"> | boolean
    oauthClientId?: StringNullableFilter<"MedicalInstitution"> | string | null
    oauthClientSecret?: StringNullableFilter<"MedicalInstitution"> | string | null
    isActive?: BoolFilter<"MedicalInstitution"> | boolean
    isVerified?: BoolFilter<"MedicalInstitution"> | boolean
    verifiedAt?: DateTimeNullableFilter<"MedicalInstitution"> | Date | string | null
    createdAt?: DateTimeFilter<"MedicalInstitution"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalInstitution"> | Date | string
    emergencyAccesses?: EmergencyAccessListRelationFilter
    staff?: MedicalStaffListRelationFilter
    insuranceNetworks?: InsuranceCompanyListRelationFilter
  }

  export type MedicalInstitutionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    cluesCode?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    emergencyPhone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    attentionLevel?: SortOrderInput | SortOrder
    specialties?: SortOrder
    hasEmergency?: SortOrder
    has24Hours?: SortOrder
    hasICU?: SortOrder
    hasTrauma?: SortOrder
    oauthClientId?: SortOrderInput | SortOrder
    oauthClientSecret?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emergencyAccesses?: EmergencyAccessOrderByRelationAggregateInput
    staff?: MedicalStaffOrderByRelationAggregateInput
    insuranceNetworks?: InsuranceCompanyOrderByRelationAggregateInput
  }

  export type MedicalInstitutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cluesCode?: string
    oauthClientId?: string
    AND?: MedicalInstitutionWhereInput | MedicalInstitutionWhereInput[]
    OR?: MedicalInstitutionWhereInput[]
    NOT?: MedicalInstitutionWhereInput | MedicalInstitutionWhereInput[]
    name?: StringFilter<"MedicalInstitution"> | string
    type?: EnumInstitutionTypeFilter<"MedicalInstitution"> | $Enums.InstitutionType
    address?: StringNullableFilter<"MedicalInstitution"> | string | null
    city?: StringNullableFilter<"MedicalInstitution"> | string | null
    state?: StringNullableFilter<"MedicalInstitution"> | string | null
    zipCode?: StringNullableFilter<"MedicalInstitution"> | string | null
    latitude?: FloatNullableFilter<"MedicalInstitution"> | number | null
    longitude?: FloatNullableFilter<"MedicalInstitution"> | number | null
    phone?: StringNullableFilter<"MedicalInstitution"> | string | null
    emergencyPhone?: StringNullableFilter<"MedicalInstitution"> | string | null
    email?: StringNullableFilter<"MedicalInstitution"> | string | null
    attentionLevel?: EnumAttentionLevelNullableFilter<"MedicalInstitution"> | $Enums.AttentionLevel | null
    specialties?: StringNullableListFilter<"MedicalInstitution">
    hasEmergency?: BoolFilter<"MedicalInstitution"> | boolean
    has24Hours?: BoolFilter<"MedicalInstitution"> | boolean
    hasICU?: BoolFilter<"MedicalInstitution"> | boolean
    hasTrauma?: BoolFilter<"MedicalInstitution"> | boolean
    oauthClientSecret?: StringNullableFilter<"MedicalInstitution"> | string | null
    isActive?: BoolFilter<"MedicalInstitution"> | boolean
    isVerified?: BoolFilter<"MedicalInstitution"> | boolean
    verifiedAt?: DateTimeNullableFilter<"MedicalInstitution"> | Date | string | null
    createdAt?: DateTimeFilter<"MedicalInstitution"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalInstitution"> | Date | string
    emergencyAccesses?: EmergencyAccessListRelationFilter
    staff?: MedicalStaffListRelationFilter
    insuranceNetworks?: InsuranceCompanyListRelationFilter
  }, "id" | "cluesCode" | "oauthClientId">

  export type MedicalInstitutionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    cluesCode?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    emergencyPhone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    attentionLevel?: SortOrderInput | SortOrder
    specialties?: SortOrder
    hasEmergency?: SortOrder
    has24Hours?: SortOrder
    hasICU?: SortOrder
    hasTrauma?: SortOrder
    oauthClientId?: SortOrderInput | SortOrder
    oauthClientSecret?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicalInstitutionCountOrderByAggregateInput
    _avg?: MedicalInstitutionAvgOrderByAggregateInput
    _max?: MedicalInstitutionMaxOrderByAggregateInput
    _min?: MedicalInstitutionMinOrderByAggregateInput
    _sum?: MedicalInstitutionSumOrderByAggregateInput
  }

  export type MedicalInstitutionScalarWhereWithAggregatesInput = {
    AND?: MedicalInstitutionScalarWhereWithAggregatesInput | MedicalInstitutionScalarWhereWithAggregatesInput[]
    OR?: MedicalInstitutionScalarWhereWithAggregatesInput[]
    NOT?: MedicalInstitutionScalarWhereWithAggregatesInput | MedicalInstitutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicalInstitution"> | string
    name?: StringWithAggregatesFilter<"MedicalInstitution"> | string
    type?: EnumInstitutionTypeWithAggregatesFilter<"MedicalInstitution"> | $Enums.InstitutionType
    cluesCode?: StringNullableWithAggregatesFilter<"MedicalInstitution"> | string | null
    address?: StringNullableWithAggregatesFilter<"MedicalInstitution"> | string | null
    city?: StringNullableWithAggregatesFilter<"MedicalInstitution"> | string | null
    state?: StringNullableWithAggregatesFilter<"MedicalInstitution"> | string | null
    zipCode?: StringNullableWithAggregatesFilter<"MedicalInstitution"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"MedicalInstitution"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"MedicalInstitution"> | number | null
    phone?: StringNullableWithAggregatesFilter<"MedicalInstitution"> | string | null
    emergencyPhone?: StringNullableWithAggregatesFilter<"MedicalInstitution"> | string | null
    email?: StringNullableWithAggregatesFilter<"MedicalInstitution"> | string | null
    attentionLevel?: EnumAttentionLevelNullableWithAggregatesFilter<"MedicalInstitution"> | $Enums.AttentionLevel | null
    specialties?: StringNullableListFilter<"MedicalInstitution">
    hasEmergency?: BoolWithAggregatesFilter<"MedicalInstitution"> | boolean
    has24Hours?: BoolWithAggregatesFilter<"MedicalInstitution"> | boolean
    hasICU?: BoolWithAggregatesFilter<"MedicalInstitution"> | boolean
    hasTrauma?: BoolWithAggregatesFilter<"MedicalInstitution"> | boolean
    oauthClientId?: StringNullableWithAggregatesFilter<"MedicalInstitution"> | string | null
    oauthClientSecret?: StringNullableWithAggregatesFilter<"MedicalInstitution"> | string | null
    isActive?: BoolWithAggregatesFilter<"MedicalInstitution"> | boolean
    isVerified?: BoolWithAggregatesFilter<"MedicalInstitution"> | boolean
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"MedicalInstitution"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MedicalInstitution"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MedicalInstitution"> | Date | string
  }

  export type InsuranceCompanyWhereInput = {
    AND?: InsuranceCompanyWhereInput | InsuranceCompanyWhereInput[]
    OR?: InsuranceCompanyWhereInput[]
    NOT?: InsuranceCompanyWhereInput | InsuranceCompanyWhereInput[]
    id?: StringFilter<"InsuranceCompany"> | string
    name?: StringFilter<"InsuranceCompany"> | string
    shortName?: StringNullableFilter<"InsuranceCompany"> | string | null
    type?: EnumInsuranceTypeFilter<"InsuranceCompany"> | $Enums.InsuranceType
    cnsfNumber?: StringNullableFilter<"InsuranceCompany"> | string | null
    rfc?: StringNullableFilter<"InsuranceCompany"> | string | null
    address?: StringNullableFilter<"InsuranceCompany"> | string | null
    city?: StringNullableFilter<"InsuranceCompany"> | string | null
    state?: StringNullableFilter<"InsuranceCompany"> | string | null
    zipCode?: StringNullableFilter<"InsuranceCompany"> | string | null
    phone?: StringNullableFilter<"InsuranceCompany"> | string | null
    emergencyPhone?: StringNullableFilter<"InsuranceCompany"> | string | null
    email?: StringNullableFilter<"InsuranceCompany"> | string | null
    website?: StringNullableFilter<"InsuranceCompany"> | string | null
    coverageTypes?: StringNullableListFilter<"InsuranceCompany">
    networkSize?: IntNullableFilter<"InsuranceCompany"> | number | null
    hasNationalCoverage?: BoolFilter<"InsuranceCompany"> | boolean
    statesCovered?: StringNullableListFilter<"InsuranceCompany">
    isVerified?: BoolFilter<"InsuranceCompany"> | boolean
    verifiedAt?: DateTimeNullableFilter<"InsuranceCompany"> | Date | string | null
    verifiedBy?: StringNullableFilter<"InsuranceCompany"> | string | null
    apiEnabled?: BoolFilter<"InsuranceCompany"> | boolean
    apiEndpoint?: StringNullableFilter<"InsuranceCompany"> | string | null
    logoUrl?: StringNullableFilter<"InsuranceCompany"> | string | null
    description?: StringNullableFilter<"InsuranceCompany"> | string | null
    isActive?: BoolFilter<"InsuranceCompany"> | boolean
    createdAt?: DateTimeFilter<"InsuranceCompany"> | Date | string
    updatedAt?: DateTimeFilter<"InsuranceCompany"> | Date | string
    plans?: InsurancePlanListRelationFilter
    networkHospitals?: MedicalInstitutionListRelationFilter
    emergencyAccesses?: EmergencyAccessListRelationFilter
  }

  export type InsuranceCompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrderInput | SortOrder
    type?: SortOrder
    cnsfNumber?: SortOrderInput | SortOrder
    rfc?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    emergencyPhone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    coverageTypes?: SortOrder
    networkSize?: SortOrderInput | SortOrder
    hasNationalCoverage?: SortOrder
    statesCovered?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    apiEnabled?: SortOrder
    apiEndpoint?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plans?: InsurancePlanOrderByRelationAggregateInput
    networkHospitals?: MedicalInstitutionOrderByRelationAggregateInput
    emergencyAccesses?: EmergencyAccessOrderByRelationAggregateInput
  }

  export type InsuranceCompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cnsfNumber?: string
    rfc?: string
    AND?: InsuranceCompanyWhereInput | InsuranceCompanyWhereInput[]
    OR?: InsuranceCompanyWhereInput[]
    NOT?: InsuranceCompanyWhereInput | InsuranceCompanyWhereInput[]
    name?: StringFilter<"InsuranceCompany"> | string
    shortName?: StringNullableFilter<"InsuranceCompany"> | string | null
    type?: EnumInsuranceTypeFilter<"InsuranceCompany"> | $Enums.InsuranceType
    address?: StringNullableFilter<"InsuranceCompany"> | string | null
    city?: StringNullableFilter<"InsuranceCompany"> | string | null
    state?: StringNullableFilter<"InsuranceCompany"> | string | null
    zipCode?: StringNullableFilter<"InsuranceCompany"> | string | null
    phone?: StringNullableFilter<"InsuranceCompany"> | string | null
    emergencyPhone?: StringNullableFilter<"InsuranceCompany"> | string | null
    email?: StringNullableFilter<"InsuranceCompany"> | string | null
    website?: StringNullableFilter<"InsuranceCompany"> | string | null
    coverageTypes?: StringNullableListFilter<"InsuranceCompany">
    networkSize?: IntNullableFilter<"InsuranceCompany"> | number | null
    hasNationalCoverage?: BoolFilter<"InsuranceCompany"> | boolean
    statesCovered?: StringNullableListFilter<"InsuranceCompany">
    isVerified?: BoolFilter<"InsuranceCompany"> | boolean
    verifiedAt?: DateTimeNullableFilter<"InsuranceCompany"> | Date | string | null
    verifiedBy?: StringNullableFilter<"InsuranceCompany"> | string | null
    apiEnabled?: BoolFilter<"InsuranceCompany"> | boolean
    apiEndpoint?: StringNullableFilter<"InsuranceCompany"> | string | null
    logoUrl?: StringNullableFilter<"InsuranceCompany"> | string | null
    description?: StringNullableFilter<"InsuranceCompany"> | string | null
    isActive?: BoolFilter<"InsuranceCompany"> | boolean
    createdAt?: DateTimeFilter<"InsuranceCompany"> | Date | string
    updatedAt?: DateTimeFilter<"InsuranceCompany"> | Date | string
    plans?: InsurancePlanListRelationFilter
    networkHospitals?: MedicalInstitutionListRelationFilter
    emergencyAccesses?: EmergencyAccessListRelationFilter
  }, "id" | "cnsfNumber" | "rfc">

  export type InsuranceCompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrderInput | SortOrder
    type?: SortOrder
    cnsfNumber?: SortOrderInput | SortOrder
    rfc?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    emergencyPhone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    coverageTypes?: SortOrder
    networkSize?: SortOrderInput | SortOrder
    hasNationalCoverage?: SortOrder
    statesCovered?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    apiEnabled?: SortOrder
    apiEndpoint?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InsuranceCompanyCountOrderByAggregateInput
    _avg?: InsuranceCompanyAvgOrderByAggregateInput
    _max?: InsuranceCompanyMaxOrderByAggregateInput
    _min?: InsuranceCompanyMinOrderByAggregateInput
    _sum?: InsuranceCompanySumOrderByAggregateInput
  }

  export type InsuranceCompanyScalarWhereWithAggregatesInput = {
    AND?: InsuranceCompanyScalarWhereWithAggregatesInput | InsuranceCompanyScalarWhereWithAggregatesInput[]
    OR?: InsuranceCompanyScalarWhereWithAggregatesInput[]
    NOT?: InsuranceCompanyScalarWhereWithAggregatesInput | InsuranceCompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InsuranceCompany"> | string
    name?: StringWithAggregatesFilter<"InsuranceCompany"> | string
    shortName?: StringNullableWithAggregatesFilter<"InsuranceCompany"> | string | null
    type?: EnumInsuranceTypeWithAggregatesFilter<"InsuranceCompany"> | $Enums.InsuranceType
    cnsfNumber?: StringNullableWithAggregatesFilter<"InsuranceCompany"> | string | null
    rfc?: StringNullableWithAggregatesFilter<"InsuranceCompany"> | string | null
    address?: StringNullableWithAggregatesFilter<"InsuranceCompany"> | string | null
    city?: StringNullableWithAggregatesFilter<"InsuranceCompany"> | string | null
    state?: StringNullableWithAggregatesFilter<"InsuranceCompany"> | string | null
    zipCode?: StringNullableWithAggregatesFilter<"InsuranceCompany"> | string | null
    phone?: StringNullableWithAggregatesFilter<"InsuranceCompany"> | string | null
    emergencyPhone?: StringNullableWithAggregatesFilter<"InsuranceCompany"> | string | null
    email?: StringNullableWithAggregatesFilter<"InsuranceCompany"> | string | null
    website?: StringNullableWithAggregatesFilter<"InsuranceCompany"> | string | null
    coverageTypes?: StringNullableListFilter<"InsuranceCompany">
    networkSize?: IntNullableWithAggregatesFilter<"InsuranceCompany"> | number | null
    hasNationalCoverage?: BoolWithAggregatesFilter<"InsuranceCompany"> | boolean
    statesCovered?: StringNullableListFilter<"InsuranceCompany">
    isVerified?: BoolWithAggregatesFilter<"InsuranceCompany"> | boolean
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"InsuranceCompany"> | Date | string | null
    verifiedBy?: StringNullableWithAggregatesFilter<"InsuranceCompany"> | string | null
    apiEnabled?: BoolWithAggregatesFilter<"InsuranceCompany"> | boolean
    apiEndpoint?: StringNullableWithAggregatesFilter<"InsuranceCompany"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"InsuranceCompany"> | string | null
    description?: StringNullableWithAggregatesFilter<"InsuranceCompany"> | string | null
    isActive?: BoolWithAggregatesFilter<"InsuranceCompany"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"InsuranceCompany"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InsuranceCompany"> | Date | string
  }

  export type InsurancePlanWhereInput = {
    AND?: InsurancePlanWhereInput | InsurancePlanWhereInput[]
    OR?: InsurancePlanWhereInput[]
    NOT?: InsurancePlanWhereInput | InsurancePlanWhereInput[]
    id?: StringFilter<"InsurancePlan"> | string
    insuranceId?: StringFilter<"InsurancePlan"> | string
    name?: StringFilter<"InsurancePlan"> | string
    code?: StringNullableFilter<"InsurancePlan"> | string | null
    sumAssured?: FloatNullableFilter<"InsurancePlan"> | number | null
    deductible?: FloatNullableFilter<"InsurancePlan"> | number | null
    coinsurance?: FloatNullableFilter<"InsurancePlan"> | number | null
    features?: StringNullableListFilter<"InsurancePlan">
    exclusions?: StringNullableListFilter<"InsurancePlan">
    hospitalLevel?: StringNullableFilter<"InsurancePlan"> | string | null
    isActive?: BoolFilter<"InsurancePlan"> | boolean
    createdAt?: DateTimeFilter<"InsurancePlan"> | Date | string
    updatedAt?: DateTimeFilter<"InsurancePlan"> | Date | string
    insurance?: XOR<InsuranceCompanyRelationFilter, InsuranceCompanyWhereInput>
  }

  export type InsurancePlanOrderByWithRelationInput = {
    id?: SortOrder
    insuranceId?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    sumAssured?: SortOrderInput | SortOrder
    deductible?: SortOrderInput | SortOrder
    coinsurance?: SortOrderInput | SortOrder
    features?: SortOrder
    exclusions?: SortOrder
    hospitalLevel?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    insurance?: InsuranceCompanyOrderByWithRelationInput
  }

  export type InsurancePlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InsurancePlanWhereInput | InsurancePlanWhereInput[]
    OR?: InsurancePlanWhereInput[]
    NOT?: InsurancePlanWhereInput | InsurancePlanWhereInput[]
    insuranceId?: StringFilter<"InsurancePlan"> | string
    name?: StringFilter<"InsurancePlan"> | string
    code?: StringNullableFilter<"InsurancePlan"> | string | null
    sumAssured?: FloatNullableFilter<"InsurancePlan"> | number | null
    deductible?: FloatNullableFilter<"InsurancePlan"> | number | null
    coinsurance?: FloatNullableFilter<"InsurancePlan"> | number | null
    features?: StringNullableListFilter<"InsurancePlan">
    exclusions?: StringNullableListFilter<"InsurancePlan">
    hospitalLevel?: StringNullableFilter<"InsurancePlan"> | string | null
    isActive?: BoolFilter<"InsurancePlan"> | boolean
    createdAt?: DateTimeFilter<"InsurancePlan"> | Date | string
    updatedAt?: DateTimeFilter<"InsurancePlan"> | Date | string
    insurance?: XOR<InsuranceCompanyRelationFilter, InsuranceCompanyWhereInput>
  }, "id">

  export type InsurancePlanOrderByWithAggregationInput = {
    id?: SortOrder
    insuranceId?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    sumAssured?: SortOrderInput | SortOrder
    deductible?: SortOrderInput | SortOrder
    coinsurance?: SortOrderInput | SortOrder
    features?: SortOrder
    exclusions?: SortOrder
    hospitalLevel?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InsurancePlanCountOrderByAggregateInput
    _avg?: InsurancePlanAvgOrderByAggregateInput
    _max?: InsurancePlanMaxOrderByAggregateInput
    _min?: InsurancePlanMinOrderByAggregateInput
    _sum?: InsurancePlanSumOrderByAggregateInput
  }

  export type InsurancePlanScalarWhereWithAggregatesInput = {
    AND?: InsurancePlanScalarWhereWithAggregatesInput | InsurancePlanScalarWhereWithAggregatesInput[]
    OR?: InsurancePlanScalarWhereWithAggregatesInput[]
    NOT?: InsurancePlanScalarWhereWithAggregatesInput | InsurancePlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InsurancePlan"> | string
    insuranceId?: StringWithAggregatesFilter<"InsurancePlan"> | string
    name?: StringWithAggregatesFilter<"InsurancePlan"> | string
    code?: StringNullableWithAggregatesFilter<"InsurancePlan"> | string | null
    sumAssured?: FloatNullableWithAggregatesFilter<"InsurancePlan"> | number | null
    deductible?: FloatNullableWithAggregatesFilter<"InsurancePlan"> | number | null
    coinsurance?: FloatNullableWithAggregatesFilter<"InsurancePlan"> | number | null
    features?: StringNullableListFilter<"InsurancePlan">
    exclusions?: StringNullableListFilter<"InsurancePlan">
    hospitalLevel?: StringNullableWithAggregatesFilter<"InsurancePlan"> | string | null
    isActive?: BoolWithAggregatesFilter<"InsurancePlan"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"InsurancePlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InsurancePlan"> | Date | string
  }

  export type MedicalStaffWhereInput = {
    AND?: MedicalStaffWhereInput | MedicalStaffWhereInput[]
    OR?: MedicalStaffWhereInput[]
    NOT?: MedicalStaffWhereInput | MedicalStaffWhereInput[]
    id?: StringFilter<"MedicalStaff"> | string
    institutionId?: StringFilter<"MedicalStaff"> | string
    name?: StringFilter<"MedicalStaff"> | string
    email?: StringFilter<"MedicalStaff"> | string
    passwordHash?: StringFilter<"MedicalStaff"> | string
    role?: EnumStaffRoleFilter<"MedicalStaff"> | $Enums.StaffRole
    license?: StringNullableFilter<"MedicalStaff"> | string | null
    isActive?: BoolFilter<"MedicalStaff"> | boolean
    createdAt?: DateTimeFilter<"MedicalStaff"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalStaff"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"MedicalStaff"> | Date | string | null
    institution?: XOR<MedicalInstitutionRelationFilter, MedicalInstitutionWhereInput>
  }

  export type MedicalStaffOrderByWithRelationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    license?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    institution?: MedicalInstitutionOrderByWithRelationInput
  }

  export type MedicalStaffWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: MedicalStaffWhereInput | MedicalStaffWhereInput[]
    OR?: MedicalStaffWhereInput[]
    NOT?: MedicalStaffWhereInput | MedicalStaffWhereInput[]
    institutionId?: StringFilter<"MedicalStaff"> | string
    name?: StringFilter<"MedicalStaff"> | string
    passwordHash?: StringFilter<"MedicalStaff"> | string
    role?: EnumStaffRoleFilter<"MedicalStaff"> | $Enums.StaffRole
    license?: StringNullableFilter<"MedicalStaff"> | string | null
    isActive?: BoolFilter<"MedicalStaff"> | boolean
    createdAt?: DateTimeFilter<"MedicalStaff"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalStaff"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"MedicalStaff"> | Date | string | null
    institution?: XOR<MedicalInstitutionRelationFilter, MedicalInstitutionWhereInput>
  }, "id" | "email">

  export type MedicalStaffOrderByWithAggregationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    license?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    _count?: MedicalStaffCountOrderByAggregateInput
    _max?: MedicalStaffMaxOrderByAggregateInput
    _min?: MedicalStaffMinOrderByAggregateInput
  }

  export type MedicalStaffScalarWhereWithAggregatesInput = {
    AND?: MedicalStaffScalarWhereWithAggregatesInput | MedicalStaffScalarWhereWithAggregatesInput[]
    OR?: MedicalStaffScalarWhereWithAggregatesInput[]
    NOT?: MedicalStaffScalarWhereWithAggregatesInput | MedicalStaffScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicalStaff"> | string
    institutionId?: StringWithAggregatesFilter<"MedicalStaff"> | string
    name?: StringWithAggregatesFilter<"MedicalStaff"> | string
    email?: StringWithAggregatesFilter<"MedicalStaff"> | string
    passwordHash?: StringWithAggregatesFilter<"MedicalStaff"> | string
    role?: EnumStaffRoleWithAggregatesFilter<"MedicalStaff"> | $Enums.StaffRole
    license?: StringNullableWithAggregatesFilter<"MedicalStaff"> | string | null
    isActive?: BoolWithAggregatesFilter<"MedicalStaff"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MedicalStaff"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MedicalStaff"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"MedicalStaff"> | Date | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    actorType?: StringFilter<"AuditLog"> | string
    actorId?: StringNullableFilter<"AuditLog"> | string | null
    actorName?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    oldValue?: JsonNullableFilter<"AuditLog">
    newValue?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    actorType?: SortOrder
    actorId?: SortOrderInput | SortOrder
    actorName?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    actorType?: StringFilter<"AuditLog"> | string
    actorId?: StringNullableFilter<"AuditLog"> | string | null
    actorName?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    oldValue?: JsonNullableFilter<"AuditLog">
    newValue?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    actorType?: SortOrder
    actorId?: SortOrderInput | SortOrder
    actorName?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    actorType?: StringWithAggregatesFilter<"AuditLog"> | string
    actorId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    actorName?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resource?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    oldValue?: JsonNullableWithAggregatesFilter<"AuditLog">
    newValue?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type StateLegalTemplateWhereInput = {
    AND?: StateLegalTemplateWhereInput | StateLegalTemplateWhereInput[]
    OR?: StateLegalTemplateWhereInput[]
    NOT?: StateLegalTemplateWhereInput | StateLegalTemplateWhereInput[]
    id?: StringFilter<"StateLegalTemplate"> | string
    stateCode?: StringFilter<"StateLegalTemplate"> | string
    stateName?: StringFilter<"StateLegalTemplate"> | string
    lawName?: StringFilter<"StateLegalTemplate"> | string
    lawDate?: DateTimeNullableFilter<"StateLegalTemplate"> | Date | string | null
    lawSummary?: StringNullableFilter<"StateLegalTemplate"> | string | null
    templateHtml?: StringNullableFilter<"StateLegalTemplate"> | string | null
    templateFields?: JsonNullableFilter<"StateLegalTemplate">
    requiresNotary?: BoolFilter<"StateLegalTemplate"> | boolean
    requiresWitnesses?: IntFilter<"StateLegalTemplate"> | number
    requiresMedicalCert?: BoolFilter<"StateLegalTemplate"> | boolean
    isActive?: BoolFilter<"StateLegalTemplate"> | boolean
    createdAt?: DateTimeFilter<"StateLegalTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"StateLegalTemplate"> | Date | string
  }

  export type StateLegalTemplateOrderByWithRelationInput = {
    id?: SortOrder
    stateCode?: SortOrder
    stateName?: SortOrder
    lawName?: SortOrder
    lawDate?: SortOrderInput | SortOrder
    lawSummary?: SortOrderInput | SortOrder
    templateHtml?: SortOrderInput | SortOrder
    templateFields?: SortOrderInput | SortOrder
    requiresNotary?: SortOrder
    requiresWitnesses?: SortOrder
    requiresMedicalCert?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StateLegalTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stateCode?: string
    AND?: StateLegalTemplateWhereInput | StateLegalTemplateWhereInput[]
    OR?: StateLegalTemplateWhereInput[]
    NOT?: StateLegalTemplateWhereInput | StateLegalTemplateWhereInput[]
    stateName?: StringFilter<"StateLegalTemplate"> | string
    lawName?: StringFilter<"StateLegalTemplate"> | string
    lawDate?: DateTimeNullableFilter<"StateLegalTemplate"> | Date | string | null
    lawSummary?: StringNullableFilter<"StateLegalTemplate"> | string | null
    templateHtml?: StringNullableFilter<"StateLegalTemplate"> | string | null
    templateFields?: JsonNullableFilter<"StateLegalTemplate">
    requiresNotary?: BoolFilter<"StateLegalTemplate"> | boolean
    requiresWitnesses?: IntFilter<"StateLegalTemplate"> | number
    requiresMedicalCert?: BoolFilter<"StateLegalTemplate"> | boolean
    isActive?: BoolFilter<"StateLegalTemplate"> | boolean
    createdAt?: DateTimeFilter<"StateLegalTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"StateLegalTemplate"> | Date | string
  }, "id" | "stateCode">

  export type StateLegalTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    stateCode?: SortOrder
    stateName?: SortOrder
    lawName?: SortOrder
    lawDate?: SortOrderInput | SortOrder
    lawSummary?: SortOrderInput | SortOrder
    templateHtml?: SortOrderInput | SortOrder
    templateFields?: SortOrderInput | SortOrder
    requiresNotary?: SortOrder
    requiresWitnesses?: SortOrder
    requiresMedicalCert?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StateLegalTemplateCountOrderByAggregateInput
    _avg?: StateLegalTemplateAvgOrderByAggregateInput
    _max?: StateLegalTemplateMaxOrderByAggregateInput
    _min?: StateLegalTemplateMinOrderByAggregateInput
    _sum?: StateLegalTemplateSumOrderByAggregateInput
  }

  export type StateLegalTemplateScalarWhereWithAggregatesInput = {
    AND?: StateLegalTemplateScalarWhereWithAggregatesInput | StateLegalTemplateScalarWhereWithAggregatesInput[]
    OR?: StateLegalTemplateScalarWhereWithAggregatesInput[]
    NOT?: StateLegalTemplateScalarWhereWithAggregatesInput | StateLegalTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StateLegalTemplate"> | string
    stateCode?: StringWithAggregatesFilter<"StateLegalTemplate"> | string
    stateName?: StringWithAggregatesFilter<"StateLegalTemplate"> | string
    lawName?: StringWithAggregatesFilter<"StateLegalTemplate"> | string
    lawDate?: DateTimeNullableWithAggregatesFilter<"StateLegalTemplate"> | Date | string | null
    lawSummary?: StringNullableWithAggregatesFilter<"StateLegalTemplate"> | string | null
    templateHtml?: StringNullableWithAggregatesFilter<"StateLegalTemplate"> | string | null
    templateFields?: JsonNullableWithAggregatesFilter<"StateLegalTemplate">
    requiresNotary?: BoolWithAggregatesFilter<"StateLegalTemplate"> | boolean
    requiresWitnesses?: IntWithAggregatesFilter<"StateLegalTemplate"> | number
    requiresMedicalCert?: BoolWithAggregatesFilter<"StateLegalTemplate"> | boolean
    isActive?: BoolWithAggregatesFilter<"StateLegalTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StateLegalTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StateLegalTemplate"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringNullableFilter<"Notification"> | string | null
    email?: StringNullableFilter<"Notification"> | string | null
    phone?: StringNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    channel?: EnumNotificationChannelFilter<"Notification"> | $Enums.NotificationChannel
    subject?: StringNullableFilter<"Notification"> | string | null
    body?: StringFilter<"Notification"> | string
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    errorMessage?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    type?: SortOrder
    channel?: SortOrder
    subject?: SortOrderInput | SortOrder
    body?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringNullableFilter<"Notification"> | string | null
    email?: StringNullableFilter<"Notification"> | string | null
    phone?: StringNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    channel?: EnumNotificationChannelFilter<"Notification"> | $Enums.NotificationChannel
    subject?: StringNullableFilter<"Notification"> | string | null
    body?: StringFilter<"Notification"> | string
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    errorMessage?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    type?: SortOrder
    channel?: SortOrder
    subject?: SortOrderInput | SortOrder
    body?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    email?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    channel?: EnumNotificationChannelWithAggregatesFilter<"Notification"> | $Enums.NotificationChannel
    subject?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    body?: StringWithAggregatesFilter<"Notification"> | string
    status?: EnumNotificationStatusWithAggregatesFilter<"Notification"> | $Enums.NotificationStatus
    sentAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    failedAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type PanicAlertWhereInput = {
    AND?: PanicAlertWhereInput | PanicAlertWhereInput[]
    OR?: PanicAlertWhereInput[]
    NOT?: PanicAlertWhereInput | PanicAlertWhereInput[]
    id?: StringFilter<"PanicAlert"> | string
    userId?: StringFilter<"PanicAlert"> | string
    latitude?: FloatFilter<"PanicAlert"> | number
    longitude?: FloatFilter<"PanicAlert"> | number
    accuracy?: FloatNullableFilter<"PanicAlert"> | number | null
    locationName?: StringNullableFilter<"PanicAlert"> | string | null
    status?: EnumPanicStatusFilter<"PanicAlert"> | $Enums.PanicStatus
    message?: StringNullableFilter<"PanicAlert"> | string | null
    cancelledAt?: DateTimeNullableFilter<"PanicAlert"> | Date | string | null
    resolvedAt?: DateTimeNullableFilter<"PanicAlert"> | Date | string | null
    nearbyHospitals?: JsonNullableFilter<"PanicAlert">
    notificationsSent?: JsonNullableFilter<"PanicAlert">
    createdAt?: DateTimeFilter<"PanicAlert"> | Date | string
    updatedAt?: DateTimeFilter<"PanicAlert"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PanicAlertOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrderInput | SortOrder
    locationName?: SortOrderInput | SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    nearbyHospitals?: SortOrderInput | SortOrder
    notificationsSent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PanicAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PanicAlertWhereInput | PanicAlertWhereInput[]
    OR?: PanicAlertWhereInput[]
    NOT?: PanicAlertWhereInput | PanicAlertWhereInput[]
    userId?: StringFilter<"PanicAlert"> | string
    latitude?: FloatFilter<"PanicAlert"> | number
    longitude?: FloatFilter<"PanicAlert"> | number
    accuracy?: FloatNullableFilter<"PanicAlert"> | number | null
    locationName?: StringNullableFilter<"PanicAlert"> | string | null
    status?: EnumPanicStatusFilter<"PanicAlert"> | $Enums.PanicStatus
    message?: StringNullableFilter<"PanicAlert"> | string | null
    cancelledAt?: DateTimeNullableFilter<"PanicAlert"> | Date | string | null
    resolvedAt?: DateTimeNullableFilter<"PanicAlert"> | Date | string | null
    nearbyHospitals?: JsonNullableFilter<"PanicAlert">
    notificationsSent?: JsonNullableFilter<"PanicAlert">
    createdAt?: DateTimeFilter<"PanicAlert"> | Date | string
    updatedAt?: DateTimeFilter<"PanicAlert"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type PanicAlertOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrderInput | SortOrder
    locationName?: SortOrderInput | SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    nearbyHospitals?: SortOrderInput | SortOrder
    notificationsSent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PanicAlertCountOrderByAggregateInput
    _avg?: PanicAlertAvgOrderByAggregateInput
    _max?: PanicAlertMaxOrderByAggregateInput
    _min?: PanicAlertMinOrderByAggregateInput
    _sum?: PanicAlertSumOrderByAggregateInput
  }

  export type PanicAlertScalarWhereWithAggregatesInput = {
    AND?: PanicAlertScalarWhereWithAggregatesInput | PanicAlertScalarWhereWithAggregatesInput[]
    OR?: PanicAlertScalarWhereWithAggregatesInput[]
    NOT?: PanicAlertScalarWhereWithAggregatesInput | PanicAlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PanicAlert"> | string
    userId?: StringWithAggregatesFilter<"PanicAlert"> | string
    latitude?: FloatWithAggregatesFilter<"PanicAlert"> | number
    longitude?: FloatWithAggregatesFilter<"PanicAlert"> | number
    accuracy?: FloatNullableWithAggregatesFilter<"PanicAlert"> | number | null
    locationName?: StringNullableWithAggregatesFilter<"PanicAlert"> | string | null
    status?: EnumPanicStatusWithAggregatesFilter<"PanicAlert"> | $Enums.PanicStatus
    message?: StringNullableWithAggregatesFilter<"PanicAlert"> | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"PanicAlert"> | Date | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"PanicAlert"> | Date | string | null
    nearbyHospitals?: JsonNullableWithAggregatesFilter<"PanicAlert">
    notificationsSent?: JsonNullableWithAggregatesFilter<"PanicAlert">
    createdAt?: DateTimeWithAggregatesFilter<"PanicAlert"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PanicAlert"> | Date | string
  }

  export type AdminUserWhereInput = {
    AND?: AdminUserWhereInput | AdminUserWhereInput[]
    OR?: AdminUserWhereInput[]
    NOT?: AdminUserWhereInput | AdminUserWhereInput[]
    id?: StringFilter<"AdminUser"> | string
    email?: StringFilter<"AdminUser"> | string
    passwordHash?: StringFilter<"AdminUser"> | string
    name?: StringFilter<"AdminUser"> | string
    role?: EnumAdminRoleFilter<"AdminUser"> | $Enums.AdminRole
    permissions?: StringNullableListFilter<"AdminUser">
    isActive?: BoolFilter<"AdminUser"> | boolean
    isSuperAdmin?: BoolFilter<"AdminUser"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"AdminUser"> | string | null
    failedAttempts?: IntFilter<"AdminUser"> | number
    lockedUntil?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    createdAt?: DateTimeFilter<"AdminUser"> | Date | string
    updatedAt?: DateTimeFilter<"AdminUser"> | Date | string
    createdBy?: StringNullableFilter<"AdminUser"> | string | null
    sessions?: AdminSessionListRelationFilter
    auditActions?: AdminAuditLogListRelationFilter
  }

  export type AdminUserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    isActive?: SortOrder
    isSuperAdmin?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastLoginIp?: SortOrderInput | SortOrder
    failedAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    sessions?: AdminSessionOrderByRelationAggregateInput
    auditActions?: AdminAuditLogOrderByRelationAggregateInput
  }

  export type AdminUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: AdminUserWhereInput | AdminUserWhereInput[]
    OR?: AdminUserWhereInput[]
    NOT?: AdminUserWhereInput | AdminUserWhereInput[]
    passwordHash?: StringFilter<"AdminUser"> | string
    name?: StringFilter<"AdminUser"> | string
    role?: EnumAdminRoleFilter<"AdminUser"> | $Enums.AdminRole
    permissions?: StringNullableListFilter<"AdminUser">
    isActive?: BoolFilter<"AdminUser"> | boolean
    isSuperAdmin?: BoolFilter<"AdminUser"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"AdminUser"> | string | null
    failedAttempts?: IntFilter<"AdminUser"> | number
    lockedUntil?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    createdAt?: DateTimeFilter<"AdminUser"> | Date | string
    updatedAt?: DateTimeFilter<"AdminUser"> | Date | string
    createdBy?: StringNullableFilter<"AdminUser"> | string | null
    sessions?: AdminSessionListRelationFilter
    auditActions?: AdminAuditLogListRelationFilter
  }, "id" | "email">

  export type AdminUserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    isActive?: SortOrder
    isSuperAdmin?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastLoginIp?: SortOrderInput | SortOrder
    failedAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: AdminUserCountOrderByAggregateInput
    _avg?: AdminUserAvgOrderByAggregateInput
    _max?: AdminUserMaxOrderByAggregateInput
    _min?: AdminUserMinOrderByAggregateInput
    _sum?: AdminUserSumOrderByAggregateInput
  }

  export type AdminUserScalarWhereWithAggregatesInput = {
    AND?: AdminUserScalarWhereWithAggregatesInput | AdminUserScalarWhereWithAggregatesInput[]
    OR?: AdminUserScalarWhereWithAggregatesInput[]
    NOT?: AdminUserScalarWhereWithAggregatesInput | AdminUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminUser"> | string
    email?: StringWithAggregatesFilter<"AdminUser"> | string
    passwordHash?: StringWithAggregatesFilter<"AdminUser"> | string
    name?: StringWithAggregatesFilter<"AdminUser"> | string
    role?: EnumAdminRoleWithAggregatesFilter<"AdminUser"> | $Enums.AdminRole
    permissions?: StringNullableListFilter<"AdminUser">
    isActive?: BoolWithAggregatesFilter<"AdminUser"> | boolean
    isSuperAdmin?: BoolWithAggregatesFilter<"AdminUser"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"AdminUser"> | Date | string | null
    lastLoginIp?: StringNullableWithAggregatesFilter<"AdminUser"> | string | null
    failedAttempts?: IntWithAggregatesFilter<"AdminUser"> | number
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"AdminUser"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AdminUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminUser"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"AdminUser"> | string | null
  }

  export type AdminSessionWhereInput = {
    AND?: AdminSessionWhereInput | AdminSessionWhereInput[]
    OR?: AdminSessionWhereInput[]
    NOT?: AdminSessionWhereInput | AdminSessionWhereInput[]
    id?: StringFilter<"AdminSession"> | string
    adminId?: StringFilter<"AdminSession"> | string
    refreshToken?: StringFilter<"AdminSession"> | string
    userAgent?: StringNullableFilter<"AdminSession"> | string | null
    ipAddress?: StringNullableFilter<"AdminSession"> | string | null
    expiresAt?: DateTimeFilter<"AdminSession"> | Date | string
    createdAt?: DateTimeFilter<"AdminSession"> | Date | string
    admin?: XOR<AdminUserRelationFilter, AdminUserWhereInput>
  }

  export type AdminSessionOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    refreshToken?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    admin?: AdminUserOrderByWithRelationInput
  }

  export type AdminSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    refreshToken?: string
    AND?: AdminSessionWhereInput | AdminSessionWhereInput[]
    OR?: AdminSessionWhereInput[]
    NOT?: AdminSessionWhereInput | AdminSessionWhereInput[]
    adminId?: StringFilter<"AdminSession"> | string
    userAgent?: StringNullableFilter<"AdminSession"> | string | null
    ipAddress?: StringNullableFilter<"AdminSession"> | string | null
    expiresAt?: DateTimeFilter<"AdminSession"> | Date | string
    createdAt?: DateTimeFilter<"AdminSession"> | Date | string
    admin?: XOR<AdminUserRelationFilter, AdminUserWhereInput>
  }, "id" | "refreshToken">

  export type AdminSessionOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    refreshToken?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: AdminSessionCountOrderByAggregateInput
    _max?: AdminSessionMaxOrderByAggregateInput
    _min?: AdminSessionMinOrderByAggregateInput
  }

  export type AdminSessionScalarWhereWithAggregatesInput = {
    AND?: AdminSessionScalarWhereWithAggregatesInput | AdminSessionScalarWhereWithAggregatesInput[]
    OR?: AdminSessionScalarWhereWithAggregatesInput[]
    NOT?: AdminSessionScalarWhereWithAggregatesInput | AdminSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminSession"> | string
    adminId?: StringWithAggregatesFilter<"AdminSession"> | string
    refreshToken?: StringWithAggregatesFilter<"AdminSession"> | string
    userAgent?: StringNullableWithAggregatesFilter<"AdminSession"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AdminSession"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"AdminSession"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminSession"> | Date | string
  }

  export type AdminAuditLogWhereInput = {
    AND?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    OR?: AdminAuditLogWhereInput[]
    NOT?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    id?: StringFilter<"AdminAuditLog"> | string
    adminId?: StringFilter<"AdminAuditLog"> | string
    action?: StringFilter<"AdminAuditLog"> | string
    resource?: StringFilter<"AdminAuditLog"> | string
    resourceId?: StringNullableFilter<"AdminAuditLog"> | string | null
    details?: JsonNullableFilter<"AdminAuditLog">
    oldValue?: JsonNullableFilter<"AdminAuditLog">
    newValue?: JsonNullableFilter<"AdminAuditLog">
    ipAddress?: StringNullableFilter<"AdminAuditLog"> | string | null
    userAgent?: StringNullableFilter<"AdminAuditLog"> | string | null
    createdAt?: DateTimeFilter<"AdminAuditLog"> | Date | string
    admin?: XOR<AdminUserRelationFilter, AdminUserWhereInput>
  }

  export type AdminAuditLogOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    admin?: AdminUserOrderByWithRelationInput
  }

  export type AdminAuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    OR?: AdminAuditLogWhereInput[]
    NOT?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    adminId?: StringFilter<"AdminAuditLog"> | string
    action?: StringFilter<"AdminAuditLog"> | string
    resource?: StringFilter<"AdminAuditLog"> | string
    resourceId?: StringNullableFilter<"AdminAuditLog"> | string | null
    details?: JsonNullableFilter<"AdminAuditLog">
    oldValue?: JsonNullableFilter<"AdminAuditLog">
    newValue?: JsonNullableFilter<"AdminAuditLog">
    ipAddress?: StringNullableFilter<"AdminAuditLog"> | string | null
    userAgent?: StringNullableFilter<"AdminAuditLog"> | string | null
    createdAt?: DateTimeFilter<"AdminAuditLog"> | Date | string
    admin?: XOR<AdminUserRelationFilter, AdminUserWhereInput>
  }, "id">

  export type AdminAuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AdminAuditLogCountOrderByAggregateInput
    _max?: AdminAuditLogMaxOrderByAggregateInput
    _min?: AdminAuditLogMinOrderByAggregateInput
  }

  export type AdminAuditLogScalarWhereWithAggregatesInput = {
    AND?: AdminAuditLogScalarWhereWithAggregatesInput | AdminAuditLogScalarWhereWithAggregatesInput[]
    OR?: AdminAuditLogScalarWhereWithAggregatesInput[]
    NOT?: AdminAuditLogScalarWhereWithAggregatesInput | AdminAuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    adminId?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    action?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    resource?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    resourceId?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"AdminAuditLog">
    oldValue?: JsonNullableWithAggregatesFilter<"AdminAuditLog">
    newValue?: JsonNullableWithAggregatesFilter<"AdminAuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AdminAuditLog"> | Date | string
  }

  export type SubscriptionPlanWhereInput = {
    AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    OR?: SubscriptionPlanWhereInput[]
    NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    id?: StringFilter<"SubscriptionPlan"> | string
    name?: StringFilter<"SubscriptionPlan"> | string
    slug?: StringFilter<"SubscriptionPlan"> | string
    description?: StringNullableFilter<"SubscriptionPlan"> | string | null
    priceMonthly?: DecimalNullableFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string | null
    priceAnnual?: DecimalNullableFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"SubscriptionPlan"> | string
    stripePriceIdMonthly?: StringNullableFilter<"SubscriptionPlan"> | string | null
    stripePriceIdAnnual?: StringNullableFilter<"SubscriptionPlan"> | string | null
    stripeProductId?: StringNullableFilter<"SubscriptionPlan"> | string | null
    features?: JsonFilter<"SubscriptionPlan">
    limits?: JsonFilter<"SubscriptionPlan">
    trialDays?: IntFilter<"SubscriptionPlan"> | number
    isActive?: BoolFilter<"SubscriptionPlan"> | boolean
    isDefault?: BoolFilter<"SubscriptionPlan"> | boolean
    displayOrder?: IntFilter<"SubscriptionPlan"> | number
    createdAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
  }

  export type SubscriptionPlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    priceMonthly?: SortOrderInput | SortOrder
    priceAnnual?: SortOrderInput | SortOrder
    currency?: SortOrder
    stripePriceIdMonthly?: SortOrderInput | SortOrder
    stripePriceIdAnnual?: SortOrderInput | SortOrder
    stripeProductId?: SortOrderInput | SortOrder
    features?: SortOrder
    limits?: SortOrder
    trialDays?: SortOrder
    isActive?: SortOrder
    isDefault?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscriptions?: SubscriptionOrderByRelationAggregateInput
  }

  export type SubscriptionPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    OR?: SubscriptionPlanWhereInput[]
    NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    name?: StringFilter<"SubscriptionPlan"> | string
    description?: StringNullableFilter<"SubscriptionPlan"> | string | null
    priceMonthly?: DecimalNullableFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string | null
    priceAnnual?: DecimalNullableFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"SubscriptionPlan"> | string
    stripePriceIdMonthly?: StringNullableFilter<"SubscriptionPlan"> | string | null
    stripePriceIdAnnual?: StringNullableFilter<"SubscriptionPlan"> | string | null
    stripeProductId?: StringNullableFilter<"SubscriptionPlan"> | string | null
    features?: JsonFilter<"SubscriptionPlan">
    limits?: JsonFilter<"SubscriptionPlan">
    trialDays?: IntFilter<"SubscriptionPlan"> | number
    isActive?: BoolFilter<"SubscriptionPlan"> | boolean
    isDefault?: BoolFilter<"SubscriptionPlan"> | boolean
    displayOrder?: IntFilter<"SubscriptionPlan"> | number
    createdAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
  }, "id" | "slug">

  export type SubscriptionPlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    priceMonthly?: SortOrderInput | SortOrder
    priceAnnual?: SortOrderInput | SortOrder
    currency?: SortOrder
    stripePriceIdMonthly?: SortOrderInput | SortOrder
    stripePriceIdAnnual?: SortOrderInput | SortOrder
    stripeProductId?: SortOrderInput | SortOrder
    features?: SortOrder
    limits?: SortOrder
    trialDays?: SortOrder
    isActive?: SortOrder
    isDefault?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionPlanCountOrderByAggregateInput
    _avg?: SubscriptionPlanAvgOrderByAggregateInput
    _max?: SubscriptionPlanMaxOrderByAggregateInput
    _min?: SubscriptionPlanMinOrderByAggregateInput
    _sum?: SubscriptionPlanSumOrderByAggregateInput
  }

  export type SubscriptionPlanScalarWhereWithAggregatesInput = {
    AND?: SubscriptionPlanScalarWhereWithAggregatesInput | SubscriptionPlanScalarWhereWithAggregatesInput[]
    OR?: SubscriptionPlanScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionPlanScalarWhereWithAggregatesInput | SubscriptionPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    name?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    slug?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    description?: StringNullableWithAggregatesFilter<"SubscriptionPlan"> | string | null
    priceMonthly?: DecimalNullableWithAggregatesFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string | null
    priceAnnual?: DecimalNullableWithAggregatesFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    stripePriceIdMonthly?: StringNullableWithAggregatesFilter<"SubscriptionPlan"> | string | null
    stripePriceIdAnnual?: StringNullableWithAggregatesFilter<"SubscriptionPlan"> | string | null
    stripeProductId?: StringNullableWithAggregatesFilter<"SubscriptionPlan"> | string | null
    features?: JsonWithAggregatesFilter<"SubscriptionPlan">
    limits?: JsonWithAggregatesFilter<"SubscriptionPlan">
    trialDays?: IntWithAggregatesFilter<"SubscriptionPlan"> | number
    isActive?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    isDefault?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    displayOrder?: IntWithAggregatesFilter<"SubscriptionPlan"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubscriptionPlan"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    planId?: StringFilter<"Subscription"> | string
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    billingCycle?: EnumBillingCycleFilter<"Subscription"> | $Enums.BillingCycle
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    trialEndsAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelReason?: StringNullableFilter<"Subscription"> | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    plan?: XOR<SubscriptionPlanRelationFilter, SubscriptionPlanWhereInput>
    payments?: PaymentListRelationFilter
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    billingCycle?: SortOrder
    status?: SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancelReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    plan?: SubscriptionPlanOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    stripeSubscriptionId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    planId?: StringFilter<"Subscription"> | string
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    billingCycle?: EnumBillingCycleFilter<"Subscription"> | $Enums.BillingCycle
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    trialEndsAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelReason?: StringNullableFilter<"Subscription"> | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    plan?: XOR<SubscriptionPlanRelationFilter, SubscriptionPlanWhereInput>
    payments?: PaymentListRelationFilter
  }, "id" | "userId" | "stripeSubscriptionId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    billingCycle?: SortOrder
    status?: SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancelReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    userId?: StringWithAggregatesFilter<"Subscription"> | string
    planId?: StringWithAggregatesFilter<"Subscription"> | string
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    billingCycle?: EnumBillingCycleWithAggregatesFilter<"Subscription"> | $Enums.BillingCycle
    status?: EnumSubscriptionStatusWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionStatus
    trialEndsAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    currentPeriodStart?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolWithAggregatesFilter<"Subscription"> | boolean
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    cancelReason?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    subscriptionId?: StringNullableFilter<"Payment"> | string | null
    stripePaymentIntentId?: StringNullableFilter<"Payment"> | string | null
    stripeChargeId?: StringNullableFilter<"Payment"> | string | null
    stripeInvoiceId?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    paymentMethod?: EnumPaymentMethodTypeFilter<"Payment"> | $Enums.PaymentMethodType
    last4?: StringNullableFilter<"Payment"> | string | null
    cardBrand?: StringNullableFilter<"Payment"> | string | null
    oxxoVoucherUrl?: StringNullableFilter<"Payment"> | string | null
    oxxoExpiresAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    description?: StringNullableFilter<"Payment"> | string | null
    failureCode?: StringNullableFilter<"Payment"> | string | null
    failureMessage?: StringNullableFilter<"Payment"> | string | null
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    stripePaymentIntentId?: SortOrderInput | SortOrder
    stripeChargeId?: SortOrderInput | SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    last4?: SortOrderInput | SortOrder
    cardBrand?: SortOrderInput | SortOrder
    oxxoVoucherUrl?: SortOrderInput | SortOrder
    oxxoExpiresAt?: SortOrderInput | SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    failureCode?: SortOrderInput | SortOrder
    failureMessage?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    subscription?: SubscriptionOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripePaymentIntentId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    userId?: StringFilter<"Payment"> | string
    subscriptionId?: StringNullableFilter<"Payment"> | string | null
    stripeChargeId?: StringNullableFilter<"Payment"> | string | null
    stripeInvoiceId?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    paymentMethod?: EnumPaymentMethodTypeFilter<"Payment"> | $Enums.PaymentMethodType
    last4?: StringNullableFilter<"Payment"> | string | null
    cardBrand?: StringNullableFilter<"Payment"> | string | null
    oxxoVoucherUrl?: StringNullableFilter<"Payment"> | string | null
    oxxoExpiresAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    description?: StringNullableFilter<"Payment"> | string | null
    failureCode?: StringNullableFilter<"Payment"> | string | null
    failureMessage?: StringNullableFilter<"Payment"> | string | null
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
  }, "id" | "stripePaymentIntentId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    stripePaymentIntentId?: SortOrderInput | SortOrder
    stripeChargeId?: SortOrderInput | SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    last4?: SortOrderInput | SortOrder
    cardBrand?: SortOrderInput | SortOrder
    oxxoVoucherUrl?: SortOrderInput | SortOrder
    oxxoExpiresAt?: SortOrderInput | SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    failureCode?: SortOrderInput | SortOrder
    failureMessage?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    userId?: StringWithAggregatesFilter<"Payment"> | string
    subscriptionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    stripePaymentIntentId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    stripeChargeId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    stripeInvoiceId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Payment"> | string
    paymentMethod?: EnumPaymentMethodTypeWithAggregatesFilter<"Payment"> | $Enums.PaymentMethodType
    last4?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    cardBrand?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    oxxoVoucherUrl?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    oxxoExpiresAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    description?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    failureCode?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    failureMessage?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type PaymentMethodWhereInput = {
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    id?: StringFilter<"PaymentMethod"> | string
    userId?: StringFilter<"PaymentMethod"> | string
    stripePaymentMethodId?: StringFilter<"PaymentMethod"> | string
    type?: EnumPaymentMethodTypeFilter<"PaymentMethod"> | $Enums.PaymentMethodType
    last4?: StringFilter<"PaymentMethod"> | string
    brand?: StringFilter<"PaymentMethod"> | string
    expMonth?: IntFilter<"PaymentMethod"> | number
    expYear?: IntFilter<"PaymentMethod"> | number
    cardholderName?: StringNullableFilter<"PaymentMethod"> | string | null
    isDefault?: BoolFilter<"PaymentMethod"> | boolean
    isActive?: BoolFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PaymentMethodOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    stripePaymentMethodId?: SortOrder
    type?: SortOrder
    last4?: SortOrder
    brand?: SortOrder
    expMonth?: SortOrder
    expYear?: SortOrder
    cardholderName?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripePaymentMethodId?: string
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    userId?: StringFilter<"PaymentMethod"> | string
    type?: EnumPaymentMethodTypeFilter<"PaymentMethod"> | $Enums.PaymentMethodType
    last4?: StringFilter<"PaymentMethod"> | string
    brand?: StringFilter<"PaymentMethod"> | string
    expMonth?: IntFilter<"PaymentMethod"> | number
    expYear?: IntFilter<"PaymentMethod"> | number
    cardholderName?: StringNullableFilter<"PaymentMethod"> | string | null
    isDefault?: BoolFilter<"PaymentMethod"> | boolean
    isActive?: BoolFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "stripePaymentMethodId">

  export type PaymentMethodOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    stripePaymentMethodId?: SortOrder
    type?: SortOrder
    last4?: SortOrder
    brand?: SortOrder
    expMonth?: SortOrder
    expYear?: SortOrder
    cardholderName?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentMethodCountOrderByAggregateInput
    _avg?: PaymentMethodAvgOrderByAggregateInput
    _max?: PaymentMethodMaxOrderByAggregateInput
    _min?: PaymentMethodMinOrderByAggregateInput
    _sum?: PaymentMethodSumOrderByAggregateInput
  }

  export type PaymentMethodScalarWhereWithAggregatesInput = {
    AND?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    OR?: PaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentMethod"> | string
    userId?: StringWithAggregatesFilter<"PaymentMethod"> | string
    stripePaymentMethodId?: StringWithAggregatesFilter<"PaymentMethod"> | string
    type?: EnumPaymentMethodTypeWithAggregatesFilter<"PaymentMethod"> | $Enums.PaymentMethodType
    last4?: StringWithAggregatesFilter<"PaymentMethod"> | string
    brand?: StringWithAggregatesFilter<"PaymentMethod"> | string
    expMonth?: IntWithAggregatesFilter<"PaymentMethod"> | number
    expYear?: IntWithAggregatesFilter<"PaymentMethod"> | number
    cardholderName?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    isDefault?: BoolWithAggregatesFilter<"PaymentMethod"> | boolean
    isActive?: BoolWithAggregatesFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
  }

  export type FiscalDataWhereInput = {
    AND?: FiscalDataWhereInput | FiscalDataWhereInput[]
    OR?: FiscalDataWhereInput[]
    NOT?: FiscalDataWhereInput | FiscalDataWhereInput[]
    id?: StringFilter<"FiscalData"> | string
    userId?: StringFilter<"FiscalData"> | string
    rfc?: StringFilter<"FiscalData"> | string
    razonSocial?: StringFilter<"FiscalData"> | string
    regimenFiscal?: StringFilter<"FiscalData"> | string
    usoCFDI?: StringFilter<"FiscalData"> | string
    codigoPostal?: StringFilter<"FiscalData"> | string
    calle?: StringNullableFilter<"FiscalData"> | string | null
    numExterior?: StringNullableFilter<"FiscalData"> | string | null
    numInterior?: StringNullableFilter<"FiscalData"> | string | null
    colonia?: StringNullableFilter<"FiscalData"> | string | null
    municipio?: StringNullableFilter<"FiscalData"> | string | null
    estado?: StringNullableFilter<"FiscalData"> | string | null
    emailFacturacion?: StringFilter<"FiscalData"> | string
    facturamaClientId?: StringNullableFilter<"FiscalData"> | string | null
    createdAt?: DateTimeFilter<"FiscalData"> | Date | string
    updatedAt?: DateTimeFilter<"FiscalData"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    invoices?: InvoiceListRelationFilter
  }

  export type FiscalDataOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    rfc?: SortOrder
    razonSocial?: SortOrder
    regimenFiscal?: SortOrder
    usoCFDI?: SortOrder
    codigoPostal?: SortOrder
    calle?: SortOrderInput | SortOrder
    numExterior?: SortOrderInput | SortOrder
    numInterior?: SortOrderInput | SortOrder
    colonia?: SortOrderInput | SortOrder
    municipio?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    emailFacturacion?: SortOrder
    facturamaClientId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    invoices?: InvoiceOrderByRelationAggregateInput
  }

  export type FiscalDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: FiscalDataWhereInput | FiscalDataWhereInput[]
    OR?: FiscalDataWhereInput[]
    NOT?: FiscalDataWhereInput | FiscalDataWhereInput[]
    rfc?: StringFilter<"FiscalData"> | string
    razonSocial?: StringFilter<"FiscalData"> | string
    regimenFiscal?: StringFilter<"FiscalData"> | string
    usoCFDI?: StringFilter<"FiscalData"> | string
    codigoPostal?: StringFilter<"FiscalData"> | string
    calle?: StringNullableFilter<"FiscalData"> | string | null
    numExterior?: StringNullableFilter<"FiscalData"> | string | null
    numInterior?: StringNullableFilter<"FiscalData"> | string | null
    colonia?: StringNullableFilter<"FiscalData"> | string | null
    municipio?: StringNullableFilter<"FiscalData"> | string | null
    estado?: StringNullableFilter<"FiscalData"> | string | null
    emailFacturacion?: StringFilter<"FiscalData"> | string
    facturamaClientId?: StringNullableFilter<"FiscalData"> | string | null
    createdAt?: DateTimeFilter<"FiscalData"> | Date | string
    updatedAt?: DateTimeFilter<"FiscalData"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    invoices?: InvoiceListRelationFilter
  }, "id" | "userId">

  export type FiscalDataOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    rfc?: SortOrder
    razonSocial?: SortOrder
    regimenFiscal?: SortOrder
    usoCFDI?: SortOrder
    codigoPostal?: SortOrder
    calle?: SortOrderInput | SortOrder
    numExterior?: SortOrderInput | SortOrder
    numInterior?: SortOrderInput | SortOrder
    colonia?: SortOrderInput | SortOrder
    municipio?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    emailFacturacion?: SortOrder
    facturamaClientId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FiscalDataCountOrderByAggregateInput
    _max?: FiscalDataMaxOrderByAggregateInput
    _min?: FiscalDataMinOrderByAggregateInput
  }

  export type FiscalDataScalarWhereWithAggregatesInput = {
    AND?: FiscalDataScalarWhereWithAggregatesInput | FiscalDataScalarWhereWithAggregatesInput[]
    OR?: FiscalDataScalarWhereWithAggregatesInput[]
    NOT?: FiscalDataScalarWhereWithAggregatesInput | FiscalDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FiscalData"> | string
    userId?: StringWithAggregatesFilter<"FiscalData"> | string
    rfc?: StringWithAggregatesFilter<"FiscalData"> | string
    razonSocial?: StringWithAggregatesFilter<"FiscalData"> | string
    regimenFiscal?: StringWithAggregatesFilter<"FiscalData"> | string
    usoCFDI?: StringWithAggregatesFilter<"FiscalData"> | string
    codigoPostal?: StringWithAggregatesFilter<"FiscalData"> | string
    calle?: StringNullableWithAggregatesFilter<"FiscalData"> | string | null
    numExterior?: StringNullableWithAggregatesFilter<"FiscalData"> | string | null
    numInterior?: StringNullableWithAggregatesFilter<"FiscalData"> | string | null
    colonia?: StringNullableWithAggregatesFilter<"FiscalData"> | string | null
    municipio?: StringNullableWithAggregatesFilter<"FiscalData"> | string | null
    estado?: StringNullableWithAggregatesFilter<"FiscalData"> | string | null
    emailFacturacion?: StringWithAggregatesFilter<"FiscalData"> | string
    facturamaClientId?: StringNullableWithAggregatesFilter<"FiscalData"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FiscalData"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FiscalData"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    userId?: StringFilter<"Invoice"> | string
    paymentId?: StringFilter<"Invoice"> | string
    fiscalDataId?: StringNullableFilter<"Invoice"> | string | null
    facturamaInvoiceId?: StringNullableFilter<"Invoice"> | string | null
    uuid?: StringNullableFilter<"Invoice"> | string | null
    serie?: StringNullableFilter<"Invoice"> | string | null
    folio?: StringNullableFilter<"Invoice"> | string | null
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    iva?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    xmlUrl?: StringNullableFilter<"Invoice"> | string | null
    pdfUrl?: StringNullableFilter<"Invoice"> | string | null
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    issuedAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    errorMessage?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    payment?: XOR<PaymentRelationFilter, PaymentWhereInput>
    fiscalData?: XOR<FiscalDataNullableRelationFilter, FiscalDataWhereInput> | null
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentId?: SortOrder
    fiscalDataId?: SortOrderInput | SortOrder
    facturamaInvoiceId?: SortOrderInput | SortOrder
    uuid?: SortOrderInput | SortOrder
    serie?: SortOrderInput | SortOrder
    folio?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    iva?: SortOrder
    total?: SortOrder
    xmlUrl?: SortOrderInput | SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    issuedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    payment?: PaymentOrderByWithRelationInput
    fiscalData?: FiscalDataOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    paymentId?: string
    facturamaInvoiceId?: string
    uuid?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    userId?: StringFilter<"Invoice"> | string
    fiscalDataId?: StringNullableFilter<"Invoice"> | string | null
    serie?: StringNullableFilter<"Invoice"> | string | null
    folio?: StringNullableFilter<"Invoice"> | string | null
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    iva?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    xmlUrl?: StringNullableFilter<"Invoice"> | string | null
    pdfUrl?: StringNullableFilter<"Invoice"> | string | null
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    issuedAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    errorMessage?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    payment?: XOR<PaymentRelationFilter, PaymentWhereInput>
    fiscalData?: XOR<FiscalDataNullableRelationFilter, FiscalDataWhereInput> | null
  }, "id" | "paymentId" | "facturamaInvoiceId" | "uuid">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentId?: SortOrder
    fiscalDataId?: SortOrderInput | SortOrder
    facturamaInvoiceId?: SortOrderInput | SortOrder
    uuid?: SortOrderInput | SortOrder
    serie?: SortOrderInput | SortOrder
    folio?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    iva?: SortOrder
    total?: SortOrder
    xmlUrl?: SortOrderInput | SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    issuedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    userId?: StringWithAggregatesFilter<"Invoice"> | string
    paymentId?: StringWithAggregatesFilter<"Invoice"> | string
    fiscalDataId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    facturamaInvoiceId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    uuid?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    serie?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    folio?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    subtotal?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    iva?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    xmlUrl?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    pdfUrl?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    issuedAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileCreateNestedOneWithoutUserInput
    directives?: AdvanceDirectiveCreateNestedManyWithoutUserInput
    representatives?: RepresentativeCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessCreateNestedManyWithoutPatientInput
    panicAlerts?: PanicAlertCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileUncheckedCreateNestedOneWithoutUserInput
    directives?: AdvanceDirectiveUncheckedCreateNestedManyWithoutUserInput
    representatives?: RepresentativeUncheckedCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessUncheckedCreateNestedManyWithoutPatientInput
    panicAlerts?: PanicAlertUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUpdateOneWithoutUserNestedInput
    directives?: AdvanceDirectiveUpdateManyWithoutUserNestedInput
    representatives?: RepresentativeUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUpdateManyWithoutPatientNestedInput
    panicAlerts?: PanicAlertUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUncheckedUpdateOneWithoutUserNestedInput
    directives?: AdvanceDirectiveUncheckedUpdateManyWithoutUserNestedInput
    representatives?: RepresentativeUncheckedUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUncheckedUpdateManyWithoutPatientNestedInput
    panicAlerts?: PanicAlertUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateInput = {
    id?: string
    refreshToken: string
    userAgent?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    refreshToken: string
    userAgent?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    refreshToken: string
    userAgent?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebAuthnCredentialCreateInput = {
    id?: string
    credentialId: string
    credentialPublicKey: Buffer
    counter?: bigint | number
    deviceType?: string | null
    deviceName?: string | null
    transports?: WebAuthnCredentialCreatetransportsInput | string[]
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    user: UserCreateNestedOneWithoutWebauthnCredentialsInput
  }

  export type WebAuthnCredentialUncheckedCreateInput = {
    id?: string
    userId: string
    credentialId: string
    credentialPublicKey: Buffer
    counter?: bigint | number
    deviceType?: string | null
    deviceName?: string | null
    transports?: WebAuthnCredentialCreatetransportsInput | string[]
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type WebAuthnCredentialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: BytesFieldUpdateOperationsInput | Buffer
    counter?: BigIntFieldUpdateOperationsInput | bigint | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    transports?: WebAuthnCredentialUpdatetransportsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutWebauthnCredentialsNestedInput
  }

  export type WebAuthnCredentialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: BytesFieldUpdateOperationsInput | Buffer
    counter?: BigIntFieldUpdateOperationsInput | bigint | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    transports?: WebAuthnCredentialUpdatetransportsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WebAuthnCredentialCreateManyInput = {
    id?: string
    userId: string
    credentialId: string
    credentialPublicKey: Buffer
    counter?: bigint | number
    deviceType?: string | null
    deviceName?: string | null
    transports?: WebAuthnCredentialCreatetransportsInput | string[]
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type WebAuthnCredentialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: BytesFieldUpdateOperationsInput | Buffer
    counter?: BigIntFieldUpdateOperationsInput | bigint | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    transports?: WebAuthnCredentialUpdatetransportsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WebAuthnCredentialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: BytesFieldUpdateOperationsInput | Buffer
    counter?: BigIntFieldUpdateOperationsInput | bigint | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    transports?: WebAuthnCredentialUpdatetransportsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PatientProfileCreateInput = {
    id?: string
    bloodType?: string | null
    allergiesEnc?: string | null
    conditionsEnc?: string | null
    medicationsEnc?: string | null
    insuranceProvider?: string | null
    insurancePolicy?: string | null
    insurancePhone?: string | null
    photoUrl?: string | null
    isDonor?: boolean
    donorPreferencesEnc?: string | null
    donorVideoUrl?: string | null
    qrToken?: string
    qrGeneratedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type PatientProfileUncheckedCreateInput = {
    id?: string
    userId: string
    bloodType?: string | null
    allergiesEnc?: string | null
    conditionsEnc?: string | null
    medicationsEnc?: string | null
    insuranceProvider?: string | null
    insurancePolicy?: string | null
    insurancePhone?: string | null
    photoUrl?: string | null
    isDonor?: boolean
    donorPreferencesEnc?: string | null
    donorVideoUrl?: string | null
    qrToken?: string
    qrGeneratedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    allergiesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    conditionsEnc?: NullableStringFieldUpdateOperationsInput | string | null
    medicationsEnc?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicy?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePhone?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDonor?: BoolFieldUpdateOperationsInput | boolean
    donorPreferencesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    donorVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrToken?: StringFieldUpdateOperationsInput | string
    qrGeneratedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type PatientProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    allergiesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    conditionsEnc?: NullableStringFieldUpdateOperationsInput | string | null
    medicationsEnc?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicy?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePhone?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDonor?: BoolFieldUpdateOperationsInput | boolean
    donorPreferencesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    donorVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrToken?: StringFieldUpdateOperationsInput | string
    qrGeneratedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientProfileCreateManyInput = {
    id?: string
    userId: string
    bloodType?: string | null
    allergiesEnc?: string | null
    conditionsEnc?: string | null
    medicationsEnc?: string | null
    insuranceProvider?: string | null
    insurancePolicy?: string | null
    insurancePhone?: string | null
    photoUrl?: string | null
    isDonor?: boolean
    donorPreferencesEnc?: string | null
    donorVideoUrl?: string | null
    qrToken?: string
    qrGeneratedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    allergiesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    conditionsEnc?: NullableStringFieldUpdateOperationsInput | string | null
    medicationsEnc?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicy?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePhone?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDonor?: BoolFieldUpdateOperationsInput | boolean
    donorPreferencesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    donorVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrToken?: StringFieldUpdateOperationsInput | string
    qrGeneratedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    allergiesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    conditionsEnc?: NullableStringFieldUpdateOperationsInput | string | null
    medicationsEnc?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicy?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePhone?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDonor?: BoolFieldUpdateOperationsInput | boolean
    donorPreferencesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    donorVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrToken?: StringFieldUpdateOperationsInput | string
    qrGeneratedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepresentativeCreateInput = {
    id?: string
    name: string
    phone: string
    email?: string | null
    relation: string
    priority?: number
    isDonorSpokesperson?: boolean
    notifyOnEmergency?: boolean
    notifyOnAccess?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRepresentativesInput
  }

  export type RepresentativeUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    phone: string
    email?: string | null
    relation: string
    priority?: number
    isDonorSpokesperson?: boolean
    notifyOnEmergency?: boolean
    notifyOnAccess?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RepresentativeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    relation?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    isDonorSpokesperson?: BoolFieldUpdateOperationsInput | boolean
    notifyOnEmergency?: BoolFieldUpdateOperationsInput | boolean
    notifyOnAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRepresentativesNestedInput
  }

  export type RepresentativeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    relation?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    isDonorSpokesperson?: BoolFieldUpdateOperationsInput | boolean
    notifyOnEmergency?: BoolFieldUpdateOperationsInput | boolean
    notifyOnAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepresentativeCreateManyInput = {
    id?: string
    userId: string
    name: string
    phone: string
    email?: string | null
    relation: string
    priority?: number
    isDonorSpokesperson?: boolean
    notifyOnEmergency?: boolean
    notifyOnAccess?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RepresentativeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    relation?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    isDonorSpokesperson?: BoolFieldUpdateOperationsInput | boolean
    notifyOnEmergency?: BoolFieldUpdateOperationsInput | boolean
    notifyOnAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepresentativeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    relation?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    isDonorSpokesperson?: BoolFieldUpdateOperationsInput | boolean
    notifyOnEmergency?: BoolFieldUpdateOperationsInput | boolean
    notifyOnAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvanceDirectiveCreateInput = {
    id?: string
    type: $Enums.DirectiveType
    status?: $Enums.DirectiveStatus
    documentUrl?: string | null
    documentHash?: string | null
    originalFileName?: string | null
    nom151Sealed?: boolean
    nom151Timestamp?: Date | string | null
    nom151Certificate?: string | null
    nom151Provider?: string | null
    acceptsCPR?: boolean | null
    acceptsIntubation?: boolean | null
    acceptsDialysis?: boolean | null
    acceptsTransfusion?: boolean | null
    acceptsArtificialNutrition?: boolean | null
    palliativeCareOnly?: boolean | null
    additionalNotes?: string | null
    originState?: string | null
    legalBasisSummary?: string | null
    validatedAt?: Date | string | null
    validatedBy?: string | null
    validationMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutDirectivesInput
    witnesses?: WitnessCreateNestedManyWithoutDirectiveInput
  }

  export type AdvanceDirectiveUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.DirectiveType
    status?: $Enums.DirectiveStatus
    documentUrl?: string | null
    documentHash?: string | null
    originalFileName?: string | null
    nom151Sealed?: boolean
    nom151Timestamp?: Date | string | null
    nom151Certificate?: string | null
    nom151Provider?: string | null
    acceptsCPR?: boolean | null
    acceptsIntubation?: boolean | null
    acceptsDialysis?: boolean | null
    acceptsTransfusion?: boolean | null
    acceptsArtificialNutrition?: boolean | null
    palliativeCareOnly?: boolean | null
    additionalNotes?: string | null
    originState?: string | null
    legalBasisSummary?: string | null
    validatedAt?: Date | string | null
    validatedBy?: string | null
    validationMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    witnesses?: WitnessUncheckedCreateNestedManyWithoutDirectiveInput
  }

  export type AdvanceDirectiveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDirectiveTypeFieldUpdateOperationsInput | $Enums.DirectiveType
    status?: EnumDirectiveStatusFieldUpdateOperationsInput | $Enums.DirectiveStatus
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    originalFileName?: NullableStringFieldUpdateOperationsInput | string | null
    nom151Sealed?: BoolFieldUpdateOperationsInput | boolean
    nom151Timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom151Certificate?: NullableStringFieldUpdateOperationsInput | string | null
    nom151Provider?: NullableStringFieldUpdateOperationsInput | string | null
    acceptsCPR?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsIntubation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsDialysis?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsTransfusion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsArtificialNutrition?: NullableBoolFieldUpdateOperationsInput | boolean | null
    palliativeCareOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    originState?: NullableStringFieldUpdateOperationsInput | string | null
    legalBasisSummary?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutDirectivesNestedInput
    witnesses?: WitnessUpdateManyWithoutDirectiveNestedInput
  }

  export type AdvanceDirectiveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumDirectiveTypeFieldUpdateOperationsInput | $Enums.DirectiveType
    status?: EnumDirectiveStatusFieldUpdateOperationsInput | $Enums.DirectiveStatus
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    originalFileName?: NullableStringFieldUpdateOperationsInput | string | null
    nom151Sealed?: BoolFieldUpdateOperationsInput | boolean
    nom151Timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom151Certificate?: NullableStringFieldUpdateOperationsInput | string | null
    nom151Provider?: NullableStringFieldUpdateOperationsInput | string | null
    acceptsCPR?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsIntubation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsDialysis?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsTransfusion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsArtificialNutrition?: NullableBoolFieldUpdateOperationsInput | boolean | null
    palliativeCareOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    originState?: NullableStringFieldUpdateOperationsInput | string | null
    legalBasisSummary?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    witnesses?: WitnessUncheckedUpdateManyWithoutDirectiveNestedInput
  }

  export type AdvanceDirectiveCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.DirectiveType
    status?: $Enums.DirectiveStatus
    documentUrl?: string | null
    documentHash?: string | null
    originalFileName?: string | null
    nom151Sealed?: boolean
    nom151Timestamp?: Date | string | null
    nom151Certificate?: string | null
    nom151Provider?: string | null
    acceptsCPR?: boolean | null
    acceptsIntubation?: boolean | null
    acceptsDialysis?: boolean | null
    acceptsTransfusion?: boolean | null
    acceptsArtificialNutrition?: boolean | null
    palliativeCareOnly?: boolean | null
    additionalNotes?: string | null
    originState?: string | null
    legalBasisSummary?: string | null
    validatedAt?: Date | string | null
    validatedBy?: string | null
    validationMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
  }

  export type AdvanceDirectiveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDirectiveTypeFieldUpdateOperationsInput | $Enums.DirectiveType
    status?: EnumDirectiveStatusFieldUpdateOperationsInput | $Enums.DirectiveStatus
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    originalFileName?: NullableStringFieldUpdateOperationsInput | string | null
    nom151Sealed?: BoolFieldUpdateOperationsInput | boolean
    nom151Timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom151Certificate?: NullableStringFieldUpdateOperationsInput | string | null
    nom151Provider?: NullableStringFieldUpdateOperationsInput | string | null
    acceptsCPR?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsIntubation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsDialysis?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsTransfusion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsArtificialNutrition?: NullableBoolFieldUpdateOperationsInput | boolean | null
    palliativeCareOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    originState?: NullableStringFieldUpdateOperationsInput | string | null
    legalBasisSummary?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdvanceDirectiveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumDirectiveTypeFieldUpdateOperationsInput | $Enums.DirectiveType
    status?: EnumDirectiveStatusFieldUpdateOperationsInput | $Enums.DirectiveStatus
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    originalFileName?: NullableStringFieldUpdateOperationsInput | string | null
    nom151Sealed?: BoolFieldUpdateOperationsInput | boolean
    nom151Timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom151Certificate?: NullableStringFieldUpdateOperationsInput | string | null
    nom151Provider?: NullableStringFieldUpdateOperationsInput | string | null
    acceptsCPR?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsIntubation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsDialysis?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsTransfusion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsArtificialNutrition?: NullableBoolFieldUpdateOperationsInput | boolean | null
    palliativeCareOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    originState?: NullableStringFieldUpdateOperationsInput | string | null
    legalBasisSummary?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WitnessCreateInput = {
    id?: string
    name: string
    curp?: string | null
    email?: string | null
    phone?: string | null
    ineImageUrl?: string | null
    selfieImageUrl?: string | null
    identityVerified?: boolean
    verifiedAt?: Date | string | null
    signatureImageUrl?: string | null
    signedAt?: Date | string | null
    sessionId?: string | null
    sessionRecordingUrl?: string | null
    sessionStartedAt?: Date | string | null
    sessionEndedAt?: Date | string | null
    createdAt?: Date | string
    directive: AdvanceDirectiveCreateNestedOneWithoutWitnessesInput
  }

  export type WitnessUncheckedCreateInput = {
    id?: string
    directiveId: string
    name: string
    curp?: string | null
    email?: string | null
    phone?: string | null
    ineImageUrl?: string | null
    selfieImageUrl?: string | null
    identityVerified?: boolean
    verifiedAt?: Date | string | null
    signatureImageUrl?: string | null
    signedAt?: Date | string | null
    sessionId?: string | null
    sessionRecordingUrl?: string | null
    sessionStartedAt?: Date | string | null
    sessionEndedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WitnessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ineImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    selfieImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sessionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionEndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    directive?: AdvanceDirectiveUpdateOneRequiredWithoutWitnessesNestedInput
  }

  export type WitnessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    directiveId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ineImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    selfieImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sessionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionEndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WitnessCreateManyInput = {
    id?: string
    directiveId: string
    name: string
    curp?: string | null
    email?: string | null
    phone?: string | null
    ineImageUrl?: string | null
    selfieImageUrl?: string | null
    identityVerified?: boolean
    verifiedAt?: Date | string | null
    signatureImageUrl?: string | null
    signedAt?: Date | string | null
    sessionId?: string | null
    sessionRecordingUrl?: string | null
    sessionStartedAt?: Date | string | null
    sessionEndedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WitnessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ineImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    selfieImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sessionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionEndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WitnessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    directiveId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ineImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    selfieImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sessionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionEndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyAccessCreateInput = {
    id?: string
    accessorId?: string | null
    accessorName: string
    accessorRole: string
    accessorLicense?: string | null
    institutionName?: string | null
    insurancePolicyNo?: string | null
    qrTokenUsed: string
    ipAddress?: string | null
    userAgent?: string | null
    latitude?: number | null
    longitude?: number | null
    locationName?: string | null
    dataAccessed?: EmergencyAccessCreatedataAccessedInput | string[]
    representativesNotified?: EmergencyAccessCreaterepresentativesNotifiedInput | string[]
    notificationsSentAt?: Date | string | null
    accessToken?: string
    accessedAt?: Date | string
    expiresAt: Date | string
    patient: UserCreateNestedOneWithoutEmergencyAccessesInput
    institution?: MedicalInstitutionCreateNestedOneWithoutEmergencyAccessesInput
    insurance?: InsuranceCompanyCreateNestedOneWithoutEmergencyAccessesInput
  }

  export type EmergencyAccessUncheckedCreateInput = {
    id?: string
    patientId: string
    accessorId?: string | null
    accessorName: string
    accessorRole: string
    accessorLicense?: string | null
    institutionId?: string | null
    institutionName?: string | null
    insuranceId?: string | null
    insurancePolicyNo?: string | null
    qrTokenUsed: string
    ipAddress?: string | null
    userAgent?: string | null
    latitude?: number | null
    longitude?: number | null
    locationName?: string | null
    dataAccessed?: EmergencyAccessCreatedataAccessedInput | string[]
    representativesNotified?: EmergencyAccessCreaterepresentativesNotifiedInput | string[]
    notificationsSentAt?: Date | string | null
    accessToken?: string
    accessedAt?: Date | string
    expiresAt: Date | string
  }

  export type EmergencyAccessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessorId?: NullableStringFieldUpdateOperationsInput | string | null
    accessorName?: StringFieldUpdateOperationsInput | string
    accessorRole?: StringFieldUpdateOperationsInput | string
    accessorLicense?: NullableStringFieldUpdateOperationsInput | string | null
    institutionName?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNo?: NullableStringFieldUpdateOperationsInput | string | null
    qrTokenUsed?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    dataAccessed?: EmergencyAccessUpdatedataAccessedInput | string[]
    representativesNotified?: EmergencyAccessUpdaterepresentativesNotifiedInput | string[]
    notificationsSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: UserUpdateOneRequiredWithoutEmergencyAccessesNestedInput
    institution?: MedicalInstitutionUpdateOneWithoutEmergencyAccessesNestedInput
    insurance?: InsuranceCompanyUpdateOneWithoutEmergencyAccessesNestedInput
  }

  export type EmergencyAccessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    accessorId?: NullableStringFieldUpdateOperationsInput | string | null
    accessorName?: StringFieldUpdateOperationsInput | string
    accessorRole?: StringFieldUpdateOperationsInput | string
    accessorLicense?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionName?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNo?: NullableStringFieldUpdateOperationsInput | string | null
    qrTokenUsed?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    dataAccessed?: EmergencyAccessUpdatedataAccessedInput | string[]
    representativesNotified?: EmergencyAccessUpdaterepresentativesNotifiedInput | string[]
    notificationsSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyAccessCreateManyInput = {
    id?: string
    patientId: string
    accessorId?: string | null
    accessorName: string
    accessorRole: string
    accessorLicense?: string | null
    institutionId?: string | null
    institutionName?: string | null
    insuranceId?: string | null
    insurancePolicyNo?: string | null
    qrTokenUsed: string
    ipAddress?: string | null
    userAgent?: string | null
    latitude?: number | null
    longitude?: number | null
    locationName?: string | null
    dataAccessed?: EmergencyAccessCreatedataAccessedInput | string[]
    representativesNotified?: EmergencyAccessCreaterepresentativesNotifiedInput | string[]
    notificationsSentAt?: Date | string | null
    accessToken?: string
    accessedAt?: Date | string
    expiresAt: Date | string
  }

  export type EmergencyAccessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessorId?: NullableStringFieldUpdateOperationsInput | string | null
    accessorName?: StringFieldUpdateOperationsInput | string
    accessorRole?: StringFieldUpdateOperationsInput | string
    accessorLicense?: NullableStringFieldUpdateOperationsInput | string | null
    institutionName?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNo?: NullableStringFieldUpdateOperationsInput | string | null
    qrTokenUsed?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    dataAccessed?: EmergencyAccessUpdatedataAccessedInput | string[]
    representativesNotified?: EmergencyAccessUpdaterepresentativesNotifiedInput | string[]
    notificationsSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyAccessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    accessorId?: NullableStringFieldUpdateOperationsInput | string | null
    accessorName?: StringFieldUpdateOperationsInput | string
    accessorRole?: StringFieldUpdateOperationsInput | string
    accessorLicense?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionName?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNo?: NullableStringFieldUpdateOperationsInput | string | null
    qrTokenUsed?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    dataAccessed?: EmergencyAccessUpdatedataAccessedInput | string[]
    representativesNotified?: EmergencyAccessUpdaterepresentativesNotifiedInput | string[]
    notificationsSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalInstitutionCreateInput = {
    id?: string
    name: string
    type: $Enums.InstitutionType
    cluesCode?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    latitude?: number | null
    longitude?: number | null
    phone?: string | null
    emergencyPhone?: string | null
    email?: string | null
    attentionLevel?: $Enums.AttentionLevel | null
    specialties?: MedicalInstitutionCreatespecialtiesInput | string[]
    hasEmergency?: boolean
    has24Hours?: boolean
    hasICU?: boolean
    hasTrauma?: boolean
    oauthClientId?: string | null
    oauthClientSecret?: string | null
    isActive?: boolean
    isVerified?: boolean
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emergencyAccesses?: EmergencyAccessCreateNestedManyWithoutInstitutionInput
    staff?: MedicalStaffCreateNestedManyWithoutInstitutionInput
    insuranceNetworks?: InsuranceCompanyCreateNestedManyWithoutNetworkHospitalsInput
  }

  export type MedicalInstitutionUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.InstitutionType
    cluesCode?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    latitude?: number | null
    longitude?: number | null
    phone?: string | null
    emergencyPhone?: string | null
    email?: string | null
    attentionLevel?: $Enums.AttentionLevel | null
    specialties?: MedicalInstitutionCreatespecialtiesInput | string[]
    hasEmergency?: boolean
    has24Hours?: boolean
    hasICU?: boolean
    hasTrauma?: boolean
    oauthClientId?: string | null
    oauthClientSecret?: string | null
    isActive?: boolean
    isVerified?: boolean
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emergencyAccesses?: EmergencyAccessUncheckedCreateNestedManyWithoutInstitutionInput
    staff?: MedicalStaffUncheckedCreateNestedManyWithoutInstitutionInput
    insuranceNetworks?: InsuranceCompanyUncheckedCreateNestedManyWithoutNetworkHospitalsInput
  }

  export type MedicalInstitutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    cluesCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    attentionLevel?: NullableEnumAttentionLevelFieldUpdateOperationsInput | $Enums.AttentionLevel | null
    specialties?: MedicalInstitutionUpdatespecialtiesInput | string[]
    hasEmergency?: BoolFieldUpdateOperationsInput | boolean
    has24Hours?: BoolFieldUpdateOperationsInput | boolean
    hasICU?: BoolFieldUpdateOperationsInput | boolean
    hasTrauma?: BoolFieldUpdateOperationsInput | boolean
    oauthClientId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emergencyAccesses?: EmergencyAccessUpdateManyWithoutInstitutionNestedInput
    staff?: MedicalStaffUpdateManyWithoutInstitutionNestedInput
    insuranceNetworks?: InsuranceCompanyUpdateManyWithoutNetworkHospitalsNestedInput
  }

  export type MedicalInstitutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    cluesCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    attentionLevel?: NullableEnumAttentionLevelFieldUpdateOperationsInput | $Enums.AttentionLevel | null
    specialties?: MedicalInstitutionUpdatespecialtiesInput | string[]
    hasEmergency?: BoolFieldUpdateOperationsInput | boolean
    has24Hours?: BoolFieldUpdateOperationsInput | boolean
    hasICU?: BoolFieldUpdateOperationsInput | boolean
    hasTrauma?: BoolFieldUpdateOperationsInput | boolean
    oauthClientId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emergencyAccesses?: EmergencyAccessUncheckedUpdateManyWithoutInstitutionNestedInput
    staff?: MedicalStaffUncheckedUpdateManyWithoutInstitutionNestedInput
    insuranceNetworks?: InsuranceCompanyUncheckedUpdateManyWithoutNetworkHospitalsNestedInput
  }

  export type MedicalInstitutionCreateManyInput = {
    id?: string
    name: string
    type: $Enums.InstitutionType
    cluesCode?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    latitude?: number | null
    longitude?: number | null
    phone?: string | null
    emergencyPhone?: string | null
    email?: string | null
    attentionLevel?: $Enums.AttentionLevel | null
    specialties?: MedicalInstitutionCreatespecialtiesInput | string[]
    hasEmergency?: boolean
    has24Hours?: boolean
    hasICU?: boolean
    hasTrauma?: boolean
    oauthClientId?: string | null
    oauthClientSecret?: string | null
    isActive?: boolean
    isVerified?: boolean
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalInstitutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    cluesCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    attentionLevel?: NullableEnumAttentionLevelFieldUpdateOperationsInput | $Enums.AttentionLevel | null
    specialties?: MedicalInstitutionUpdatespecialtiesInput | string[]
    hasEmergency?: BoolFieldUpdateOperationsInput | boolean
    has24Hours?: BoolFieldUpdateOperationsInput | boolean
    hasICU?: BoolFieldUpdateOperationsInput | boolean
    hasTrauma?: BoolFieldUpdateOperationsInput | boolean
    oauthClientId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalInstitutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    cluesCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    attentionLevel?: NullableEnumAttentionLevelFieldUpdateOperationsInput | $Enums.AttentionLevel | null
    specialties?: MedicalInstitutionUpdatespecialtiesInput | string[]
    hasEmergency?: BoolFieldUpdateOperationsInput | boolean
    has24Hours?: BoolFieldUpdateOperationsInput | boolean
    hasICU?: BoolFieldUpdateOperationsInput | boolean
    hasTrauma?: BoolFieldUpdateOperationsInput | boolean
    oauthClientId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsuranceCompanyCreateInput = {
    id?: string
    name: string
    shortName?: string | null
    type: $Enums.InsuranceType
    cnsfNumber?: string | null
    rfc?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    phone?: string | null
    emergencyPhone?: string | null
    email?: string | null
    website?: string | null
    coverageTypes?: InsuranceCompanyCreatecoverageTypesInput | string[]
    networkSize?: number | null
    hasNationalCoverage?: boolean
    statesCovered?: InsuranceCompanyCreatestatesCoveredInput | string[]
    isVerified?: boolean
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    apiEnabled?: boolean
    apiEndpoint?: string | null
    logoUrl?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    plans?: InsurancePlanCreateNestedManyWithoutInsuranceInput
    networkHospitals?: MedicalInstitutionCreateNestedManyWithoutInsuranceNetworksInput
    emergencyAccesses?: EmergencyAccessCreateNestedManyWithoutInsuranceInput
  }

  export type InsuranceCompanyUncheckedCreateInput = {
    id?: string
    name: string
    shortName?: string | null
    type: $Enums.InsuranceType
    cnsfNumber?: string | null
    rfc?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    phone?: string | null
    emergencyPhone?: string | null
    email?: string | null
    website?: string | null
    coverageTypes?: InsuranceCompanyCreatecoverageTypesInput | string[]
    networkSize?: number | null
    hasNationalCoverage?: boolean
    statesCovered?: InsuranceCompanyCreatestatesCoveredInput | string[]
    isVerified?: boolean
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    apiEnabled?: boolean
    apiEndpoint?: string | null
    logoUrl?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    plans?: InsurancePlanUncheckedCreateNestedManyWithoutInsuranceInput
    networkHospitals?: MedicalInstitutionUncheckedCreateNestedManyWithoutInsuranceNetworksInput
    emergencyAccesses?: EmergencyAccessUncheckedCreateNestedManyWithoutInsuranceInput
  }

  export type InsuranceCompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType
    cnsfNumber?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    coverageTypes?: InsuranceCompanyUpdatecoverageTypesInput | string[]
    networkSize?: NullableIntFieldUpdateOperationsInput | number | null
    hasNationalCoverage?: BoolFieldUpdateOperationsInput | boolean
    statesCovered?: InsuranceCompanyUpdatestatesCoveredInput | string[]
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    apiEnabled?: BoolFieldUpdateOperationsInput | boolean
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plans?: InsurancePlanUpdateManyWithoutInsuranceNestedInput
    networkHospitals?: MedicalInstitutionUpdateManyWithoutInsuranceNetworksNestedInput
    emergencyAccesses?: EmergencyAccessUpdateManyWithoutInsuranceNestedInput
  }

  export type InsuranceCompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType
    cnsfNumber?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    coverageTypes?: InsuranceCompanyUpdatecoverageTypesInput | string[]
    networkSize?: NullableIntFieldUpdateOperationsInput | number | null
    hasNationalCoverage?: BoolFieldUpdateOperationsInput | boolean
    statesCovered?: InsuranceCompanyUpdatestatesCoveredInput | string[]
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    apiEnabled?: BoolFieldUpdateOperationsInput | boolean
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plans?: InsurancePlanUncheckedUpdateManyWithoutInsuranceNestedInput
    networkHospitals?: MedicalInstitutionUncheckedUpdateManyWithoutInsuranceNetworksNestedInput
    emergencyAccesses?: EmergencyAccessUncheckedUpdateManyWithoutInsuranceNestedInput
  }

  export type InsuranceCompanyCreateManyInput = {
    id?: string
    name: string
    shortName?: string | null
    type: $Enums.InsuranceType
    cnsfNumber?: string | null
    rfc?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    phone?: string | null
    emergencyPhone?: string | null
    email?: string | null
    website?: string | null
    coverageTypes?: InsuranceCompanyCreatecoverageTypesInput | string[]
    networkSize?: number | null
    hasNationalCoverage?: boolean
    statesCovered?: InsuranceCompanyCreatestatesCoveredInput | string[]
    isVerified?: boolean
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    apiEnabled?: boolean
    apiEndpoint?: string | null
    logoUrl?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsuranceCompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType
    cnsfNumber?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    coverageTypes?: InsuranceCompanyUpdatecoverageTypesInput | string[]
    networkSize?: NullableIntFieldUpdateOperationsInput | number | null
    hasNationalCoverage?: BoolFieldUpdateOperationsInput | boolean
    statesCovered?: InsuranceCompanyUpdatestatesCoveredInput | string[]
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    apiEnabled?: BoolFieldUpdateOperationsInput | boolean
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsuranceCompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType
    cnsfNumber?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    coverageTypes?: InsuranceCompanyUpdatecoverageTypesInput | string[]
    networkSize?: NullableIntFieldUpdateOperationsInput | number | null
    hasNationalCoverage?: BoolFieldUpdateOperationsInput | boolean
    statesCovered?: InsuranceCompanyUpdatestatesCoveredInput | string[]
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    apiEnabled?: BoolFieldUpdateOperationsInput | boolean
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsurancePlanCreateInput = {
    id?: string
    name: string
    code?: string | null
    sumAssured?: number | null
    deductible?: number | null
    coinsurance?: number | null
    features?: InsurancePlanCreatefeaturesInput | string[]
    exclusions?: InsurancePlanCreateexclusionsInput | string[]
    hospitalLevel?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    insurance: InsuranceCompanyCreateNestedOneWithoutPlansInput
  }

  export type InsurancePlanUncheckedCreateInput = {
    id?: string
    insuranceId: string
    name: string
    code?: string | null
    sumAssured?: number | null
    deductible?: number | null
    coinsurance?: number | null
    features?: InsurancePlanCreatefeaturesInput | string[]
    exclusions?: InsurancePlanCreateexclusionsInput | string[]
    hospitalLevel?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsurancePlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sumAssured?: NullableFloatFieldUpdateOperationsInput | number | null
    deductible?: NullableFloatFieldUpdateOperationsInput | number | null
    coinsurance?: NullableFloatFieldUpdateOperationsInput | number | null
    features?: InsurancePlanUpdatefeaturesInput | string[]
    exclusions?: InsurancePlanUpdateexclusionsInput | string[]
    hospitalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insurance?: InsuranceCompanyUpdateOneRequiredWithoutPlansNestedInput
  }

  export type InsurancePlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    insuranceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sumAssured?: NullableFloatFieldUpdateOperationsInput | number | null
    deductible?: NullableFloatFieldUpdateOperationsInput | number | null
    coinsurance?: NullableFloatFieldUpdateOperationsInput | number | null
    features?: InsurancePlanUpdatefeaturesInput | string[]
    exclusions?: InsurancePlanUpdateexclusionsInput | string[]
    hospitalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsurancePlanCreateManyInput = {
    id?: string
    insuranceId: string
    name: string
    code?: string | null
    sumAssured?: number | null
    deductible?: number | null
    coinsurance?: number | null
    features?: InsurancePlanCreatefeaturesInput | string[]
    exclusions?: InsurancePlanCreateexclusionsInput | string[]
    hospitalLevel?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsurancePlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sumAssured?: NullableFloatFieldUpdateOperationsInput | number | null
    deductible?: NullableFloatFieldUpdateOperationsInput | number | null
    coinsurance?: NullableFloatFieldUpdateOperationsInput | number | null
    features?: InsurancePlanUpdatefeaturesInput | string[]
    exclusions?: InsurancePlanUpdateexclusionsInput | string[]
    hospitalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsurancePlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    insuranceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sumAssured?: NullableFloatFieldUpdateOperationsInput | number | null
    deductible?: NullableFloatFieldUpdateOperationsInput | number | null
    coinsurance?: NullableFloatFieldUpdateOperationsInput | number | null
    features?: InsurancePlanUpdatefeaturesInput | string[]
    exclusions?: InsurancePlanUpdateexclusionsInput | string[]
    hospitalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalStaffCreateInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.StaffRole
    license?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    institution: MedicalInstitutionCreateNestedOneWithoutStaffInput
  }

  export type MedicalStaffUncheckedCreateInput = {
    id?: string
    institutionId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.StaffRole
    license?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type MedicalStaffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    license?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    institution?: MedicalInstitutionUpdateOneRequiredWithoutStaffNestedInput
  }

  export type MedicalStaffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    license?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MedicalStaffCreateManyInput = {
    id?: string
    institutionId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.StaffRole
    license?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type MedicalStaffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    license?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MedicalStaffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    license?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogCreateInput = {
    id?: string
    actorType: string
    actorId?: string | null
    actorName?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    actorType: string
    actorId?: string | null
    actorName?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorType?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    actorName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actorType?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    actorName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    actorType: string
    actorId?: string | null
    actorName?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorType?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    actorName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actorType?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    actorName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateLegalTemplateCreateInput = {
    id?: string
    stateCode: string
    stateName: string
    lawName: string
    lawDate?: Date | string | null
    lawSummary?: string | null
    templateHtml?: string | null
    templateFields?: NullableJsonNullValueInput | InputJsonValue
    requiresNotary?: boolean
    requiresWitnesses?: number
    requiresMedicalCert?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StateLegalTemplateUncheckedCreateInput = {
    id?: string
    stateCode: string
    stateName: string
    lawName: string
    lawDate?: Date | string | null
    lawSummary?: string | null
    templateHtml?: string | null
    templateFields?: NullableJsonNullValueInput | InputJsonValue
    requiresNotary?: boolean
    requiresWitnesses?: number
    requiresMedicalCert?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StateLegalTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stateCode?: StringFieldUpdateOperationsInput | string
    stateName?: StringFieldUpdateOperationsInput | string
    lawName?: StringFieldUpdateOperationsInput | string
    lawDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lawSummary?: NullableStringFieldUpdateOperationsInput | string | null
    templateHtml?: NullableStringFieldUpdateOperationsInput | string | null
    templateFields?: NullableJsonNullValueInput | InputJsonValue
    requiresNotary?: BoolFieldUpdateOperationsInput | boolean
    requiresWitnesses?: IntFieldUpdateOperationsInput | number
    requiresMedicalCert?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateLegalTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stateCode?: StringFieldUpdateOperationsInput | string
    stateName?: StringFieldUpdateOperationsInput | string
    lawName?: StringFieldUpdateOperationsInput | string
    lawDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lawSummary?: NullableStringFieldUpdateOperationsInput | string | null
    templateHtml?: NullableStringFieldUpdateOperationsInput | string | null
    templateFields?: NullableJsonNullValueInput | InputJsonValue
    requiresNotary?: BoolFieldUpdateOperationsInput | boolean
    requiresWitnesses?: IntFieldUpdateOperationsInput | number
    requiresMedicalCert?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateLegalTemplateCreateManyInput = {
    id?: string
    stateCode: string
    stateName: string
    lawName: string
    lawDate?: Date | string | null
    lawSummary?: string | null
    templateHtml?: string | null
    templateFields?: NullableJsonNullValueInput | InputJsonValue
    requiresNotary?: boolean
    requiresWitnesses?: number
    requiresMedicalCert?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StateLegalTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stateCode?: StringFieldUpdateOperationsInput | string
    stateName?: StringFieldUpdateOperationsInput | string
    lawName?: StringFieldUpdateOperationsInput | string
    lawDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lawSummary?: NullableStringFieldUpdateOperationsInput | string | null
    templateHtml?: NullableStringFieldUpdateOperationsInput | string | null
    templateFields?: NullableJsonNullValueInput | InputJsonValue
    requiresNotary?: BoolFieldUpdateOperationsInput | boolean
    requiresWitnesses?: IntFieldUpdateOperationsInput | number
    requiresMedicalCert?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateLegalTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stateCode?: StringFieldUpdateOperationsInput | string
    stateName?: StringFieldUpdateOperationsInput | string
    lawName?: StringFieldUpdateOperationsInput | string
    lawDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lawSummary?: NullableStringFieldUpdateOperationsInput | string | null
    templateHtml?: NullableStringFieldUpdateOperationsInput | string | null
    templateFields?: NullableJsonNullValueInput | InputJsonValue
    requiresNotary?: BoolFieldUpdateOperationsInput | boolean
    requiresWitnesses?: IntFieldUpdateOperationsInput | number
    requiresMedicalCert?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    userId?: string | null
    email?: string | null
    phone?: string | null
    type: $Enums.NotificationType
    channel: $Enums.NotificationChannel
    subject?: string | null
    body: string
    status?: $Enums.NotificationStatus
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId?: string | null
    email?: string | null
    phone?: string | null
    type: $Enums.NotificationType
    channel: $Enums.NotificationChannel
    subject?: string | null
    body: string
    status?: $Enums.NotificationStatus
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId?: string | null
    email?: string | null
    phone?: string | null
    type: $Enums.NotificationType
    channel: $Enums.NotificationChannel
    subject?: string | null
    body: string
    status?: $Enums.NotificationStatus
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PanicAlertCreateInput = {
    id?: string
    latitude: number
    longitude: number
    accuracy?: number | null
    locationName?: string | null
    status?: $Enums.PanicStatus
    message?: string | null
    cancelledAt?: Date | string | null
    resolvedAt?: Date | string | null
    nearbyHospitals?: NullableJsonNullValueInput | InputJsonValue
    notificationsSent?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPanicAlertsInput
  }

  export type PanicAlertUncheckedCreateInput = {
    id?: string
    userId: string
    latitude: number
    longitude: number
    accuracy?: number | null
    locationName?: string | null
    status?: $Enums.PanicStatus
    message?: string | null
    cancelledAt?: Date | string | null
    resolvedAt?: Date | string | null
    nearbyHospitals?: NullableJsonNullValueInput | InputJsonValue
    notificationsSent?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PanicAlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPanicStatusFieldUpdateOperationsInput | $Enums.PanicStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nearbyHospitals?: NullableJsonNullValueInput | InputJsonValue
    notificationsSent?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPanicAlertsNestedInput
  }

  export type PanicAlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPanicStatusFieldUpdateOperationsInput | $Enums.PanicStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nearbyHospitals?: NullableJsonNullValueInput | InputJsonValue
    notificationsSent?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PanicAlertCreateManyInput = {
    id?: string
    userId: string
    latitude: number
    longitude: number
    accuracy?: number | null
    locationName?: string | null
    status?: $Enums.PanicStatus
    message?: string | null
    cancelledAt?: Date | string | null
    resolvedAt?: Date | string | null
    nearbyHospitals?: NullableJsonNullValueInput | InputJsonValue
    notificationsSent?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PanicAlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPanicStatusFieldUpdateOperationsInput | $Enums.PanicStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nearbyHospitals?: NullableJsonNullValueInput | InputJsonValue
    notificationsSent?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PanicAlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPanicStatusFieldUpdateOperationsInput | $Enums.PanicStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nearbyHospitals?: NullableJsonNullValueInput | InputJsonValue
    notificationsSent?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role?: $Enums.AdminRole
    permissions?: AdminUserCreatepermissionsInput | string[]
    isActive?: boolean
    isSuperAdmin?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    sessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditActions?: AdminAuditLogCreateNestedManyWithoutAdminInput
  }

  export type AdminUserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role?: $Enums.AdminRole
    permissions?: AdminUserCreatepermissionsInput | string[]
    isActive?: boolean
    isSuperAdmin?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    sessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditActions?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    permissions?: AdminUserUpdatepermissionsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditActions?: AdminAuditLogUpdateManyWithoutAdminNestedInput
  }

  export type AdminUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    permissions?: AdminUserUpdatepermissionsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditActions?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminUserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role?: $Enums.AdminRole
    permissions?: AdminUserCreatepermissionsInput | string[]
    isActive?: boolean
    isSuperAdmin?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type AdminUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    permissions?: AdminUserUpdatepermissionsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    permissions?: AdminUserUpdatepermissionsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminSessionCreateInput = {
    id?: string
    refreshToken: string
    userAgent?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    admin: AdminUserCreateNestedOneWithoutSessionsInput
  }

  export type AdminSessionUncheckedCreateInput = {
    id?: string
    adminId: string
    refreshToken: string
    userAgent?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type AdminSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type AdminSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSessionCreateManyInput = {
    id?: string
    adminId: string
    refreshToken: string
    userAgent?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type AdminSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogCreateInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    admin: AdminUserCreateNestedOneWithoutAuditActionsInput
  }

  export type AdminAuditLogUncheckedCreateInput = {
    id?: string
    adminId: string
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AdminAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUserUpdateOneRequiredWithoutAuditActionsNestedInput
  }

  export type AdminAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogCreateManyInput = {
    id?: string
    adminId: string
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AdminAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    priceMonthly?: Decimal | DecimalJsLike | number | string | null
    priceAnnual?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    stripePriceIdMonthly?: string | null
    stripePriceIdAnnual?: string | null
    stripeProductId?: string | null
    features: JsonNullValueInput | InputJsonValue
    limits: JsonNullValueInput | InputJsonValue
    trialDays?: number
    isActive?: boolean
    isDefault?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    priceMonthly?: Decimal | DecimalJsLike | number | string | null
    priceAnnual?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    stripePriceIdMonthly?: string | null
    stripePriceIdAnnual?: string | null
    stripeProductId?: string | null
    features: JsonNullValueInput | InputJsonValue
    limits: JsonNullValueInput | InputJsonValue
    trialDays?: number
    isActive?: boolean
    isDefault?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceAnnual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    stripePriceIdMonthly?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceIdAnnual?: NullableStringFieldUpdateOperationsInput | string | null
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    limits?: JsonNullValueInput | InputJsonValue
    trialDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceAnnual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    stripePriceIdMonthly?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceIdAnnual?: NullableStringFieldUpdateOperationsInput | string | null
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    limits?: JsonNullValueInput | InputJsonValue
    trialDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    priceMonthly?: Decimal | DecimalJsLike | number | string | null
    priceAnnual?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    stripePriceIdMonthly?: string | null
    stripePriceIdAnnual?: string | null
    stripeProductId?: string | null
    features: JsonNullValueInput | InputJsonValue
    limits: JsonNullValueInput | InputJsonValue
    trialDays?: number
    isActive?: boolean
    isDefault?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceAnnual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    stripePriceIdMonthly?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceIdAnnual?: NullableStringFieldUpdateOperationsInput | string | null
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    limits?: JsonNullValueInput | InputJsonValue
    trialDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceAnnual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    stripePriceIdMonthly?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceIdAnnual?: NullableStringFieldUpdateOperationsInput | string | null
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    limits?: JsonNullValueInput | InputJsonValue
    trialDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    billingCycle?: $Enums.BillingCycle
    status?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionInput
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
    payments?: PaymentCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    planId: string
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    billingCycle?: $Enums.BillingCycle
    status?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    payments?: PaymentUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    userId: string
    planId: string
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    billingCycle?: $Enums.BillingCycle
    status?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    stripeInvoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod: $Enums.PaymentMethodType
    last4?: string | null
    cardBrand?: string | null
    oxxoVoucherUrl?: string | null
    oxxoExpiresAt?: Date | string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    failureCode?: string | null
    failureMessage?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
    subscription?: SubscriptionCreateNestedOneWithoutPaymentsInput
    invoice?: InvoiceCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    userId: string
    subscriptionId?: string | null
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    stripeInvoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod: $Enums.PaymentMethodType
    last4?: string | null
    cardBrand?: string | null
    oxxoVoucherUrl?: string | null
    oxxoExpiresAt?: Date | string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    failureCode?: string | null
    failureMessage?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    oxxoVoucherUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oxxoExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    failureCode?: NullableStringFieldUpdateOperationsInput | string | null
    failureMessage?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    subscription?: SubscriptionUpdateOneWithoutPaymentsNestedInput
    invoice?: InvoiceUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    oxxoVoucherUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oxxoExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    failureCode?: NullableStringFieldUpdateOperationsInput | string | null
    failureMessage?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentCreateManyInput = {
    id?: string
    userId: string
    subscriptionId?: string | null
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    stripeInvoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod: $Enums.PaymentMethodType
    last4?: string | null
    cardBrand?: string | null
    oxxoVoucherUrl?: string | null
    oxxoExpiresAt?: Date | string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    failureCode?: string | null
    failureMessage?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    oxxoVoucherUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oxxoExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    failureCode?: NullableStringFieldUpdateOperationsInput | string | null
    failureMessage?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    oxxoVoucherUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oxxoExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    failureCode?: NullableStringFieldUpdateOperationsInput | string | null
    failureMessage?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodCreateInput = {
    id?: string
    stripePaymentMethodId: string
    type?: $Enums.PaymentMethodType
    last4: string
    brand: string
    expMonth: number
    expYear: number
    cardholderName?: string | null
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentMethodsInput
  }

  export type PaymentMethodUncheckedCreateInput = {
    id?: string
    userId: string
    stripePaymentMethodId: string
    type?: $Enums.PaymentMethodType
    last4: string
    brand: string
    expMonth: number
    expYear: number
    cardholderName?: string | null
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentMethodId?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    last4?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    expMonth?: IntFieldUpdateOperationsInput | number
    expYear?: IntFieldUpdateOperationsInput | number
    cardholderName?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentMethodsNestedInput
  }

  export type PaymentMethodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripePaymentMethodId?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    last4?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    expMonth?: IntFieldUpdateOperationsInput | number
    expYear?: IntFieldUpdateOperationsInput | number
    cardholderName?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodCreateManyInput = {
    id?: string
    userId: string
    stripePaymentMethodId: string
    type?: $Enums.PaymentMethodType
    last4: string
    brand: string
    expMonth: number
    expYear: number
    cardholderName?: string | null
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentMethodId?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    last4?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    expMonth?: IntFieldUpdateOperationsInput | number
    expYear?: IntFieldUpdateOperationsInput | number
    cardholderName?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripePaymentMethodId?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    last4?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    expMonth?: IntFieldUpdateOperationsInput | number
    expYear?: IntFieldUpdateOperationsInput | number
    cardholderName?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiscalDataCreateInput = {
    id?: string
    rfc: string
    razonSocial: string
    regimenFiscal: string
    usoCFDI?: string
    codigoPostal: string
    calle?: string | null
    numExterior?: string | null
    numInterior?: string | null
    colonia?: string | null
    municipio?: string | null
    estado?: string | null
    emailFacturacion: string
    facturamaClientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFiscalDataInput
    invoices?: InvoiceCreateNestedManyWithoutFiscalDataInput
  }

  export type FiscalDataUncheckedCreateInput = {
    id?: string
    userId: string
    rfc: string
    razonSocial: string
    regimenFiscal: string
    usoCFDI?: string
    codigoPostal: string
    calle?: string | null
    numExterior?: string | null
    numInterior?: string | null
    colonia?: string | null
    municipio?: string | null
    estado?: string | null
    emailFacturacion: string
    facturamaClientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutFiscalDataInput
  }

  export type FiscalDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rfc?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    regimenFiscal?: StringFieldUpdateOperationsInput | string
    usoCFDI?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    calle?: NullableStringFieldUpdateOperationsInput | string | null
    numExterior?: NullableStringFieldUpdateOperationsInput | string | null
    numInterior?: NullableStringFieldUpdateOperationsInput | string | null
    colonia?: NullableStringFieldUpdateOperationsInput | string | null
    municipio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    emailFacturacion?: StringFieldUpdateOperationsInput | string
    facturamaClientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFiscalDataNestedInput
    invoices?: InvoiceUpdateManyWithoutFiscalDataNestedInput
  }

  export type FiscalDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rfc?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    regimenFiscal?: StringFieldUpdateOperationsInput | string
    usoCFDI?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    calle?: NullableStringFieldUpdateOperationsInput | string | null
    numExterior?: NullableStringFieldUpdateOperationsInput | string | null
    numInterior?: NullableStringFieldUpdateOperationsInput | string | null
    colonia?: NullableStringFieldUpdateOperationsInput | string | null
    municipio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    emailFacturacion?: StringFieldUpdateOperationsInput | string
    facturamaClientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutFiscalDataNestedInput
  }

  export type FiscalDataCreateManyInput = {
    id?: string
    userId: string
    rfc: string
    razonSocial: string
    regimenFiscal: string
    usoCFDI?: string
    codigoPostal: string
    calle?: string | null
    numExterior?: string | null
    numInterior?: string | null
    colonia?: string | null
    municipio?: string | null
    estado?: string | null
    emailFacturacion: string
    facturamaClientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FiscalDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rfc?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    regimenFiscal?: StringFieldUpdateOperationsInput | string
    usoCFDI?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    calle?: NullableStringFieldUpdateOperationsInput | string | null
    numExterior?: NullableStringFieldUpdateOperationsInput | string | null
    numInterior?: NullableStringFieldUpdateOperationsInput | string | null
    colonia?: NullableStringFieldUpdateOperationsInput | string | null
    municipio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    emailFacturacion?: StringFieldUpdateOperationsInput | string
    facturamaClientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiscalDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rfc?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    regimenFiscal?: StringFieldUpdateOperationsInput | string
    usoCFDI?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    calle?: NullableStringFieldUpdateOperationsInput | string | null
    numExterior?: NullableStringFieldUpdateOperationsInput | string | null
    numInterior?: NullableStringFieldUpdateOperationsInput | string | null
    colonia?: NullableStringFieldUpdateOperationsInput | string | null
    municipio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    emailFacturacion?: StringFieldUpdateOperationsInput | string
    facturamaClientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    facturamaInvoiceId?: string | null
    uuid?: string | null
    serie?: string | null
    folio?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    xmlUrl?: string | null
    pdfUrl?: string | null
    status?: $Enums.InvoiceStatus
    issuedAt?: Date | string | null
    cancelledAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInvoicesInput
    payment: PaymentCreateNestedOneWithoutInvoiceInput
    fiscalData?: FiscalDataCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    userId: string
    paymentId: string
    fiscalDataId?: string | null
    facturamaInvoiceId?: string | null
    uuid?: string | null
    serie?: string | null
    folio?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    xmlUrl?: string | null
    pdfUrl?: string | null
    status?: $Enums.InvoiceStatus
    issuedAt?: Date | string | null
    cancelledAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    facturamaInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableStringFieldUpdateOperationsInput | string | null
    folio?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    xmlUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    payment?: PaymentUpdateOneRequiredWithoutInvoiceNestedInput
    fiscalData?: FiscalDataUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    fiscalDataId?: NullableStringFieldUpdateOperationsInput | string | null
    facturamaInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableStringFieldUpdateOperationsInput | string | null
    folio?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    xmlUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyInput = {
    id?: string
    userId: string
    paymentId: string
    fiscalDataId?: string | null
    facturamaInvoiceId?: string | null
    uuid?: string | null
    serie?: string | null
    folio?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    xmlUrl?: string | null
    pdfUrl?: string | null
    status?: $Enums.InvoiceStatus
    issuedAt?: Date | string | null
    cancelledAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    facturamaInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableStringFieldUpdateOperationsInput | string | null
    folio?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    xmlUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    fiscalDataId?: NullableStringFieldUpdateOperationsInput | string | null
    facturamaInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableStringFieldUpdateOperationsInput | string | null
    folio?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    xmlUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PatientProfileNullableRelationFilter = {
    is?: PatientProfileWhereInput | null
    isNot?: PatientProfileWhereInput | null
  }

  export type AdvanceDirectiveListRelationFilter = {
    every?: AdvanceDirectiveWhereInput
    some?: AdvanceDirectiveWhereInput
    none?: AdvanceDirectiveWhereInput
  }

  export type RepresentativeListRelationFilter = {
    every?: RepresentativeWhereInput
    some?: RepresentativeWhereInput
    none?: RepresentativeWhereInput
  }

  export type EmergencyAccessListRelationFilter = {
    every?: EmergencyAccessWhereInput
    some?: EmergencyAccessWhereInput
    none?: EmergencyAccessWhereInput
  }

  export type PanicAlertListRelationFilter = {
    every?: PanicAlertWhereInput
    some?: PanicAlertWhereInput
    none?: PanicAlertWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type WebAuthnCredentialListRelationFilter = {
    every?: WebAuthnCredentialWhereInput
    some?: WebAuthnCredentialWhereInput
    none?: WebAuthnCredentialWhereInput
  }

  export type SubscriptionNullableRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentMethodListRelationFilter = {
    every?: PaymentMethodWhereInput
    some?: PaymentMethodWhereInput
    none?: PaymentMethodWhereInput
  }

  export type FiscalDataNullableRelationFilter = {
    is?: FiscalDataWhereInput | null
    isNot?: FiscalDataWhereInput | null
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AdvanceDirectiveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RepresentativeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmergencyAccessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PanicAlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebAuthnCredentialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentMethodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    curp?: SortOrder
    name?: SortOrder
    dateOfBirth?: SortOrder
    sex?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    verificationToken?: SortOrder
    verificationExpires?: SortOrder
    resetToken?: SortOrder
    resetExpires?: SortOrder
    webauthnChallenge?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    curp?: SortOrder
    name?: SortOrder
    dateOfBirth?: SortOrder
    sex?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    verificationToken?: SortOrder
    verificationExpires?: SortOrder
    resetToken?: SortOrder
    resetExpires?: SortOrder
    webauthnChallenge?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    curp?: SortOrder
    name?: SortOrder
    dateOfBirth?: SortOrder
    sex?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    verificationToken?: SortOrder
    verificationExpires?: SortOrder
    resetToken?: SortOrder
    resetExpires?: SortOrder
    webauthnChallenge?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type WebAuthnCredentialCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
    credentialPublicKey?: SortOrder
    counter?: SortOrder
    deviceType?: SortOrder
    deviceName?: SortOrder
    transports?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type WebAuthnCredentialAvgOrderByAggregateInput = {
    counter?: SortOrder
  }

  export type WebAuthnCredentialMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
    credentialPublicKey?: SortOrder
    counter?: SortOrder
    deviceType?: SortOrder
    deviceName?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type WebAuthnCredentialMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
    credentialPublicKey?: SortOrder
    counter?: SortOrder
    deviceType?: SortOrder
    deviceName?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type WebAuthnCredentialSumOrderByAggregateInput = {
    counter?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type PatientProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bloodType?: SortOrder
    allergiesEnc?: SortOrder
    conditionsEnc?: SortOrder
    medicationsEnc?: SortOrder
    insuranceProvider?: SortOrder
    insurancePolicy?: SortOrder
    insurancePhone?: SortOrder
    photoUrl?: SortOrder
    isDonor?: SortOrder
    donorPreferencesEnc?: SortOrder
    donorVideoUrl?: SortOrder
    qrToken?: SortOrder
    qrGeneratedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bloodType?: SortOrder
    allergiesEnc?: SortOrder
    conditionsEnc?: SortOrder
    medicationsEnc?: SortOrder
    insuranceProvider?: SortOrder
    insurancePolicy?: SortOrder
    insurancePhone?: SortOrder
    photoUrl?: SortOrder
    isDonor?: SortOrder
    donorPreferencesEnc?: SortOrder
    donorVideoUrl?: SortOrder
    qrToken?: SortOrder
    qrGeneratedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bloodType?: SortOrder
    allergiesEnc?: SortOrder
    conditionsEnc?: SortOrder
    medicationsEnc?: SortOrder
    insuranceProvider?: SortOrder
    insurancePolicy?: SortOrder
    insurancePhone?: SortOrder
    photoUrl?: SortOrder
    isDonor?: SortOrder
    donorPreferencesEnc?: SortOrder
    donorVideoUrl?: SortOrder
    qrToken?: SortOrder
    qrGeneratedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type RepresentativeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    relation?: SortOrder
    priority?: SortOrder
    isDonorSpokesperson?: SortOrder
    notifyOnEmergency?: SortOrder
    notifyOnAccess?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RepresentativeAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type RepresentativeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    relation?: SortOrder
    priority?: SortOrder
    isDonorSpokesperson?: SortOrder
    notifyOnEmergency?: SortOrder
    notifyOnAccess?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RepresentativeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    relation?: SortOrder
    priority?: SortOrder
    isDonorSpokesperson?: SortOrder
    notifyOnEmergency?: SortOrder
    notifyOnAccess?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RepresentativeSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumDirectiveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DirectiveType | EnumDirectiveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DirectiveType[] | ListEnumDirectiveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DirectiveType[] | ListEnumDirectiveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectiveTypeFilter<$PrismaModel> | $Enums.DirectiveType
  }

  export type EnumDirectiveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DirectiveStatus | EnumDirectiveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DirectiveStatus[] | ListEnumDirectiveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DirectiveStatus[] | ListEnumDirectiveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectiveStatusFilter<$PrismaModel> | $Enums.DirectiveStatus
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type WitnessListRelationFilter = {
    every?: WitnessWhereInput
    some?: WitnessWhereInput
    none?: WitnessWhereInput
  }

  export type WitnessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdvanceDirectiveCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    documentUrl?: SortOrder
    documentHash?: SortOrder
    originalFileName?: SortOrder
    nom151Sealed?: SortOrder
    nom151Timestamp?: SortOrder
    nom151Certificate?: SortOrder
    nom151Provider?: SortOrder
    acceptsCPR?: SortOrder
    acceptsIntubation?: SortOrder
    acceptsDialysis?: SortOrder
    acceptsTransfusion?: SortOrder
    acceptsArtificialNutrition?: SortOrder
    palliativeCareOnly?: SortOrder
    additionalNotes?: SortOrder
    originState?: SortOrder
    legalBasisSummary?: SortOrder
    validatedAt?: SortOrder
    validatedBy?: SortOrder
    validationMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    revokedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type AdvanceDirectiveMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    documentUrl?: SortOrder
    documentHash?: SortOrder
    originalFileName?: SortOrder
    nom151Sealed?: SortOrder
    nom151Timestamp?: SortOrder
    nom151Certificate?: SortOrder
    nom151Provider?: SortOrder
    acceptsCPR?: SortOrder
    acceptsIntubation?: SortOrder
    acceptsDialysis?: SortOrder
    acceptsTransfusion?: SortOrder
    acceptsArtificialNutrition?: SortOrder
    palliativeCareOnly?: SortOrder
    additionalNotes?: SortOrder
    originState?: SortOrder
    legalBasisSummary?: SortOrder
    validatedAt?: SortOrder
    validatedBy?: SortOrder
    validationMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    revokedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type AdvanceDirectiveMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    documentUrl?: SortOrder
    documentHash?: SortOrder
    originalFileName?: SortOrder
    nom151Sealed?: SortOrder
    nom151Timestamp?: SortOrder
    nom151Certificate?: SortOrder
    nom151Provider?: SortOrder
    acceptsCPR?: SortOrder
    acceptsIntubation?: SortOrder
    acceptsDialysis?: SortOrder
    acceptsTransfusion?: SortOrder
    acceptsArtificialNutrition?: SortOrder
    palliativeCareOnly?: SortOrder
    additionalNotes?: SortOrder
    originState?: SortOrder
    legalBasisSummary?: SortOrder
    validatedAt?: SortOrder
    validatedBy?: SortOrder
    validationMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    revokedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type EnumDirectiveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DirectiveType | EnumDirectiveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DirectiveType[] | ListEnumDirectiveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DirectiveType[] | ListEnumDirectiveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectiveTypeWithAggregatesFilter<$PrismaModel> | $Enums.DirectiveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDirectiveTypeFilter<$PrismaModel>
    _max?: NestedEnumDirectiveTypeFilter<$PrismaModel>
  }

  export type EnumDirectiveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DirectiveStatus | EnumDirectiveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DirectiveStatus[] | ListEnumDirectiveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DirectiveStatus[] | ListEnumDirectiveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectiveStatusWithAggregatesFilter<$PrismaModel> | $Enums.DirectiveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDirectiveStatusFilter<$PrismaModel>
    _max?: NestedEnumDirectiveStatusFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type AdvanceDirectiveRelationFilter = {
    is?: AdvanceDirectiveWhereInput
    isNot?: AdvanceDirectiveWhereInput
  }

  export type WitnessCountOrderByAggregateInput = {
    id?: SortOrder
    directiveId?: SortOrder
    name?: SortOrder
    curp?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    ineImageUrl?: SortOrder
    selfieImageUrl?: SortOrder
    identityVerified?: SortOrder
    verifiedAt?: SortOrder
    signatureImageUrl?: SortOrder
    signedAt?: SortOrder
    sessionId?: SortOrder
    sessionRecordingUrl?: SortOrder
    sessionStartedAt?: SortOrder
    sessionEndedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type WitnessMaxOrderByAggregateInput = {
    id?: SortOrder
    directiveId?: SortOrder
    name?: SortOrder
    curp?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    ineImageUrl?: SortOrder
    selfieImageUrl?: SortOrder
    identityVerified?: SortOrder
    verifiedAt?: SortOrder
    signatureImageUrl?: SortOrder
    signedAt?: SortOrder
    sessionId?: SortOrder
    sessionRecordingUrl?: SortOrder
    sessionStartedAt?: SortOrder
    sessionEndedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type WitnessMinOrderByAggregateInput = {
    id?: SortOrder
    directiveId?: SortOrder
    name?: SortOrder
    curp?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    ineImageUrl?: SortOrder
    selfieImageUrl?: SortOrder
    identityVerified?: SortOrder
    verifiedAt?: SortOrder
    signatureImageUrl?: SortOrder
    signedAt?: SortOrder
    sessionId?: SortOrder
    sessionRecordingUrl?: SortOrder
    sessionStartedAt?: SortOrder
    sessionEndedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type MedicalInstitutionNullableRelationFilter = {
    is?: MedicalInstitutionWhereInput | null
    isNot?: MedicalInstitutionWhereInput | null
  }

  export type InsuranceCompanyNullableRelationFilter = {
    is?: InsuranceCompanyWhereInput | null
    isNot?: InsuranceCompanyWhereInput | null
  }

  export type EmergencyAccessCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    accessorId?: SortOrder
    accessorName?: SortOrder
    accessorRole?: SortOrder
    accessorLicense?: SortOrder
    institutionId?: SortOrder
    institutionName?: SortOrder
    insuranceId?: SortOrder
    insurancePolicyNo?: SortOrder
    qrTokenUsed?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    locationName?: SortOrder
    dataAccessed?: SortOrder
    representativesNotified?: SortOrder
    notificationsSentAt?: SortOrder
    accessToken?: SortOrder
    accessedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type EmergencyAccessAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type EmergencyAccessMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    accessorId?: SortOrder
    accessorName?: SortOrder
    accessorRole?: SortOrder
    accessorLicense?: SortOrder
    institutionId?: SortOrder
    institutionName?: SortOrder
    insuranceId?: SortOrder
    insurancePolicyNo?: SortOrder
    qrTokenUsed?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    locationName?: SortOrder
    notificationsSentAt?: SortOrder
    accessToken?: SortOrder
    accessedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type EmergencyAccessMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    accessorId?: SortOrder
    accessorName?: SortOrder
    accessorRole?: SortOrder
    accessorLicense?: SortOrder
    institutionId?: SortOrder
    institutionName?: SortOrder
    insuranceId?: SortOrder
    insurancePolicyNo?: SortOrder
    qrTokenUsed?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    locationName?: SortOrder
    notificationsSentAt?: SortOrder
    accessToken?: SortOrder
    accessedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type EmergencyAccessSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumInstitutionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InstitutionType | EnumInstitutionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInstitutionTypeFilter<$PrismaModel> | $Enums.InstitutionType
  }

  export type EnumAttentionLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AttentionLevel | EnumAttentionLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.AttentionLevel[] | ListEnumAttentionLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AttentionLevel[] | ListEnumAttentionLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAttentionLevelNullableFilter<$PrismaModel> | $Enums.AttentionLevel | null
  }

  export type MedicalStaffListRelationFilter = {
    every?: MedicalStaffWhereInput
    some?: MedicalStaffWhereInput
    none?: MedicalStaffWhereInput
  }

  export type InsuranceCompanyListRelationFilter = {
    every?: InsuranceCompanyWhereInput
    some?: InsuranceCompanyWhereInput
    none?: InsuranceCompanyWhereInput
  }

  export type MedicalStaffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InsuranceCompanyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicalInstitutionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    cluesCode?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    phone?: SortOrder
    emergencyPhone?: SortOrder
    email?: SortOrder
    attentionLevel?: SortOrder
    specialties?: SortOrder
    hasEmergency?: SortOrder
    has24Hours?: SortOrder
    hasICU?: SortOrder
    hasTrauma?: SortOrder
    oauthClientId?: SortOrder
    oauthClientSecret?: SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalInstitutionAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type MedicalInstitutionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    cluesCode?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    phone?: SortOrder
    emergencyPhone?: SortOrder
    email?: SortOrder
    attentionLevel?: SortOrder
    hasEmergency?: SortOrder
    has24Hours?: SortOrder
    hasICU?: SortOrder
    hasTrauma?: SortOrder
    oauthClientId?: SortOrder
    oauthClientSecret?: SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalInstitutionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    cluesCode?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    phone?: SortOrder
    emergencyPhone?: SortOrder
    email?: SortOrder
    attentionLevel?: SortOrder
    hasEmergency?: SortOrder
    has24Hours?: SortOrder
    hasICU?: SortOrder
    hasTrauma?: SortOrder
    oauthClientId?: SortOrder
    oauthClientSecret?: SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalInstitutionSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type EnumInstitutionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstitutionType | EnumInstitutionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInstitutionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InstitutionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstitutionTypeFilter<$PrismaModel>
    _max?: NestedEnumInstitutionTypeFilter<$PrismaModel>
  }

  export type EnumAttentionLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttentionLevel | EnumAttentionLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.AttentionLevel[] | ListEnumAttentionLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AttentionLevel[] | ListEnumAttentionLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAttentionLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.AttentionLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAttentionLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumAttentionLevelNullableFilter<$PrismaModel>
  }

  export type EnumInsuranceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InsuranceType | EnumInsuranceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InsuranceType[] | ListEnumInsuranceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsuranceType[] | ListEnumInsuranceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInsuranceTypeFilter<$PrismaModel> | $Enums.InsuranceType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type InsurancePlanListRelationFilter = {
    every?: InsurancePlanWhereInput
    some?: InsurancePlanWhereInput
    none?: InsurancePlanWhereInput
  }

  export type MedicalInstitutionListRelationFilter = {
    every?: MedicalInstitutionWhereInput
    some?: MedicalInstitutionWhereInput
    none?: MedicalInstitutionWhereInput
  }

  export type InsurancePlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicalInstitutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InsuranceCompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    type?: SortOrder
    cnsfNumber?: SortOrder
    rfc?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    emergencyPhone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    coverageTypes?: SortOrder
    networkSize?: SortOrder
    hasNationalCoverage?: SortOrder
    statesCovered?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    verifiedBy?: SortOrder
    apiEnabled?: SortOrder
    apiEndpoint?: SortOrder
    logoUrl?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InsuranceCompanyAvgOrderByAggregateInput = {
    networkSize?: SortOrder
  }

  export type InsuranceCompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    type?: SortOrder
    cnsfNumber?: SortOrder
    rfc?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    emergencyPhone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    networkSize?: SortOrder
    hasNationalCoverage?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    verifiedBy?: SortOrder
    apiEnabled?: SortOrder
    apiEndpoint?: SortOrder
    logoUrl?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InsuranceCompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    type?: SortOrder
    cnsfNumber?: SortOrder
    rfc?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    emergencyPhone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    networkSize?: SortOrder
    hasNationalCoverage?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    verifiedBy?: SortOrder
    apiEnabled?: SortOrder
    apiEndpoint?: SortOrder
    logoUrl?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InsuranceCompanySumOrderByAggregateInput = {
    networkSize?: SortOrder
  }

  export type EnumInsuranceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsuranceType | EnumInsuranceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InsuranceType[] | ListEnumInsuranceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsuranceType[] | ListEnumInsuranceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInsuranceTypeWithAggregatesFilter<$PrismaModel> | $Enums.InsuranceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsuranceTypeFilter<$PrismaModel>
    _max?: NestedEnumInsuranceTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type InsuranceCompanyRelationFilter = {
    is?: InsuranceCompanyWhereInput
    isNot?: InsuranceCompanyWhereInput
  }

  export type InsurancePlanCountOrderByAggregateInput = {
    id?: SortOrder
    insuranceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    sumAssured?: SortOrder
    deductible?: SortOrder
    coinsurance?: SortOrder
    features?: SortOrder
    exclusions?: SortOrder
    hospitalLevel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InsurancePlanAvgOrderByAggregateInput = {
    sumAssured?: SortOrder
    deductible?: SortOrder
    coinsurance?: SortOrder
  }

  export type InsurancePlanMaxOrderByAggregateInput = {
    id?: SortOrder
    insuranceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    sumAssured?: SortOrder
    deductible?: SortOrder
    coinsurance?: SortOrder
    hospitalLevel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InsurancePlanMinOrderByAggregateInput = {
    id?: SortOrder
    insuranceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    sumAssured?: SortOrder
    deductible?: SortOrder
    coinsurance?: SortOrder
    hospitalLevel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InsurancePlanSumOrderByAggregateInput = {
    sumAssured?: SortOrder
    deductible?: SortOrder
    coinsurance?: SortOrder
  }

  export type EnumStaffRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffRole | EnumStaffRoleFieldRefInput<$PrismaModel>
    in?: $Enums.StaffRole[] | ListEnumStaffRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.StaffRole[] | ListEnumStaffRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumStaffRoleFilter<$PrismaModel> | $Enums.StaffRole
  }

  export type MedicalInstitutionRelationFilter = {
    is?: MedicalInstitutionWhereInput
    isNot?: MedicalInstitutionWhereInput
  }

  export type MedicalStaffCountOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    license?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type MedicalStaffMaxOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    license?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type MedicalStaffMinOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    license?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type EnumStaffRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffRole | EnumStaffRoleFieldRefInput<$PrismaModel>
    in?: $Enums.StaffRole[] | ListEnumStaffRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.StaffRole[] | ListEnumStaffRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumStaffRoleWithAggregatesFilter<$PrismaModel> | $Enums.StaffRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStaffRoleFilter<$PrismaModel>
    _max?: NestedEnumStaffRoleFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    actorType?: SortOrder
    actorId?: SortOrder
    actorName?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    details?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    actorType?: SortOrder
    actorId?: SortOrder
    actorName?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    actorType?: SortOrder
    actorId?: SortOrder
    actorName?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type StateLegalTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    stateCode?: SortOrder
    stateName?: SortOrder
    lawName?: SortOrder
    lawDate?: SortOrder
    lawSummary?: SortOrder
    templateHtml?: SortOrder
    templateFields?: SortOrder
    requiresNotary?: SortOrder
    requiresWitnesses?: SortOrder
    requiresMedicalCert?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StateLegalTemplateAvgOrderByAggregateInput = {
    requiresWitnesses?: SortOrder
  }

  export type StateLegalTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    stateCode?: SortOrder
    stateName?: SortOrder
    lawName?: SortOrder
    lawDate?: SortOrder
    lawSummary?: SortOrder
    templateHtml?: SortOrder
    requiresNotary?: SortOrder
    requiresWitnesses?: SortOrder
    requiresMedicalCert?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StateLegalTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    stateCode?: SortOrder
    stateName?: SortOrder
    lawName?: SortOrder
    lawDate?: SortOrder
    lawSummary?: SortOrder
    templateHtml?: SortOrder
    requiresNotary?: SortOrder
    requiresWitnesses?: SortOrder
    requiresMedicalCert?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StateLegalTemplateSumOrderByAggregateInput = {
    requiresWitnesses?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type EnumNotificationChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelFilter<$PrismaModel> | $Enums.NotificationChannel
  }

  export type EnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    type?: SortOrder
    channel?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    failedAt?: SortOrder
    errorMessage?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    type?: SortOrder
    channel?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    failedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    type?: SortOrder
    channel?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    failedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumNotificationChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelWithAggregatesFilter<$PrismaModel> | $Enums.NotificationChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationChannelFilter<$PrismaModel>
    _max?: NestedEnumNotificationChannelFilter<$PrismaModel>
  }

  export type EnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumPanicStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PanicStatus | EnumPanicStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PanicStatus[] | ListEnumPanicStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PanicStatus[] | ListEnumPanicStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPanicStatusFilter<$PrismaModel> | $Enums.PanicStatus
  }

  export type PanicAlertCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrder
    locationName?: SortOrder
    status?: SortOrder
    message?: SortOrder
    cancelledAt?: SortOrder
    resolvedAt?: SortOrder
    nearbyHospitals?: SortOrder
    notificationsSent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PanicAlertAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrder
  }

  export type PanicAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrder
    locationName?: SortOrder
    status?: SortOrder
    message?: SortOrder
    cancelledAt?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PanicAlertMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrder
    locationName?: SortOrder
    status?: SortOrder
    message?: SortOrder
    cancelledAt?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PanicAlertSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumPanicStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PanicStatus | EnumPanicStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PanicStatus[] | ListEnumPanicStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PanicStatus[] | ListEnumPanicStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPanicStatusWithAggregatesFilter<$PrismaModel> | $Enums.PanicStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPanicStatusFilter<$PrismaModel>
    _max?: NestedEnumPanicStatusFilter<$PrismaModel>
  }

  export type EnumAdminRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleFilter<$PrismaModel> | $Enums.AdminRole
  }

  export type AdminSessionListRelationFilter = {
    every?: AdminSessionWhereInput
    some?: AdminSessionWhereInput
    none?: AdminSessionWhereInput
  }

  export type AdminAuditLogListRelationFilter = {
    every?: AdminAuditLogWhereInput
    some?: AdminAuditLogWhereInput
    none?: AdminAuditLogWhereInput
  }

  export type AdminSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminAuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminUserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    isActive?: SortOrder
    isSuperAdmin?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    failedAttempts?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type AdminUserAvgOrderByAggregateInput = {
    failedAttempts?: SortOrder
  }

  export type AdminUserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    isSuperAdmin?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    failedAttempts?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type AdminUserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    isSuperAdmin?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    failedAttempts?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type AdminUserSumOrderByAggregateInput = {
    failedAttempts?: SortOrder
  }

  export type EnumAdminRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleWithAggregatesFilter<$PrismaModel> | $Enums.AdminRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminRoleFilter<$PrismaModel>
    _max?: NestedEnumAdminRoleFilter<$PrismaModel>
  }

  export type AdminUserRelationFilter = {
    is?: AdminUserWhereInput
    isNot?: AdminUserWhereInput
  }

  export type AdminSessionCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    refreshToken?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    refreshToken?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminSessionMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    refreshToken?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminAuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    details?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminAuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionPlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    priceMonthly?: SortOrder
    priceAnnual?: SortOrder
    currency?: SortOrder
    stripePriceIdMonthly?: SortOrder
    stripePriceIdAnnual?: SortOrder
    stripeProductId?: SortOrder
    features?: SortOrder
    limits?: SortOrder
    trialDays?: SortOrder
    isActive?: SortOrder
    isDefault?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPlanAvgOrderByAggregateInput = {
    priceMonthly?: SortOrder
    priceAnnual?: SortOrder
    trialDays?: SortOrder
    displayOrder?: SortOrder
  }

  export type SubscriptionPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    priceMonthly?: SortOrder
    priceAnnual?: SortOrder
    currency?: SortOrder
    stripePriceIdMonthly?: SortOrder
    stripePriceIdAnnual?: SortOrder
    stripeProductId?: SortOrder
    trialDays?: SortOrder
    isActive?: SortOrder
    isDefault?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    priceMonthly?: SortOrder
    priceAnnual?: SortOrder
    currency?: SortOrder
    stripePriceIdMonthly?: SortOrder
    stripePriceIdAnnual?: SortOrder
    stripeProductId?: SortOrder
    trialDays?: SortOrder
    isActive?: SortOrder
    isDefault?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPlanSumOrderByAggregateInput = {
    priceMonthly?: SortOrder
    priceAnnual?: SortOrder
    trialDays?: SortOrder
    displayOrder?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumBillingCycleFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingCycle | EnumBillingCycleFieldRefInput<$PrismaModel>
    in?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingCycleFilter<$PrismaModel> | $Enums.BillingCycle
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type SubscriptionPlanRelationFilter = {
    is?: SubscriptionPlanWhereInput
    isNot?: SubscriptionPlanWhereInput
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeCustomerId?: SortOrder
    billingCycle?: SortOrder
    status?: SortOrder
    trialEndsAt?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    cancelledAt?: SortOrder
    cancelReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeCustomerId?: SortOrder
    billingCycle?: SortOrder
    status?: SortOrder
    trialEndsAt?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    cancelledAt?: SortOrder
    cancelReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeCustomerId?: SortOrder
    billingCycle?: SortOrder
    status?: SortOrder
    trialEndsAt?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    cancelledAt?: SortOrder
    cancelReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumBillingCycleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingCycle | EnumBillingCycleFieldRefInput<$PrismaModel>
    in?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingCycleWithAggregatesFilter<$PrismaModel> | $Enums.BillingCycle
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillingCycleFilter<$PrismaModel>
    _max?: NestedEnumBillingCycleFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumPaymentMethodTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodType | EnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodType[] | ListEnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethodType[] | ListEnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodTypeFilter<$PrismaModel> | $Enums.PaymentMethodType
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type InvoiceNullableRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrder
    stripePaymentIntentId?: SortOrder
    stripeChargeId?: SortOrder
    stripeInvoiceId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    last4?: SortOrder
    cardBrand?: SortOrder
    oxxoVoucherUrl?: SortOrder
    oxxoExpiresAt?: SortOrder
    status?: SortOrder
    description?: SortOrder
    failureCode?: SortOrder
    failureMessage?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrder
    stripePaymentIntentId?: SortOrder
    stripeChargeId?: SortOrder
    stripeInvoiceId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    last4?: SortOrder
    cardBrand?: SortOrder
    oxxoVoucherUrl?: SortOrder
    oxxoExpiresAt?: SortOrder
    status?: SortOrder
    description?: SortOrder
    failureCode?: SortOrder
    failureMessage?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrder
    stripePaymentIntentId?: SortOrder
    stripeChargeId?: SortOrder
    stripeInvoiceId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    last4?: SortOrder
    cardBrand?: SortOrder
    oxxoVoucherUrl?: SortOrder
    oxxoExpiresAt?: SortOrder
    status?: SortOrder
    description?: SortOrder
    failureCode?: SortOrder
    failureMessage?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumPaymentMethodTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodType | EnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodType[] | ListEnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethodType[] | ListEnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethodType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodTypeFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type PaymentMethodCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripePaymentMethodId?: SortOrder
    type?: SortOrder
    last4?: SortOrder
    brand?: SortOrder
    expMonth?: SortOrder
    expYear?: SortOrder
    cardholderName?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodAvgOrderByAggregateInput = {
    expMonth?: SortOrder
    expYear?: SortOrder
  }

  export type PaymentMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripePaymentMethodId?: SortOrder
    type?: SortOrder
    last4?: SortOrder
    brand?: SortOrder
    expMonth?: SortOrder
    expYear?: SortOrder
    cardholderName?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripePaymentMethodId?: SortOrder
    type?: SortOrder
    last4?: SortOrder
    brand?: SortOrder
    expMonth?: SortOrder
    expYear?: SortOrder
    cardholderName?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodSumOrderByAggregateInput = {
    expMonth?: SortOrder
    expYear?: SortOrder
  }

  export type FiscalDataCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rfc?: SortOrder
    razonSocial?: SortOrder
    regimenFiscal?: SortOrder
    usoCFDI?: SortOrder
    codigoPostal?: SortOrder
    calle?: SortOrder
    numExterior?: SortOrder
    numInterior?: SortOrder
    colonia?: SortOrder
    municipio?: SortOrder
    estado?: SortOrder
    emailFacturacion?: SortOrder
    facturamaClientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FiscalDataMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rfc?: SortOrder
    razonSocial?: SortOrder
    regimenFiscal?: SortOrder
    usoCFDI?: SortOrder
    codigoPostal?: SortOrder
    calle?: SortOrder
    numExterior?: SortOrder
    numInterior?: SortOrder
    colonia?: SortOrder
    municipio?: SortOrder
    estado?: SortOrder
    emailFacturacion?: SortOrder
    facturamaClientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FiscalDataMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rfc?: SortOrder
    razonSocial?: SortOrder
    regimenFiscal?: SortOrder
    usoCFDI?: SortOrder
    codigoPostal?: SortOrder
    calle?: SortOrder
    numExterior?: SortOrder
    numInterior?: SortOrder
    colonia?: SortOrder
    municipio?: SortOrder
    estado?: SortOrder
    emailFacturacion?: SortOrder
    facturamaClientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type PaymentRelationFilter = {
    is?: PaymentWhereInput
    isNot?: PaymentWhereInput
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentId?: SortOrder
    fiscalDataId?: SortOrder
    facturamaInvoiceId?: SortOrder
    uuid?: SortOrder
    serie?: SortOrder
    folio?: SortOrder
    subtotal?: SortOrder
    iva?: SortOrder
    total?: SortOrder
    xmlUrl?: SortOrder
    pdfUrl?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrder
    cancelledAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    iva?: SortOrder
    total?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentId?: SortOrder
    fiscalDataId?: SortOrder
    facturamaInvoiceId?: SortOrder
    uuid?: SortOrder
    serie?: SortOrder
    folio?: SortOrder
    subtotal?: SortOrder
    iva?: SortOrder
    total?: SortOrder
    xmlUrl?: SortOrder
    pdfUrl?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrder
    cancelledAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentId?: SortOrder
    fiscalDataId?: SortOrder
    facturamaInvoiceId?: SortOrder
    uuid?: SortOrder
    serie?: SortOrder
    folio?: SortOrder
    subtotal?: SortOrder
    iva?: SortOrder
    total?: SortOrder
    xmlUrl?: SortOrder
    pdfUrl?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrder
    cancelledAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    subtotal?: SortOrder
    iva?: SortOrder
    total?: SortOrder
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type PatientProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<PatientProfileCreateWithoutUserInput, PatientProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PatientProfileCreateOrConnectWithoutUserInput
    connect?: PatientProfileWhereUniqueInput
  }

  export type AdvanceDirectiveCreateNestedManyWithoutUserInput = {
    create?: XOR<AdvanceDirectiveCreateWithoutUserInput, AdvanceDirectiveUncheckedCreateWithoutUserInput> | AdvanceDirectiveCreateWithoutUserInput[] | AdvanceDirectiveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdvanceDirectiveCreateOrConnectWithoutUserInput | AdvanceDirectiveCreateOrConnectWithoutUserInput[]
    createMany?: AdvanceDirectiveCreateManyUserInputEnvelope
    connect?: AdvanceDirectiveWhereUniqueInput | AdvanceDirectiveWhereUniqueInput[]
  }

  export type RepresentativeCreateNestedManyWithoutUserInput = {
    create?: XOR<RepresentativeCreateWithoutUserInput, RepresentativeUncheckedCreateWithoutUserInput> | RepresentativeCreateWithoutUserInput[] | RepresentativeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RepresentativeCreateOrConnectWithoutUserInput | RepresentativeCreateOrConnectWithoutUserInput[]
    createMany?: RepresentativeCreateManyUserInputEnvelope
    connect?: RepresentativeWhereUniqueInput | RepresentativeWhereUniqueInput[]
  }

  export type EmergencyAccessCreateNestedManyWithoutPatientInput = {
    create?: XOR<EmergencyAccessCreateWithoutPatientInput, EmergencyAccessUncheckedCreateWithoutPatientInput> | EmergencyAccessCreateWithoutPatientInput[] | EmergencyAccessUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EmergencyAccessCreateOrConnectWithoutPatientInput | EmergencyAccessCreateOrConnectWithoutPatientInput[]
    createMany?: EmergencyAccessCreateManyPatientInputEnvelope
    connect?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
  }

  export type PanicAlertCreateNestedManyWithoutUserInput = {
    create?: XOR<PanicAlertCreateWithoutUserInput, PanicAlertUncheckedCreateWithoutUserInput> | PanicAlertCreateWithoutUserInput[] | PanicAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PanicAlertCreateOrConnectWithoutUserInput | PanicAlertCreateOrConnectWithoutUserInput[]
    createMany?: PanicAlertCreateManyUserInputEnvelope
    connect?: PanicAlertWhereUniqueInput | PanicAlertWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type WebAuthnCredentialCreateNestedManyWithoutUserInput = {
    create?: XOR<WebAuthnCredentialCreateWithoutUserInput, WebAuthnCredentialUncheckedCreateWithoutUserInput> | WebAuthnCredentialCreateWithoutUserInput[] | WebAuthnCredentialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WebAuthnCredentialCreateOrConnectWithoutUserInput | WebAuthnCredentialCreateOrConnectWithoutUserInput[]
    createMany?: WebAuthnCredentialCreateManyUserInputEnvelope
    connect?: WebAuthnCredentialWhereUniqueInput | WebAuthnCredentialWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedOneWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentMethodCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentMethodCreateWithoutUserInput, PaymentMethodUncheckedCreateWithoutUserInput> | PaymentMethodCreateWithoutUserInput[] | PaymentMethodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutUserInput | PaymentMethodCreateOrConnectWithoutUserInput[]
    createMany?: PaymentMethodCreateManyUserInputEnvelope
    connect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
  }

  export type FiscalDataCreateNestedOneWithoutUserInput = {
    create?: XOR<FiscalDataCreateWithoutUserInput, FiscalDataUncheckedCreateWithoutUserInput>
    connectOrCreate?: FiscalDataCreateOrConnectWithoutUserInput
    connect?: FiscalDataWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutUserInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PatientProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PatientProfileCreateWithoutUserInput, PatientProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PatientProfileCreateOrConnectWithoutUserInput
    connect?: PatientProfileWhereUniqueInput
  }

  export type AdvanceDirectiveUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AdvanceDirectiveCreateWithoutUserInput, AdvanceDirectiveUncheckedCreateWithoutUserInput> | AdvanceDirectiveCreateWithoutUserInput[] | AdvanceDirectiveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdvanceDirectiveCreateOrConnectWithoutUserInput | AdvanceDirectiveCreateOrConnectWithoutUserInput[]
    createMany?: AdvanceDirectiveCreateManyUserInputEnvelope
    connect?: AdvanceDirectiveWhereUniqueInput | AdvanceDirectiveWhereUniqueInput[]
  }

  export type RepresentativeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RepresentativeCreateWithoutUserInput, RepresentativeUncheckedCreateWithoutUserInput> | RepresentativeCreateWithoutUserInput[] | RepresentativeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RepresentativeCreateOrConnectWithoutUserInput | RepresentativeCreateOrConnectWithoutUserInput[]
    createMany?: RepresentativeCreateManyUserInputEnvelope
    connect?: RepresentativeWhereUniqueInput | RepresentativeWhereUniqueInput[]
  }

  export type EmergencyAccessUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<EmergencyAccessCreateWithoutPatientInput, EmergencyAccessUncheckedCreateWithoutPatientInput> | EmergencyAccessCreateWithoutPatientInput[] | EmergencyAccessUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EmergencyAccessCreateOrConnectWithoutPatientInput | EmergencyAccessCreateOrConnectWithoutPatientInput[]
    createMany?: EmergencyAccessCreateManyPatientInputEnvelope
    connect?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
  }

  export type PanicAlertUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PanicAlertCreateWithoutUserInput, PanicAlertUncheckedCreateWithoutUserInput> | PanicAlertCreateWithoutUserInput[] | PanicAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PanicAlertCreateOrConnectWithoutUserInput | PanicAlertCreateOrConnectWithoutUserInput[]
    createMany?: PanicAlertCreateManyUserInputEnvelope
    connect?: PanicAlertWhereUniqueInput | PanicAlertWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WebAuthnCredentialCreateWithoutUserInput, WebAuthnCredentialUncheckedCreateWithoutUserInput> | WebAuthnCredentialCreateWithoutUserInput[] | WebAuthnCredentialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WebAuthnCredentialCreateOrConnectWithoutUserInput | WebAuthnCredentialCreateOrConnectWithoutUserInput[]
    createMany?: WebAuthnCredentialCreateManyUserInputEnvelope
    connect?: WebAuthnCredentialWhereUniqueInput | WebAuthnCredentialWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentMethodUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentMethodCreateWithoutUserInput, PaymentMethodUncheckedCreateWithoutUserInput> | PaymentMethodCreateWithoutUserInput[] | PaymentMethodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutUserInput | PaymentMethodCreateOrConnectWithoutUserInput[]
    createMany?: PaymentMethodCreateManyUserInputEnvelope
    connect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
  }

  export type FiscalDataUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<FiscalDataCreateWithoutUserInput, FiscalDataUncheckedCreateWithoutUserInput>
    connectOrCreate?: FiscalDataCreateOrConnectWithoutUserInput
    connect?: FiscalDataWhereUniqueInput
  }

  export type InvoiceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PatientProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<PatientProfileCreateWithoutUserInput, PatientProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PatientProfileCreateOrConnectWithoutUserInput
    upsert?: PatientProfileUpsertWithoutUserInput
    disconnect?: PatientProfileWhereInput | boolean
    delete?: PatientProfileWhereInput | boolean
    connect?: PatientProfileWhereUniqueInput
    update?: XOR<XOR<PatientProfileUpdateToOneWithWhereWithoutUserInput, PatientProfileUpdateWithoutUserInput>, PatientProfileUncheckedUpdateWithoutUserInput>
  }

  export type AdvanceDirectiveUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdvanceDirectiveCreateWithoutUserInput, AdvanceDirectiveUncheckedCreateWithoutUserInput> | AdvanceDirectiveCreateWithoutUserInput[] | AdvanceDirectiveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdvanceDirectiveCreateOrConnectWithoutUserInput | AdvanceDirectiveCreateOrConnectWithoutUserInput[]
    upsert?: AdvanceDirectiveUpsertWithWhereUniqueWithoutUserInput | AdvanceDirectiveUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdvanceDirectiveCreateManyUserInputEnvelope
    set?: AdvanceDirectiveWhereUniqueInput | AdvanceDirectiveWhereUniqueInput[]
    disconnect?: AdvanceDirectiveWhereUniqueInput | AdvanceDirectiveWhereUniqueInput[]
    delete?: AdvanceDirectiveWhereUniqueInput | AdvanceDirectiveWhereUniqueInput[]
    connect?: AdvanceDirectiveWhereUniqueInput | AdvanceDirectiveWhereUniqueInput[]
    update?: AdvanceDirectiveUpdateWithWhereUniqueWithoutUserInput | AdvanceDirectiveUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdvanceDirectiveUpdateManyWithWhereWithoutUserInput | AdvanceDirectiveUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdvanceDirectiveScalarWhereInput | AdvanceDirectiveScalarWhereInput[]
  }

  export type RepresentativeUpdateManyWithoutUserNestedInput = {
    create?: XOR<RepresentativeCreateWithoutUserInput, RepresentativeUncheckedCreateWithoutUserInput> | RepresentativeCreateWithoutUserInput[] | RepresentativeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RepresentativeCreateOrConnectWithoutUserInput | RepresentativeCreateOrConnectWithoutUserInput[]
    upsert?: RepresentativeUpsertWithWhereUniqueWithoutUserInput | RepresentativeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RepresentativeCreateManyUserInputEnvelope
    set?: RepresentativeWhereUniqueInput | RepresentativeWhereUniqueInput[]
    disconnect?: RepresentativeWhereUniqueInput | RepresentativeWhereUniqueInput[]
    delete?: RepresentativeWhereUniqueInput | RepresentativeWhereUniqueInput[]
    connect?: RepresentativeWhereUniqueInput | RepresentativeWhereUniqueInput[]
    update?: RepresentativeUpdateWithWhereUniqueWithoutUserInput | RepresentativeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RepresentativeUpdateManyWithWhereWithoutUserInput | RepresentativeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RepresentativeScalarWhereInput | RepresentativeScalarWhereInput[]
  }

  export type EmergencyAccessUpdateManyWithoutPatientNestedInput = {
    create?: XOR<EmergencyAccessCreateWithoutPatientInput, EmergencyAccessUncheckedCreateWithoutPatientInput> | EmergencyAccessCreateWithoutPatientInput[] | EmergencyAccessUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EmergencyAccessCreateOrConnectWithoutPatientInput | EmergencyAccessCreateOrConnectWithoutPatientInput[]
    upsert?: EmergencyAccessUpsertWithWhereUniqueWithoutPatientInput | EmergencyAccessUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: EmergencyAccessCreateManyPatientInputEnvelope
    set?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
    disconnect?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
    delete?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
    connect?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
    update?: EmergencyAccessUpdateWithWhereUniqueWithoutPatientInput | EmergencyAccessUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: EmergencyAccessUpdateManyWithWhereWithoutPatientInput | EmergencyAccessUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: EmergencyAccessScalarWhereInput | EmergencyAccessScalarWhereInput[]
  }

  export type PanicAlertUpdateManyWithoutUserNestedInput = {
    create?: XOR<PanicAlertCreateWithoutUserInput, PanicAlertUncheckedCreateWithoutUserInput> | PanicAlertCreateWithoutUserInput[] | PanicAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PanicAlertCreateOrConnectWithoutUserInput | PanicAlertCreateOrConnectWithoutUserInput[]
    upsert?: PanicAlertUpsertWithWhereUniqueWithoutUserInput | PanicAlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PanicAlertCreateManyUserInputEnvelope
    set?: PanicAlertWhereUniqueInput | PanicAlertWhereUniqueInput[]
    disconnect?: PanicAlertWhereUniqueInput | PanicAlertWhereUniqueInput[]
    delete?: PanicAlertWhereUniqueInput | PanicAlertWhereUniqueInput[]
    connect?: PanicAlertWhereUniqueInput | PanicAlertWhereUniqueInput[]
    update?: PanicAlertUpdateWithWhereUniqueWithoutUserInput | PanicAlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PanicAlertUpdateManyWithWhereWithoutUserInput | PanicAlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PanicAlertScalarWhereInput | PanicAlertScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type WebAuthnCredentialUpdateManyWithoutUserNestedInput = {
    create?: XOR<WebAuthnCredentialCreateWithoutUserInput, WebAuthnCredentialUncheckedCreateWithoutUserInput> | WebAuthnCredentialCreateWithoutUserInput[] | WebAuthnCredentialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WebAuthnCredentialCreateOrConnectWithoutUserInput | WebAuthnCredentialCreateOrConnectWithoutUserInput[]
    upsert?: WebAuthnCredentialUpsertWithWhereUniqueWithoutUserInput | WebAuthnCredentialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WebAuthnCredentialCreateManyUserInputEnvelope
    set?: WebAuthnCredentialWhereUniqueInput | WebAuthnCredentialWhereUniqueInput[]
    disconnect?: WebAuthnCredentialWhereUniqueInput | WebAuthnCredentialWhereUniqueInput[]
    delete?: WebAuthnCredentialWhereUniqueInput | WebAuthnCredentialWhereUniqueInput[]
    connect?: WebAuthnCredentialWhereUniqueInput | WebAuthnCredentialWhereUniqueInput[]
    update?: WebAuthnCredentialUpdateWithWhereUniqueWithoutUserInput | WebAuthnCredentialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WebAuthnCredentialUpdateManyWithWhereWithoutUserInput | WebAuthnCredentialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WebAuthnCredentialScalarWhereInput | WebAuthnCredentialScalarWhereInput[]
  }

  export type SubscriptionUpdateOneWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    upsert?: SubscriptionUpsertWithoutUserInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUserInput, SubscriptionUpdateWithoutUserInput>, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentMethodUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutUserInput, PaymentMethodUncheckedCreateWithoutUserInput> | PaymentMethodCreateWithoutUserInput[] | PaymentMethodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutUserInput | PaymentMethodCreateOrConnectWithoutUserInput[]
    upsert?: PaymentMethodUpsertWithWhereUniqueWithoutUserInput | PaymentMethodUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentMethodCreateManyUserInputEnvelope
    set?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    disconnect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    delete?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    connect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    update?: PaymentMethodUpdateWithWhereUniqueWithoutUserInput | PaymentMethodUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentMethodUpdateManyWithWhereWithoutUserInput | PaymentMethodUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentMethodScalarWhereInput | PaymentMethodScalarWhereInput[]
  }

  export type FiscalDataUpdateOneWithoutUserNestedInput = {
    create?: XOR<FiscalDataCreateWithoutUserInput, FiscalDataUncheckedCreateWithoutUserInput>
    connectOrCreate?: FiscalDataCreateOrConnectWithoutUserInput
    upsert?: FiscalDataUpsertWithoutUserInput
    disconnect?: FiscalDataWhereInput | boolean
    delete?: FiscalDataWhereInput | boolean
    connect?: FiscalDataWhereUniqueInput
    update?: XOR<XOR<FiscalDataUpdateToOneWithWhereWithoutUserInput, FiscalDataUpdateWithoutUserInput>, FiscalDataUncheckedUpdateWithoutUserInput>
  }

  export type InvoiceUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUserInput | InvoiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUserInput | InvoiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUserInput | InvoiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PatientProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PatientProfileCreateWithoutUserInput, PatientProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PatientProfileCreateOrConnectWithoutUserInput
    upsert?: PatientProfileUpsertWithoutUserInput
    disconnect?: PatientProfileWhereInput | boolean
    delete?: PatientProfileWhereInput | boolean
    connect?: PatientProfileWhereUniqueInput
    update?: XOR<XOR<PatientProfileUpdateToOneWithWhereWithoutUserInput, PatientProfileUpdateWithoutUserInput>, PatientProfileUncheckedUpdateWithoutUserInput>
  }

  export type AdvanceDirectiveUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdvanceDirectiveCreateWithoutUserInput, AdvanceDirectiveUncheckedCreateWithoutUserInput> | AdvanceDirectiveCreateWithoutUserInput[] | AdvanceDirectiveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdvanceDirectiveCreateOrConnectWithoutUserInput | AdvanceDirectiveCreateOrConnectWithoutUserInput[]
    upsert?: AdvanceDirectiveUpsertWithWhereUniqueWithoutUserInput | AdvanceDirectiveUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdvanceDirectiveCreateManyUserInputEnvelope
    set?: AdvanceDirectiveWhereUniqueInput | AdvanceDirectiveWhereUniqueInput[]
    disconnect?: AdvanceDirectiveWhereUniqueInput | AdvanceDirectiveWhereUniqueInput[]
    delete?: AdvanceDirectiveWhereUniqueInput | AdvanceDirectiveWhereUniqueInput[]
    connect?: AdvanceDirectiveWhereUniqueInput | AdvanceDirectiveWhereUniqueInput[]
    update?: AdvanceDirectiveUpdateWithWhereUniqueWithoutUserInput | AdvanceDirectiveUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdvanceDirectiveUpdateManyWithWhereWithoutUserInput | AdvanceDirectiveUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdvanceDirectiveScalarWhereInput | AdvanceDirectiveScalarWhereInput[]
  }

  export type RepresentativeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RepresentativeCreateWithoutUserInput, RepresentativeUncheckedCreateWithoutUserInput> | RepresentativeCreateWithoutUserInput[] | RepresentativeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RepresentativeCreateOrConnectWithoutUserInput | RepresentativeCreateOrConnectWithoutUserInput[]
    upsert?: RepresentativeUpsertWithWhereUniqueWithoutUserInput | RepresentativeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RepresentativeCreateManyUserInputEnvelope
    set?: RepresentativeWhereUniqueInput | RepresentativeWhereUniqueInput[]
    disconnect?: RepresentativeWhereUniqueInput | RepresentativeWhereUniqueInput[]
    delete?: RepresentativeWhereUniqueInput | RepresentativeWhereUniqueInput[]
    connect?: RepresentativeWhereUniqueInput | RepresentativeWhereUniqueInput[]
    update?: RepresentativeUpdateWithWhereUniqueWithoutUserInput | RepresentativeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RepresentativeUpdateManyWithWhereWithoutUserInput | RepresentativeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RepresentativeScalarWhereInput | RepresentativeScalarWhereInput[]
  }

  export type EmergencyAccessUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<EmergencyAccessCreateWithoutPatientInput, EmergencyAccessUncheckedCreateWithoutPatientInput> | EmergencyAccessCreateWithoutPatientInput[] | EmergencyAccessUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EmergencyAccessCreateOrConnectWithoutPatientInput | EmergencyAccessCreateOrConnectWithoutPatientInput[]
    upsert?: EmergencyAccessUpsertWithWhereUniqueWithoutPatientInput | EmergencyAccessUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: EmergencyAccessCreateManyPatientInputEnvelope
    set?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
    disconnect?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
    delete?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
    connect?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
    update?: EmergencyAccessUpdateWithWhereUniqueWithoutPatientInput | EmergencyAccessUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: EmergencyAccessUpdateManyWithWhereWithoutPatientInput | EmergencyAccessUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: EmergencyAccessScalarWhereInput | EmergencyAccessScalarWhereInput[]
  }

  export type PanicAlertUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PanicAlertCreateWithoutUserInput, PanicAlertUncheckedCreateWithoutUserInput> | PanicAlertCreateWithoutUserInput[] | PanicAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PanicAlertCreateOrConnectWithoutUserInput | PanicAlertCreateOrConnectWithoutUserInput[]
    upsert?: PanicAlertUpsertWithWhereUniqueWithoutUserInput | PanicAlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PanicAlertCreateManyUserInputEnvelope
    set?: PanicAlertWhereUniqueInput | PanicAlertWhereUniqueInput[]
    disconnect?: PanicAlertWhereUniqueInput | PanicAlertWhereUniqueInput[]
    delete?: PanicAlertWhereUniqueInput | PanicAlertWhereUniqueInput[]
    connect?: PanicAlertWhereUniqueInput | PanicAlertWhereUniqueInput[]
    update?: PanicAlertUpdateWithWhereUniqueWithoutUserInput | PanicAlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PanicAlertUpdateManyWithWhereWithoutUserInput | PanicAlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PanicAlertScalarWhereInput | PanicAlertScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WebAuthnCredentialCreateWithoutUserInput, WebAuthnCredentialUncheckedCreateWithoutUserInput> | WebAuthnCredentialCreateWithoutUserInput[] | WebAuthnCredentialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WebAuthnCredentialCreateOrConnectWithoutUserInput | WebAuthnCredentialCreateOrConnectWithoutUserInput[]
    upsert?: WebAuthnCredentialUpsertWithWhereUniqueWithoutUserInput | WebAuthnCredentialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WebAuthnCredentialCreateManyUserInputEnvelope
    set?: WebAuthnCredentialWhereUniqueInput | WebAuthnCredentialWhereUniqueInput[]
    disconnect?: WebAuthnCredentialWhereUniqueInput | WebAuthnCredentialWhereUniqueInput[]
    delete?: WebAuthnCredentialWhereUniqueInput | WebAuthnCredentialWhereUniqueInput[]
    connect?: WebAuthnCredentialWhereUniqueInput | WebAuthnCredentialWhereUniqueInput[]
    update?: WebAuthnCredentialUpdateWithWhereUniqueWithoutUserInput | WebAuthnCredentialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WebAuthnCredentialUpdateManyWithWhereWithoutUserInput | WebAuthnCredentialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WebAuthnCredentialScalarWhereInput | WebAuthnCredentialScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    upsert?: SubscriptionUpsertWithoutUserInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUserInput, SubscriptionUpdateWithoutUserInput>, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentMethodUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutUserInput, PaymentMethodUncheckedCreateWithoutUserInput> | PaymentMethodCreateWithoutUserInput[] | PaymentMethodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutUserInput | PaymentMethodCreateOrConnectWithoutUserInput[]
    upsert?: PaymentMethodUpsertWithWhereUniqueWithoutUserInput | PaymentMethodUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentMethodCreateManyUserInputEnvelope
    set?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    disconnect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    delete?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    connect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    update?: PaymentMethodUpdateWithWhereUniqueWithoutUserInput | PaymentMethodUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentMethodUpdateManyWithWhereWithoutUserInput | PaymentMethodUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentMethodScalarWhereInput | PaymentMethodScalarWhereInput[]
  }

  export type FiscalDataUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<FiscalDataCreateWithoutUserInput, FiscalDataUncheckedCreateWithoutUserInput>
    connectOrCreate?: FiscalDataCreateOrConnectWithoutUserInput
    upsert?: FiscalDataUpsertWithoutUserInput
    disconnect?: FiscalDataWhereInput | boolean
    delete?: FiscalDataWhereInput | boolean
    connect?: FiscalDataWhereUniqueInput
    update?: XOR<XOR<FiscalDataUpdateToOneWithWhereWithoutUserInput, FiscalDataUpdateWithoutUserInput>, FiscalDataUncheckedUpdateWithoutUserInput>
  }

  export type InvoiceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUserInput | InvoiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUserInput | InvoiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUserInput | InvoiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type WebAuthnCredentialCreatetransportsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutWebauthnCredentialsInput = {
    create?: XOR<UserCreateWithoutWebauthnCredentialsInput, UserUncheckedCreateWithoutWebauthnCredentialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWebauthnCredentialsInput
    connect?: UserWhereUniqueInput
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type WebAuthnCredentialUpdatetransportsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutWebauthnCredentialsNestedInput = {
    create?: XOR<UserCreateWithoutWebauthnCredentialsInput, UserUncheckedCreateWithoutWebauthnCredentialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWebauthnCredentialsInput
    upsert?: UserUpsertWithoutWebauthnCredentialsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWebauthnCredentialsInput, UserUpdateWithoutWebauthnCredentialsInput>, UserUncheckedUpdateWithoutWebauthnCredentialsInput>
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserCreateNestedOneWithoutRepresentativesInput = {
    create?: XOR<UserCreateWithoutRepresentativesInput, UserUncheckedCreateWithoutRepresentativesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRepresentativesInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutRepresentativesNestedInput = {
    create?: XOR<UserCreateWithoutRepresentativesInput, UserUncheckedCreateWithoutRepresentativesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRepresentativesInput
    upsert?: UserUpsertWithoutRepresentativesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRepresentativesInput, UserUpdateWithoutRepresentativesInput>, UserUncheckedUpdateWithoutRepresentativesInput>
  }

  export type UserCreateNestedOneWithoutDirectivesInput = {
    create?: XOR<UserCreateWithoutDirectivesInput, UserUncheckedCreateWithoutDirectivesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDirectivesInput
    connect?: UserWhereUniqueInput
  }

  export type WitnessCreateNestedManyWithoutDirectiveInput = {
    create?: XOR<WitnessCreateWithoutDirectiveInput, WitnessUncheckedCreateWithoutDirectiveInput> | WitnessCreateWithoutDirectiveInput[] | WitnessUncheckedCreateWithoutDirectiveInput[]
    connectOrCreate?: WitnessCreateOrConnectWithoutDirectiveInput | WitnessCreateOrConnectWithoutDirectiveInput[]
    createMany?: WitnessCreateManyDirectiveInputEnvelope
    connect?: WitnessWhereUniqueInput | WitnessWhereUniqueInput[]
  }

  export type WitnessUncheckedCreateNestedManyWithoutDirectiveInput = {
    create?: XOR<WitnessCreateWithoutDirectiveInput, WitnessUncheckedCreateWithoutDirectiveInput> | WitnessCreateWithoutDirectiveInput[] | WitnessUncheckedCreateWithoutDirectiveInput[]
    connectOrCreate?: WitnessCreateOrConnectWithoutDirectiveInput | WitnessCreateOrConnectWithoutDirectiveInput[]
    createMany?: WitnessCreateManyDirectiveInputEnvelope
    connect?: WitnessWhereUniqueInput | WitnessWhereUniqueInput[]
  }

  export type EnumDirectiveTypeFieldUpdateOperationsInput = {
    set?: $Enums.DirectiveType
  }

  export type EnumDirectiveStatusFieldUpdateOperationsInput = {
    set?: $Enums.DirectiveStatus
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserUpdateOneRequiredWithoutDirectivesNestedInput = {
    create?: XOR<UserCreateWithoutDirectivesInput, UserUncheckedCreateWithoutDirectivesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDirectivesInput
    upsert?: UserUpsertWithoutDirectivesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDirectivesInput, UserUpdateWithoutDirectivesInput>, UserUncheckedUpdateWithoutDirectivesInput>
  }

  export type WitnessUpdateManyWithoutDirectiveNestedInput = {
    create?: XOR<WitnessCreateWithoutDirectiveInput, WitnessUncheckedCreateWithoutDirectiveInput> | WitnessCreateWithoutDirectiveInput[] | WitnessUncheckedCreateWithoutDirectiveInput[]
    connectOrCreate?: WitnessCreateOrConnectWithoutDirectiveInput | WitnessCreateOrConnectWithoutDirectiveInput[]
    upsert?: WitnessUpsertWithWhereUniqueWithoutDirectiveInput | WitnessUpsertWithWhereUniqueWithoutDirectiveInput[]
    createMany?: WitnessCreateManyDirectiveInputEnvelope
    set?: WitnessWhereUniqueInput | WitnessWhereUniqueInput[]
    disconnect?: WitnessWhereUniqueInput | WitnessWhereUniqueInput[]
    delete?: WitnessWhereUniqueInput | WitnessWhereUniqueInput[]
    connect?: WitnessWhereUniqueInput | WitnessWhereUniqueInput[]
    update?: WitnessUpdateWithWhereUniqueWithoutDirectiveInput | WitnessUpdateWithWhereUniqueWithoutDirectiveInput[]
    updateMany?: WitnessUpdateManyWithWhereWithoutDirectiveInput | WitnessUpdateManyWithWhereWithoutDirectiveInput[]
    deleteMany?: WitnessScalarWhereInput | WitnessScalarWhereInput[]
  }

  export type WitnessUncheckedUpdateManyWithoutDirectiveNestedInput = {
    create?: XOR<WitnessCreateWithoutDirectiveInput, WitnessUncheckedCreateWithoutDirectiveInput> | WitnessCreateWithoutDirectiveInput[] | WitnessUncheckedCreateWithoutDirectiveInput[]
    connectOrCreate?: WitnessCreateOrConnectWithoutDirectiveInput | WitnessCreateOrConnectWithoutDirectiveInput[]
    upsert?: WitnessUpsertWithWhereUniqueWithoutDirectiveInput | WitnessUpsertWithWhereUniqueWithoutDirectiveInput[]
    createMany?: WitnessCreateManyDirectiveInputEnvelope
    set?: WitnessWhereUniqueInput | WitnessWhereUniqueInput[]
    disconnect?: WitnessWhereUniqueInput | WitnessWhereUniqueInput[]
    delete?: WitnessWhereUniqueInput | WitnessWhereUniqueInput[]
    connect?: WitnessWhereUniqueInput | WitnessWhereUniqueInput[]
    update?: WitnessUpdateWithWhereUniqueWithoutDirectiveInput | WitnessUpdateWithWhereUniqueWithoutDirectiveInput[]
    updateMany?: WitnessUpdateManyWithWhereWithoutDirectiveInput | WitnessUpdateManyWithWhereWithoutDirectiveInput[]
    deleteMany?: WitnessScalarWhereInput | WitnessScalarWhereInput[]
  }

  export type AdvanceDirectiveCreateNestedOneWithoutWitnessesInput = {
    create?: XOR<AdvanceDirectiveCreateWithoutWitnessesInput, AdvanceDirectiveUncheckedCreateWithoutWitnessesInput>
    connectOrCreate?: AdvanceDirectiveCreateOrConnectWithoutWitnessesInput
    connect?: AdvanceDirectiveWhereUniqueInput
  }

  export type AdvanceDirectiveUpdateOneRequiredWithoutWitnessesNestedInput = {
    create?: XOR<AdvanceDirectiveCreateWithoutWitnessesInput, AdvanceDirectiveUncheckedCreateWithoutWitnessesInput>
    connectOrCreate?: AdvanceDirectiveCreateOrConnectWithoutWitnessesInput
    upsert?: AdvanceDirectiveUpsertWithoutWitnessesInput
    connect?: AdvanceDirectiveWhereUniqueInput
    update?: XOR<XOR<AdvanceDirectiveUpdateToOneWithWhereWithoutWitnessesInput, AdvanceDirectiveUpdateWithoutWitnessesInput>, AdvanceDirectiveUncheckedUpdateWithoutWitnessesInput>
  }

  export type EmergencyAccessCreatedataAccessedInput = {
    set: string[]
  }

  export type EmergencyAccessCreaterepresentativesNotifiedInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutEmergencyAccessesInput = {
    create?: XOR<UserCreateWithoutEmergencyAccessesInput, UserUncheckedCreateWithoutEmergencyAccessesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmergencyAccessesInput
    connect?: UserWhereUniqueInput
  }

  export type MedicalInstitutionCreateNestedOneWithoutEmergencyAccessesInput = {
    create?: XOR<MedicalInstitutionCreateWithoutEmergencyAccessesInput, MedicalInstitutionUncheckedCreateWithoutEmergencyAccessesInput>
    connectOrCreate?: MedicalInstitutionCreateOrConnectWithoutEmergencyAccessesInput
    connect?: MedicalInstitutionWhereUniqueInput
  }

  export type InsuranceCompanyCreateNestedOneWithoutEmergencyAccessesInput = {
    create?: XOR<InsuranceCompanyCreateWithoutEmergencyAccessesInput, InsuranceCompanyUncheckedCreateWithoutEmergencyAccessesInput>
    connectOrCreate?: InsuranceCompanyCreateOrConnectWithoutEmergencyAccessesInput
    connect?: InsuranceCompanyWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EmergencyAccessUpdatedataAccessedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmergencyAccessUpdaterepresentativesNotifiedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutEmergencyAccessesNestedInput = {
    create?: XOR<UserCreateWithoutEmergencyAccessesInput, UserUncheckedCreateWithoutEmergencyAccessesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmergencyAccessesInput
    upsert?: UserUpsertWithoutEmergencyAccessesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmergencyAccessesInput, UserUpdateWithoutEmergencyAccessesInput>, UserUncheckedUpdateWithoutEmergencyAccessesInput>
  }

  export type MedicalInstitutionUpdateOneWithoutEmergencyAccessesNestedInput = {
    create?: XOR<MedicalInstitutionCreateWithoutEmergencyAccessesInput, MedicalInstitutionUncheckedCreateWithoutEmergencyAccessesInput>
    connectOrCreate?: MedicalInstitutionCreateOrConnectWithoutEmergencyAccessesInput
    upsert?: MedicalInstitutionUpsertWithoutEmergencyAccessesInput
    disconnect?: MedicalInstitutionWhereInput | boolean
    delete?: MedicalInstitutionWhereInput | boolean
    connect?: MedicalInstitutionWhereUniqueInput
    update?: XOR<XOR<MedicalInstitutionUpdateToOneWithWhereWithoutEmergencyAccessesInput, MedicalInstitutionUpdateWithoutEmergencyAccessesInput>, MedicalInstitutionUncheckedUpdateWithoutEmergencyAccessesInput>
  }

  export type InsuranceCompanyUpdateOneWithoutEmergencyAccessesNestedInput = {
    create?: XOR<InsuranceCompanyCreateWithoutEmergencyAccessesInput, InsuranceCompanyUncheckedCreateWithoutEmergencyAccessesInput>
    connectOrCreate?: InsuranceCompanyCreateOrConnectWithoutEmergencyAccessesInput
    upsert?: InsuranceCompanyUpsertWithoutEmergencyAccessesInput
    disconnect?: InsuranceCompanyWhereInput | boolean
    delete?: InsuranceCompanyWhereInput | boolean
    connect?: InsuranceCompanyWhereUniqueInput
    update?: XOR<XOR<InsuranceCompanyUpdateToOneWithWhereWithoutEmergencyAccessesInput, InsuranceCompanyUpdateWithoutEmergencyAccessesInput>, InsuranceCompanyUncheckedUpdateWithoutEmergencyAccessesInput>
  }

  export type MedicalInstitutionCreatespecialtiesInput = {
    set: string[]
  }

  export type EmergencyAccessCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<EmergencyAccessCreateWithoutInstitutionInput, EmergencyAccessUncheckedCreateWithoutInstitutionInput> | EmergencyAccessCreateWithoutInstitutionInput[] | EmergencyAccessUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: EmergencyAccessCreateOrConnectWithoutInstitutionInput | EmergencyAccessCreateOrConnectWithoutInstitutionInput[]
    createMany?: EmergencyAccessCreateManyInstitutionInputEnvelope
    connect?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
  }

  export type MedicalStaffCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<MedicalStaffCreateWithoutInstitutionInput, MedicalStaffUncheckedCreateWithoutInstitutionInput> | MedicalStaffCreateWithoutInstitutionInput[] | MedicalStaffUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: MedicalStaffCreateOrConnectWithoutInstitutionInput | MedicalStaffCreateOrConnectWithoutInstitutionInput[]
    createMany?: MedicalStaffCreateManyInstitutionInputEnvelope
    connect?: MedicalStaffWhereUniqueInput | MedicalStaffWhereUniqueInput[]
  }

  export type InsuranceCompanyCreateNestedManyWithoutNetworkHospitalsInput = {
    create?: XOR<InsuranceCompanyCreateWithoutNetworkHospitalsInput, InsuranceCompanyUncheckedCreateWithoutNetworkHospitalsInput> | InsuranceCompanyCreateWithoutNetworkHospitalsInput[] | InsuranceCompanyUncheckedCreateWithoutNetworkHospitalsInput[]
    connectOrCreate?: InsuranceCompanyCreateOrConnectWithoutNetworkHospitalsInput | InsuranceCompanyCreateOrConnectWithoutNetworkHospitalsInput[]
    connect?: InsuranceCompanyWhereUniqueInput | InsuranceCompanyWhereUniqueInput[]
  }

  export type EmergencyAccessUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<EmergencyAccessCreateWithoutInstitutionInput, EmergencyAccessUncheckedCreateWithoutInstitutionInput> | EmergencyAccessCreateWithoutInstitutionInput[] | EmergencyAccessUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: EmergencyAccessCreateOrConnectWithoutInstitutionInput | EmergencyAccessCreateOrConnectWithoutInstitutionInput[]
    createMany?: EmergencyAccessCreateManyInstitutionInputEnvelope
    connect?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
  }

  export type MedicalStaffUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<MedicalStaffCreateWithoutInstitutionInput, MedicalStaffUncheckedCreateWithoutInstitutionInput> | MedicalStaffCreateWithoutInstitutionInput[] | MedicalStaffUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: MedicalStaffCreateOrConnectWithoutInstitutionInput | MedicalStaffCreateOrConnectWithoutInstitutionInput[]
    createMany?: MedicalStaffCreateManyInstitutionInputEnvelope
    connect?: MedicalStaffWhereUniqueInput | MedicalStaffWhereUniqueInput[]
  }

  export type InsuranceCompanyUncheckedCreateNestedManyWithoutNetworkHospitalsInput = {
    create?: XOR<InsuranceCompanyCreateWithoutNetworkHospitalsInput, InsuranceCompanyUncheckedCreateWithoutNetworkHospitalsInput> | InsuranceCompanyCreateWithoutNetworkHospitalsInput[] | InsuranceCompanyUncheckedCreateWithoutNetworkHospitalsInput[]
    connectOrCreate?: InsuranceCompanyCreateOrConnectWithoutNetworkHospitalsInput | InsuranceCompanyCreateOrConnectWithoutNetworkHospitalsInput[]
    connect?: InsuranceCompanyWhereUniqueInput | InsuranceCompanyWhereUniqueInput[]
  }

  export type EnumInstitutionTypeFieldUpdateOperationsInput = {
    set?: $Enums.InstitutionType
  }

  export type NullableEnumAttentionLevelFieldUpdateOperationsInput = {
    set?: $Enums.AttentionLevel | null
  }

  export type MedicalInstitutionUpdatespecialtiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmergencyAccessUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<EmergencyAccessCreateWithoutInstitutionInput, EmergencyAccessUncheckedCreateWithoutInstitutionInput> | EmergencyAccessCreateWithoutInstitutionInput[] | EmergencyAccessUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: EmergencyAccessCreateOrConnectWithoutInstitutionInput | EmergencyAccessCreateOrConnectWithoutInstitutionInput[]
    upsert?: EmergencyAccessUpsertWithWhereUniqueWithoutInstitutionInput | EmergencyAccessUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: EmergencyAccessCreateManyInstitutionInputEnvelope
    set?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
    disconnect?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
    delete?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
    connect?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
    update?: EmergencyAccessUpdateWithWhereUniqueWithoutInstitutionInput | EmergencyAccessUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: EmergencyAccessUpdateManyWithWhereWithoutInstitutionInput | EmergencyAccessUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: EmergencyAccessScalarWhereInput | EmergencyAccessScalarWhereInput[]
  }

  export type MedicalStaffUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<MedicalStaffCreateWithoutInstitutionInput, MedicalStaffUncheckedCreateWithoutInstitutionInput> | MedicalStaffCreateWithoutInstitutionInput[] | MedicalStaffUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: MedicalStaffCreateOrConnectWithoutInstitutionInput | MedicalStaffCreateOrConnectWithoutInstitutionInput[]
    upsert?: MedicalStaffUpsertWithWhereUniqueWithoutInstitutionInput | MedicalStaffUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: MedicalStaffCreateManyInstitutionInputEnvelope
    set?: MedicalStaffWhereUniqueInput | MedicalStaffWhereUniqueInput[]
    disconnect?: MedicalStaffWhereUniqueInput | MedicalStaffWhereUniqueInput[]
    delete?: MedicalStaffWhereUniqueInput | MedicalStaffWhereUniqueInput[]
    connect?: MedicalStaffWhereUniqueInput | MedicalStaffWhereUniqueInput[]
    update?: MedicalStaffUpdateWithWhereUniqueWithoutInstitutionInput | MedicalStaffUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: MedicalStaffUpdateManyWithWhereWithoutInstitutionInput | MedicalStaffUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: MedicalStaffScalarWhereInput | MedicalStaffScalarWhereInput[]
  }

  export type InsuranceCompanyUpdateManyWithoutNetworkHospitalsNestedInput = {
    create?: XOR<InsuranceCompanyCreateWithoutNetworkHospitalsInput, InsuranceCompanyUncheckedCreateWithoutNetworkHospitalsInput> | InsuranceCompanyCreateWithoutNetworkHospitalsInput[] | InsuranceCompanyUncheckedCreateWithoutNetworkHospitalsInput[]
    connectOrCreate?: InsuranceCompanyCreateOrConnectWithoutNetworkHospitalsInput | InsuranceCompanyCreateOrConnectWithoutNetworkHospitalsInput[]
    upsert?: InsuranceCompanyUpsertWithWhereUniqueWithoutNetworkHospitalsInput | InsuranceCompanyUpsertWithWhereUniqueWithoutNetworkHospitalsInput[]
    set?: InsuranceCompanyWhereUniqueInput | InsuranceCompanyWhereUniqueInput[]
    disconnect?: InsuranceCompanyWhereUniqueInput | InsuranceCompanyWhereUniqueInput[]
    delete?: InsuranceCompanyWhereUniqueInput | InsuranceCompanyWhereUniqueInput[]
    connect?: InsuranceCompanyWhereUniqueInput | InsuranceCompanyWhereUniqueInput[]
    update?: InsuranceCompanyUpdateWithWhereUniqueWithoutNetworkHospitalsInput | InsuranceCompanyUpdateWithWhereUniqueWithoutNetworkHospitalsInput[]
    updateMany?: InsuranceCompanyUpdateManyWithWhereWithoutNetworkHospitalsInput | InsuranceCompanyUpdateManyWithWhereWithoutNetworkHospitalsInput[]
    deleteMany?: InsuranceCompanyScalarWhereInput | InsuranceCompanyScalarWhereInput[]
  }

  export type EmergencyAccessUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<EmergencyAccessCreateWithoutInstitutionInput, EmergencyAccessUncheckedCreateWithoutInstitutionInput> | EmergencyAccessCreateWithoutInstitutionInput[] | EmergencyAccessUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: EmergencyAccessCreateOrConnectWithoutInstitutionInput | EmergencyAccessCreateOrConnectWithoutInstitutionInput[]
    upsert?: EmergencyAccessUpsertWithWhereUniqueWithoutInstitutionInput | EmergencyAccessUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: EmergencyAccessCreateManyInstitutionInputEnvelope
    set?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
    disconnect?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
    delete?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
    connect?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
    update?: EmergencyAccessUpdateWithWhereUniqueWithoutInstitutionInput | EmergencyAccessUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: EmergencyAccessUpdateManyWithWhereWithoutInstitutionInput | EmergencyAccessUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: EmergencyAccessScalarWhereInput | EmergencyAccessScalarWhereInput[]
  }

  export type MedicalStaffUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<MedicalStaffCreateWithoutInstitutionInput, MedicalStaffUncheckedCreateWithoutInstitutionInput> | MedicalStaffCreateWithoutInstitutionInput[] | MedicalStaffUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: MedicalStaffCreateOrConnectWithoutInstitutionInput | MedicalStaffCreateOrConnectWithoutInstitutionInput[]
    upsert?: MedicalStaffUpsertWithWhereUniqueWithoutInstitutionInput | MedicalStaffUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: MedicalStaffCreateManyInstitutionInputEnvelope
    set?: MedicalStaffWhereUniqueInput | MedicalStaffWhereUniqueInput[]
    disconnect?: MedicalStaffWhereUniqueInput | MedicalStaffWhereUniqueInput[]
    delete?: MedicalStaffWhereUniqueInput | MedicalStaffWhereUniqueInput[]
    connect?: MedicalStaffWhereUniqueInput | MedicalStaffWhereUniqueInput[]
    update?: MedicalStaffUpdateWithWhereUniqueWithoutInstitutionInput | MedicalStaffUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: MedicalStaffUpdateManyWithWhereWithoutInstitutionInput | MedicalStaffUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: MedicalStaffScalarWhereInput | MedicalStaffScalarWhereInput[]
  }

  export type InsuranceCompanyUncheckedUpdateManyWithoutNetworkHospitalsNestedInput = {
    create?: XOR<InsuranceCompanyCreateWithoutNetworkHospitalsInput, InsuranceCompanyUncheckedCreateWithoutNetworkHospitalsInput> | InsuranceCompanyCreateWithoutNetworkHospitalsInput[] | InsuranceCompanyUncheckedCreateWithoutNetworkHospitalsInput[]
    connectOrCreate?: InsuranceCompanyCreateOrConnectWithoutNetworkHospitalsInput | InsuranceCompanyCreateOrConnectWithoutNetworkHospitalsInput[]
    upsert?: InsuranceCompanyUpsertWithWhereUniqueWithoutNetworkHospitalsInput | InsuranceCompanyUpsertWithWhereUniqueWithoutNetworkHospitalsInput[]
    set?: InsuranceCompanyWhereUniqueInput | InsuranceCompanyWhereUniqueInput[]
    disconnect?: InsuranceCompanyWhereUniqueInput | InsuranceCompanyWhereUniqueInput[]
    delete?: InsuranceCompanyWhereUniqueInput | InsuranceCompanyWhereUniqueInput[]
    connect?: InsuranceCompanyWhereUniqueInput | InsuranceCompanyWhereUniqueInput[]
    update?: InsuranceCompanyUpdateWithWhereUniqueWithoutNetworkHospitalsInput | InsuranceCompanyUpdateWithWhereUniqueWithoutNetworkHospitalsInput[]
    updateMany?: InsuranceCompanyUpdateManyWithWhereWithoutNetworkHospitalsInput | InsuranceCompanyUpdateManyWithWhereWithoutNetworkHospitalsInput[]
    deleteMany?: InsuranceCompanyScalarWhereInput | InsuranceCompanyScalarWhereInput[]
  }

  export type InsuranceCompanyCreatecoverageTypesInput = {
    set: string[]
  }

  export type InsuranceCompanyCreatestatesCoveredInput = {
    set: string[]
  }

  export type InsurancePlanCreateNestedManyWithoutInsuranceInput = {
    create?: XOR<InsurancePlanCreateWithoutInsuranceInput, InsurancePlanUncheckedCreateWithoutInsuranceInput> | InsurancePlanCreateWithoutInsuranceInput[] | InsurancePlanUncheckedCreateWithoutInsuranceInput[]
    connectOrCreate?: InsurancePlanCreateOrConnectWithoutInsuranceInput | InsurancePlanCreateOrConnectWithoutInsuranceInput[]
    createMany?: InsurancePlanCreateManyInsuranceInputEnvelope
    connect?: InsurancePlanWhereUniqueInput | InsurancePlanWhereUniqueInput[]
  }

  export type MedicalInstitutionCreateNestedManyWithoutInsuranceNetworksInput = {
    create?: XOR<MedicalInstitutionCreateWithoutInsuranceNetworksInput, MedicalInstitutionUncheckedCreateWithoutInsuranceNetworksInput> | MedicalInstitutionCreateWithoutInsuranceNetworksInput[] | MedicalInstitutionUncheckedCreateWithoutInsuranceNetworksInput[]
    connectOrCreate?: MedicalInstitutionCreateOrConnectWithoutInsuranceNetworksInput | MedicalInstitutionCreateOrConnectWithoutInsuranceNetworksInput[]
    connect?: MedicalInstitutionWhereUniqueInput | MedicalInstitutionWhereUniqueInput[]
  }

  export type EmergencyAccessCreateNestedManyWithoutInsuranceInput = {
    create?: XOR<EmergencyAccessCreateWithoutInsuranceInput, EmergencyAccessUncheckedCreateWithoutInsuranceInput> | EmergencyAccessCreateWithoutInsuranceInput[] | EmergencyAccessUncheckedCreateWithoutInsuranceInput[]
    connectOrCreate?: EmergencyAccessCreateOrConnectWithoutInsuranceInput | EmergencyAccessCreateOrConnectWithoutInsuranceInput[]
    createMany?: EmergencyAccessCreateManyInsuranceInputEnvelope
    connect?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
  }

  export type InsurancePlanUncheckedCreateNestedManyWithoutInsuranceInput = {
    create?: XOR<InsurancePlanCreateWithoutInsuranceInput, InsurancePlanUncheckedCreateWithoutInsuranceInput> | InsurancePlanCreateWithoutInsuranceInput[] | InsurancePlanUncheckedCreateWithoutInsuranceInput[]
    connectOrCreate?: InsurancePlanCreateOrConnectWithoutInsuranceInput | InsurancePlanCreateOrConnectWithoutInsuranceInput[]
    createMany?: InsurancePlanCreateManyInsuranceInputEnvelope
    connect?: InsurancePlanWhereUniqueInput | InsurancePlanWhereUniqueInput[]
  }

  export type MedicalInstitutionUncheckedCreateNestedManyWithoutInsuranceNetworksInput = {
    create?: XOR<MedicalInstitutionCreateWithoutInsuranceNetworksInput, MedicalInstitutionUncheckedCreateWithoutInsuranceNetworksInput> | MedicalInstitutionCreateWithoutInsuranceNetworksInput[] | MedicalInstitutionUncheckedCreateWithoutInsuranceNetworksInput[]
    connectOrCreate?: MedicalInstitutionCreateOrConnectWithoutInsuranceNetworksInput | MedicalInstitutionCreateOrConnectWithoutInsuranceNetworksInput[]
    connect?: MedicalInstitutionWhereUniqueInput | MedicalInstitutionWhereUniqueInput[]
  }

  export type EmergencyAccessUncheckedCreateNestedManyWithoutInsuranceInput = {
    create?: XOR<EmergencyAccessCreateWithoutInsuranceInput, EmergencyAccessUncheckedCreateWithoutInsuranceInput> | EmergencyAccessCreateWithoutInsuranceInput[] | EmergencyAccessUncheckedCreateWithoutInsuranceInput[]
    connectOrCreate?: EmergencyAccessCreateOrConnectWithoutInsuranceInput | EmergencyAccessCreateOrConnectWithoutInsuranceInput[]
    createMany?: EmergencyAccessCreateManyInsuranceInputEnvelope
    connect?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
  }

  export type EnumInsuranceTypeFieldUpdateOperationsInput = {
    set?: $Enums.InsuranceType
  }

  export type InsuranceCompanyUpdatecoverageTypesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InsuranceCompanyUpdatestatesCoveredInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InsurancePlanUpdateManyWithoutInsuranceNestedInput = {
    create?: XOR<InsurancePlanCreateWithoutInsuranceInput, InsurancePlanUncheckedCreateWithoutInsuranceInput> | InsurancePlanCreateWithoutInsuranceInput[] | InsurancePlanUncheckedCreateWithoutInsuranceInput[]
    connectOrCreate?: InsurancePlanCreateOrConnectWithoutInsuranceInput | InsurancePlanCreateOrConnectWithoutInsuranceInput[]
    upsert?: InsurancePlanUpsertWithWhereUniqueWithoutInsuranceInput | InsurancePlanUpsertWithWhereUniqueWithoutInsuranceInput[]
    createMany?: InsurancePlanCreateManyInsuranceInputEnvelope
    set?: InsurancePlanWhereUniqueInput | InsurancePlanWhereUniqueInput[]
    disconnect?: InsurancePlanWhereUniqueInput | InsurancePlanWhereUniqueInput[]
    delete?: InsurancePlanWhereUniqueInput | InsurancePlanWhereUniqueInput[]
    connect?: InsurancePlanWhereUniqueInput | InsurancePlanWhereUniqueInput[]
    update?: InsurancePlanUpdateWithWhereUniqueWithoutInsuranceInput | InsurancePlanUpdateWithWhereUniqueWithoutInsuranceInput[]
    updateMany?: InsurancePlanUpdateManyWithWhereWithoutInsuranceInput | InsurancePlanUpdateManyWithWhereWithoutInsuranceInput[]
    deleteMany?: InsurancePlanScalarWhereInput | InsurancePlanScalarWhereInput[]
  }

  export type MedicalInstitutionUpdateManyWithoutInsuranceNetworksNestedInput = {
    create?: XOR<MedicalInstitutionCreateWithoutInsuranceNetworksInput, MedicalInstitutionUncheckedCreateWithoutInsuranceNetworksInput> | MedicalInstitutionCreateWithoutInsuranceNetworksInput[] | MedicalInstitutionUncheckedCreateWithoutInsuranceNetworksInput[]
    connectOrCreate?: MedicalInstitutionCreateOrConnectWithoutInsuranceNetworksInput | MedicalInstitutionCreateOrConnectWithoutInsuranceNetworksInput[]
    upsert?: MedicalInstitutionUpsertWithWhereUniqueWithoutInsuranceNetworksInput | MedicalInstitutionUpsertWithWhereUniqueWithoutInsuranceNetworksInput[]
    set?: MedicalInstitutionWhereUniqueInput | MedicalInstitutionWhereUniqueInput[]
    disconnect?: MedicalInstitutionWhereUniqueInput | MedicalInstitutionWhereUniqueInput[]
    delete?: MedicalInstitutionWhereUniqueInput | MedicalInstitutionWhereUniqueInput[]
    connect?: MedicalInstitutionWhereUniqueInput | MedicalInstitutionWhereUniqueInput[]
    update?: MedicalInstitutionUpdateWithWhereUniqueWithoutInsuranceNetworksInput | MedicalInstitutionUpdateWithWhereUniqueWithoutInsuranceNetworksInput[]
    updateMany?: MedicalInstitutionUpdateManyWithWhereWithoutInsuranceNetworksInput | MedicalInstitutionUpdateManyWithWhereWithoutInsuranceNetworksInput[]
    deleteMany?: MedicalInstitutionScalarWhereInput | MedicalInstitutionScalarWhereInput[]
  }

  export type EmergencyAccessUpdateManyWithoutInsuranceNestedInput = {
    create?: XOR<EmergencyAccessCreateWithoutInsuranceInput, EmergencyAccessUncheckedCreateWithoutInsuranceInput> | EmergencyAccessCreateWithoutInsuranceInput[] | EmergencyAccessUncheckedCreateWithoutInsuranceInput[]
    connectOrCreate?: EmergencyAccessCreateOrConnectWithoutInsuranceInput | EmergencyAccessCreateOrConnectWithoutInsuranceInput[]
    upsert?: EmergencyAccessUpsertWithWhereUniqueWithoutInsuranceInput | EmergencyAccessUpsertWithWhereUniqueWithoutInsuranceInput[]
    createMany?: EmergencyAccessCreateManyInsuranceInputEnvelope
    set?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
    disconnect?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
    delete?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
    connect?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
    update?: EmergencyAccessUpdateWithWhereUniqueWithoutInsuranceInput | EmergencyAccessUpdateWithWhereUniqueWithoutInsuranceInput[]
    updateMany?: EmergencyAccessUpdateManyWithWhereWithoutInsuranceInput | EmergencyAccessUpdateManyWithWhereWithoutInsuranceInput[]
    deleteMany?: EmergencyAccessScalarWhereInput | EmergencyAccessScalarWhereInput[]
  }

  export type InsurancePlanUncheckedUpdateManyWithoutInsuranceNestedInput = {
    create?: XOR<InsurancePlanCreateWithoutInsuranceInput, InsurancePlanUncheckedCreateWithoutInsuranceInput> | InsurancePlanCreateWithoutInsuranceInput[] | InsurancePlanUncheckedCreateWithoutInsuranceInput[]
    connectOrCreate?: InsurancePlanCreateOrConnectWithoutInsuranceInput | InsurancePlanCreateOrConnectWithoutInsuranceInput[]
    upsert?: InsurancePlanUpsertWithWhereUniqueWithoutInsuranceInput | InsurancePlanUpsertWithWhereUniqueWithoutInsuranceInput[]
    createMany?: InsurancePlanCreateManyInsuranceInputEnvelope
    set?: InsurancePlanWhereUniqueInput | InsurancePlanWhereUniqueInput[]
    disconnect?: InsurancePlanWhereUniqueInput | InsurancePlanWhereUniqueInput[]
    delete?: InsurancePlanWhereUniqueInput | InsurancePlanWhereUniqueInput[]
    connect?: InsurancePlanWhereUniqueInput | InsurancePlanWhereUniqueInput[]
    update?: InsurancePlanUpdateWithWhereUniqueWithoutInsuranceInput | InsurancePlanUpdateWithWhereUniqueWithoutInsuranceInput[]
    updateMany?: InsurancePlanUpdateManyWithWhereWithoutInsuranceInput | InsurancePlanUpdateManyWithWhereWithoutInsuranceInput[]
    deleteMany?: InsurancePlanScalarWhereInput | InsurancePlanScalarWhereInput[]
  }

  export type MedicalInstitutionUncheckedUpdateManyWithoutInsuranceNetworksNestedInput = {
    create?: XOR<MedicalInstitutionCreateWithoutInsuranceNetworksInput, MedicalInstitutionUncheckedCreateWithoutInsuranceNetworksInput> | MedicalInstitutionCreateWithoutInsuranceNetworksInput[] | MedicalInstitutionUncheckedCreateWithoutInsuranceNetworksInput[]
    connectOrCreate?: MedicalInstitutionCreateOrConnectWithoutInsuranceNetworksInput | MedicalInstitutionCreateOrConnectWithoutInsuranceNetworksInput[]
    upsert?: MedicalInstitutionUpsertWithWhereUniqueWithoutInsuranceNetworksInput | MedicalInstitutionUpsertWithWhereUniqueWithoutInsuranceNetworksInput[]
    set?: MedicalInstitutionWhereUniqueInput | MedicalInstitutionWhereUniqueInput[]
    disconnect?: MedicalInstitutionWhereUniqueInput | MedicalInstitutionWhereUniqueInput[]
    delete?: MedicalInstitutionWhereUniqueInput | MedicalInstitutionWhereUniqueInput[]
    connect?: MedicalInstitutionWhereUniqueInput | MedicalInstitutionWhereUniqueInput[]
    update?: MedicalInstitutionUpdateWithWhereUniqueWithoutInsuranceNetworksInput | MedicalInstitutionUpdateWithWhereUniqueWithoutInsuranceNetworksInput[]
    updateMany?: MedicalInstitutionUpdateManyWithWhereWithoutInsuranceNetworksInput | MedicalInstitutionUpdateManyWithWhereWithoutInsuranceNetworksInput[]
    deleteMany?: MedicalInstitutionScalarWhereInput | MedicalInstitutionScalarWhereInput[]
  }

  export type EmergencyAccessUncheckedUpdateManyWithoutInsuranceNestedInput = {
    create?: XOR<EmergencyAccessCreateWithoutInsuranceInput, EmergencyAccessUncheckedCreateWithoutInsuranceInput> | EmergencyAccessCreateWithoutInsuranceInput[] | EmergencyAccessUncheckedCreateWithoutInsuranceInput[]
    connectOrCreate?: EmergencyAccessCreateOrConnectWithoutInsuranceInput | EmergencyAccessCreateOrConnectWithoutInsuranceInput[]
    upsert?: EmergencyAccessUpsertWithWhereUniqueWithoutInsuranceInput | EmergencyAccessUpsertWithWhereUniqueWithoutInsuranceInput[]
    createMany?: EmergencyAccessCreateManyInsuranceInputEnvelope
    set?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
    disconnect?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
    delete?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
    connect?: EmergencyAccessWhereUniqueInput | EmergencyAccessWhereUniqueInput[]
    update?: EmergencyAccessUpdateWithWhereUniqueWithoutInsuranceInput | EmergencyAccessUpdateWithWhereUniqueWithoutInsuranceInput[]
    updateMany?: EmergencyAccessUpdateManyWithWhereWithoutInsuranceInput | EmergencyAccessUpdateManyWithWhereWithoutInsuranceInput[]
    deleteMany?: EmergencyAccessScalarWhereInput | EmergencyAccessScalarWhereInput[]
  }

  export type InsurancePlanCreatefeaturesInput = {
    set: string[]
  }

  export type InsurancePlanCreateexclusionsInput = {
    set: string[]
  }

  export type InsuranceCompanyCreateNestedOneWithoutPlansInput = {
    create?: XOR<InsuranceCompanyCreateWithoutPlansInput, InsuranceCompanyUncheckedCreateWithoutPlansInput>
    connectOrCreate?: InsuranceCompanyCreateOrConnectWithoutPlansInput
    connect?: InsuranceCompanyWhereUniqueInput
  }

  export type InsurancePlanUpdatefeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InsurancePlanUpdateexclusionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InsuranceCompanyUpdateOneRequiredWithoutPlansNestedInput = {
    create?: XOR<InsuranceCompanyCreateWithoutPlansInput, InsuranceCompanyUncheckedCreateWithoutPlansInput>
    connectOrCreate?: InsuranceCompanyCreateOrConnectWithoutPlansInput
    upsert?: InsuranceCompanyUpsertWithoutPlansInput
    connect?: InsuranceCompanyWhereUniqueInput
    update?: XOR<XOR<InsuranceCompanyUpdateToOneWithWhereWithoutPlansInput, InsuranceCompanyUpdateWithoutPlansInput>, InsuranceCompanyUncheckedUpdateWithoutPlansInput>
  }

  export type MedicalInstitutionCreateNestedOneWithoutStaffInput = {
    create?: XOR<MedicalInstitutionCreateWithoutStaffInput, MedicalInstitutionUncheckedCreateWithoutStaffInput>
    connectOrCreate?: MedicalInstitutionCreateOrConnectWithoutStaffInput
    connect?: MedicalInstitutionWhereUniqueInput
  }

  export type EnumStaffRoleFieldUpdateOperationsInput = {
    set?: $Enums.StaffRole
  }

  export type MedicalInstitutionUpdateOneRequiredWithoutStaffNestedInput = {
    create?: XOR<MedicalInstitutionCreateWithoutStaffInput, MedicalInstitutionUncheckedCreateWithoutStaffInput>
    connectOrCreate?: MedicalInstitutionCreateOrConnectWithoutStaffInput
    upsert?: MedicalInstitutionUpsertWithoutStaffInput
    connect?: MedicalInstitutionWhereUniqueInput
    update?: XOR<XOR<MedicalInstitutionUpdateToOneWithWhereWithoutStaffInput, MedicalInstitutionUpdateWithoutStaffInput>, MedicalInstitutionUncheckedUpdateWithoutStaffInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type EnumNotificationChannelFieldUpdateOperationsInput = {
    set?: $Enums.NotificationChannel
  }

  export type EnumNotificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.NotificationStatus
  }

  export type UserCreateNestedOneWithoutPanicAlertsInput = {
    create?: XOR<UserCreateWithoutPanicAlertsInput, UserUncheckedCreateWithoutPanicAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPanicAlertsInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumPanicStatusFieldUpdateOperationsInput = {
    set?: $Enums.PanicStatus
  }

  export type UserUpdateOneRequiredWithoutPanicAlertsNestedInput = {
    create?: XOR<UserCreateWithoutPanicAlertsInput, UserUncheckedCreateWithoutPanicAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPanicAlertsInput
    upsert?: UserUpsertWithoutPanicAlertsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPanicAlertsInput, UserUpdateWithoutPanicAlertsInput>, UserUncheckedUpdateWithoutPanicAlertsInput>
  }

  export type AdminUserCreatepermissionsInput = {
    set: string[]
  }

  export type AdminSessionCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminSessionCreateWithoutAdminInput, AdminSessionUncheckedCreateWithoutAdminInput> | AdminSessionCreateWithoutAdminInput[] | AdminSessionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminSessionCreateOrConnectWithoutAdminInput | AdminSessionCreateOrConnectWithoutAdminInput[]
    createMany?: AdminSessionCreateManyAdminInputEnvelope
    connect?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
  }

  export type AdminAuditLogCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput> | AdminAuditLogCreateWithoutAdminInput[] | AdminAuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminInput | AdminAuditLogCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAuditLogCreateManyAdminInputEnvelope
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
  }

  export type AdminSessionUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminSessionCreateWithoutAdminInput, AdminSessionUncheckedCreateWithoutAdminInput> | AdminSessionCreateWithoutAdminInput[] | AdminSessionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminSessionCreateOrConnectWithoutAdminInput | AdminSessionCreateOrConnectWithoutAdminInput[]
    createMany?: AdminSessionCreateManyAdminInputEnvelope
    connect?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
  }

  export type AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput> | AdminAuditLogCreateWithoutAdminInput[] | AdminAuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminInput | AdminAuditLogCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAuditLogCreateManyAdminInputEnvelope
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
  }

  export type EnumAdminRoleFieldUpdateOperationsInput = {
    set?: $Enums.AdminRole
  }

  export type AdminUserUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AdminSessionUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminSessionCreateWithoutAdminInput, AdminSessionUncheckedCreateWithoutAdminInput> | AdminSessionCreateWithoutAdminInput[] | AdminSessionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminSessionCreateOrConnectWithoutAdminInput | AdminSessionCreateOrConnectWithoutAdminInput[]
    upsert?: AdminSessionUpsertWithWhereUniqueWithoutAdminInput | AdminSessionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminSessionCreateManyAdminInputEnvelope
    set?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    disconnect?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    delete?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    connect?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    update?: AdminSessionUpdateWithWhereUniqueWithoutAdminInput | AdminSessionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminSessionUpdateManyWithWhereWithoutAdminInput | AdminSessionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminSessionScalarWhereInput | AdminSessionScalarWhereInput[]
  }

  export type AdminAuditLogUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput> | AdminAuditLogCreateWithoutAdminInput[] | AdminAuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminInput | AdminAuditLogCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput | AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAuditLogCreateManyAdminInputEnvelope
    set?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    disconnect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    delete?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    update?: AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput | AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAuditLogUpdateManyWithWhereWithoutAdminInput | AdminAuditLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
  }

  export type AdminSessionUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminSessionCreateWithoutAdminInput, AdminSessionUncheckedCreateWithoutAdminInput> | AdminSessionCreateWithoutAdminInput[] | AdminSessionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminSessionCreateOrConnectWithoutAdminInput | AdminSessionCreateOrConnectWithoutAdminInput[]
    upsert?: AdminSessionUpsertWithWhereUniqueWithoutAdminInput | AdminSessionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminSessionCreateManyAdminInputEnvelope
    set?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    disconnect?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    delete?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    connect?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    update?: AdminSessionUpdateWithWhereUniqueWithoutAdminInput | AdminSessionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminSessionUpdateManyWithWhereWithoutAdminInput | AdminSessionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminSessionScalarWhereInput | AdminSessionScalarWhereInput[]
  }

  export type AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput> | AdminAuditLogCreateWithoutAdminInput[] | AdminAuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminInput | AdminAuditLogCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput | AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAuditLogCreateManyAdminInputEnvelope
    set?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    disconnect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    delete?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    update?: AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput | AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAuditLogUpdateManyWithWhereWithoutAdminInput | AdminAuditLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
  }

  export type AdminUserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<AdminUserCreateWithoutSessionsInput, AdminUserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutSessionsInput
    connect?: AdminUserWhereUniqueInput
  }

  export type AdminUserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<AdminUserCreateWithoutSessionsInput, AdminUserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutSessionsInput
    upsert?: AdminUserUpsertWithoutSessionsInput
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutSessionsInput, AdminUserUpdateWithoutSessionsInput>, AdminUserUncheckedUpdateWithoutSessionsInput>
  }

  export type AdminUserCreateNestedOneWithoutAuditActionsInput = {
    create?: XOR<AdminUserCreateWithoutAuditActionsInput, AdminUserUncheckedCreateWithoutAuditActionsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutAuditActionsInput
    connect?: AdminUserWhereUniqueInput
  }

  export type AdminUserUpdateOneRequiredWithoutAuditActionsNestedInput = {
    create?: XOR<AdminUserCreateWithoutAuditActionsInput, AdminUserUncheckedCreateWithoutAuditActionsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutAuditActionsInput
    upsert?: AdminUserUpsertWithoutAuditActionsInput
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutAuditActionsInput, AdminUserUpdateWithoutAuditActionsInput>, AdminUserUncheckedUpdateWithoutAuditActionsInput>
  }

  export type SubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type SubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
  }

  export type SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput
    connect?: SubscriptionPlanWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EnumBillingCycleFieldUpdateOperationsInput = {
    set?: $Enums.BillingCycle
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type UserUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    upsert?: UserUpsertWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionInput, UserUpdateWithoutSubscriptionInput>, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput
    upsert?: SubscriptionPlanUpsertWithoutSubscriptionsInput
    connect?: SubscriptionPlanWhereUniqueInput
    update?: XOR<XOR<SubscriptionPlanUpdateToOneWithWhereWithoutSubscriptionsInput, SubscriptionPlanUpdateWithoutSubscriptionsInput>, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type PaymentUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutSubscriptionInput | PaymentUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutSubscriptionInput | PaymentUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutSubscriptionInput | PaymentUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutSubscriptionInput | PaymentUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutSubscriptionInput | PaymentUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutSubscriptionInput | PaymentUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type SubscriptionCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPaymentsInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutPaymentInput = {
    create?: XOR<InvoiceCreateWithoutPaymentInput, InvoiceUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUncheckedCreateNestedOneWithoutPaymentInput = {
    create?: XOR<InvoiceCreateWithoutPaymentInput, InvoiceUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentInput
    connect?: InvoiceWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumPaymentMethodTypeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethodType
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type SubscriptionUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPaymentsInput
    upsert?: SubscriptionUpsertWithoutPaymentsInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutPaymentsInput, SubscriptionUpdateWithoutPaymentsInput>, SubscriptionUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentInput, InvoiceUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentInput
    upsert?: InvoiceUpsertWithoutPaymentInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentInput, InvoiceUpdateWithoutPaymentInput>, InvoiceUncheckedUpdateWithoutPaymentInput>
  }

  export type InvoiceUncheckedUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentInput, InvoiceUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentInput
    upsert?: InvoiceUpsertWithoutPaymentInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentInput, InvoiceUpdateWithoutPaymentInput>, InvoiceUncheckedUpdateWithoutPaymentInput>
  }

  export type UserCreateNestedOneWithoutPaymentMethodsInput = {
    create?: XOR<UserCreateWithoutPaymentMethodsInput, UserUncheckedCreateWithoutPaymentMethodsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentMethodsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPaymentMethodsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentMethodsInput, UserUncheckedCreateWithoutPaymentMethodsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentMethodsInput
    upsert?: UserUpsertWithoutPaymentMethodsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentMethodsInput, UserUpdateWithoutPaymentMethodsInput>, UserUncheckedUpdateWithoutPaymentMethodsInput>
  }

  export type UserCreateNestedOneWithoutFiscalDataInput = {
    create?: XOR<UserCreateWithoutFiscalDataInput, UserUncheckedCreateWithoutFiscalDataInput>
    connectOrCreate?: UserCreateOrConnectWithoutFiscalDataInput
    connect?: UserWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutFiscalDataInput = {
    create?: XOR<InvoiceCreateWithoutFiscalDataInput, InvoiceUncheckedCreateWithoutFiscalDataInput> | InvoiceCreateWithoutFiscalDataInput[] | InvoiceUncheckedCreateWithoutFiscalDataInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutFiscalDataInput | InvoiceCreateOrConnectWithoutFiscalDataInput[]
    createMany?: InvoiceCreateManyFiscalDataInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutFiscalDataInput = {
    create?: XOR<InvoiceCreateWithoutFiscalDataInput, InvoiceUncheckedCreateWithoutFiscalDataInput> | InvoiceCreateWithoutFiscalDataInput[] | InvoiceUncheckedCreateWithoutFiscalDataInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutFiscalDataInput | InvoiceCreateOrConnectWithoutFiscalDataInput[]
    createMany?: InvoiceCreateManyFiscalDataInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutFiscalDataNestedInput = {
    create?: XOR<UserCreateWithoutFiscalDataInput, UserUncheckedCreateWithoutFiscalDataInput>
    connectOrCreate?: UserCreateOrConnectWithoutFiscalDataInput
    upsert?: UserUpsertWithoutFiscalDataInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFiscalDataInput, UserUpdateWithoutFiscalDataInput>, UserUncheckedUpdateWithoutFiscalDataInput>
  }

  export type InvoiceUpdateManyWithoutFiscalDataNestedInput = {
    create?: XOR<InvoiceCreateWithoutFiscalDataInput, InvoiceUncheckedCreateWithoutFiscalDataInput> | InvoiceCreateWithoutFiscalDataInput[] | InvoiceUncheckedCreateWithoutFiscalDataInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutFiscalDataInput | InvoiceCreateOrConnectWithoutFiscalDataInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutFiscalDataInput | InvoiceUpsertWithWhereUniqueWithoutFiscalDataInput[]
    createMany?: InvoiceCreateManyFiscalDataInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutFiscalDataInput | InvoiceUpdateWithWhereUniqueWithoutFiscalDataInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutFiscalDataInput | InvoiceUpdateManyWithWhereWithoutFiscalDataInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutFiscalDataNestedInput = {
    create?: XOR<InvoiceCreateWithoutFiscalDataInput, InvoiceUncheckedCreateWithoutFiscalDataInput> | InvoiceCreateWithoutFiscalDataInput[] | InvoiceUncheckedCreateWithoutFiscalDataInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutFiscalDataInput | InvoiceCreateOrConnectWithoutFiscalDataInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutFiscalDataInput | InvoiceUpsertWithWhereUniqueWithoutFiscalDataInput[]
    createMany?: InvoiceCreateManyFiscalDataInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutFiscalDataInput | InvoiceUpdateWithWhereUniqueWithoutFiscalDataInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutFiscalDataInput | InvoiceUpdateManyWithWhereWithoutFiscalDataInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput
    connect?: PaymentWhereUniqueInput
  }

  export type FiscalDataCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<FiscalDataCreateWithoutInvoicesInput, FiscalDataUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: FiscalDataCreateOrConnectWithoutInvoicesInput
    connect?: FiscalDataWhereUniqueInput
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type UserUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    upsert?: UserUpsertWithoutInvoicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvoicesInput, UserUpdateWithoutInvoicesInput>, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type PaymentUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput
    upsert?: PaymentUpsertWithoutInvoiceInput
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutInvoiceInput, PaymentUpdateWithoutInvoiceInput>, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type FiscalDataUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<FiscalDataCreateWithoutInvoicesInput, FiscalDataUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: FiscalDataCreateOrConnectWithoutInvoicesInput
    upsert?: FiscalDataUpsertWithoutInvoicesInput
    disconnect?: FiscalDataWhereInput | boolean
    delete?: FiscalDataWhereInput | boolean
    connect?: FiscalDataWhereUniqueInput
    update?: XOR<XOR<FiscalDataUpdateToOneWithWhereWithoutInvoicesInput, FiscalDataUpdateWithoutInvoicesInput>, FiscalDataUncheckedUpdateWithoutInvoicesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumDirectiveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DirectiveType | EnumDirectiveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DirectiveType[] | ListEnumDirectiveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DirectiveType[] | ListEnumDirectiveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectiveTypeFilter<$PrismaModel> | $Enums.DirectiveType
  }

  export type NestedEnumDirectiveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DirectiveStatus | EnumDirectiveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DirectiveStatus[] | ListEnumDirectiveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DirectiveStatus[] | ListEnumDirectiveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectiveStatusFilter<$PrismaModel> | $Enums.DirectiveStatus
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumDirectiveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DirectiveType | EnumDirectiveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DirectiveType[] | ListEnumDirectiveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DirectiveType[] | ListEnumDirectiveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectiveTypeWithAggregatesFilter<$PrismaModel> | $Enums.DirectiveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDirectiveTypeFilter<$PrismaModel>
    _max?: NestedEnumDirectiveTypeFilter<$PrismaModel>
  }

  export type NestedEnumDirectiveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DirectiveStatus | EnumDirectiveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DirectiveStatus[] | ListEnumDirectiveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DirectiveStatus[] | ListEnumDirectiveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectiveStatusWithAggregatesFilter<$PrismaModel> | $Enums.DirectiveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDirectiveStatusFilter<$PrismaModel>
    _max?: NestedEnumDirectiveStatusFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumInstitutionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InstitutionType | EnumInstitutionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInstitutionTypeFilter<$PrismaModel> | $Enums.InstitutionType
  }

  export type NestedEnumAttentionLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AttentionLevel | EnumAttentionLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.AttentionLevel[] | ListEnumAttentionLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AttentionLevel[] | ListEnumAttentionLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAttentionLevelNullableFilter<$PrismaModel> | $Enums.AttentionLevel | null
  }

  export type NestedEnumInstitutionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstitutionType | EnumInstitutionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInstitutionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InstitutionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstitutionTypeFilter<$PrismaModel>
    _max?: NestedEnumInstitutionTypeFilter<$PrismaModel>
  }

  export type NestedEnumAttentionLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttentionLevel | EnumAttentionLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.AttentionLevel[] | ListEnumAttentionLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AttentionLevel[] | ListEnumAttentionLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAttentionLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.AttentionLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAttentionLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumAttentionLevelNullableFilter<$PrismaModel>
  }

  export type NestedEnumInsuranceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InsuranceType | EnumInsuranceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InsuranceType[] | ListEnumInsuranceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsuranceType[] | ListEnumInsuranceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInsuranceTypeFilter<$PrismaModel> | $Enums.InsuranceType
  }

  export type NestedEnumInsuranceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsuranceType | EnumInsuranceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InsuranceType[] | ListEnumInsuranceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsuranceType[] | ListEnumInsuranceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInsuranceTypeWithAggregatesFilter<$PrismaModel> | $Enums.InsuranceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsuranceTypeFilter<$PrismaModel>
    _max?: NestedEnumInsuranceTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumStaffRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffRole | EnumStaffRoleFieldRefInput<$PrismaModel>
    in?: $Enums.StaffRole[] | ListEnumStaffRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.StaffRole[] | ListEnumStaffRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumStaffRoleFilter<$PrismaModel> | $Enums.StaffRole
  }

  export type NestedEnumStaffRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffRole | EnumStaffRoleFieldRefInput<$PrismaModel>
    in?: $Enums.StaffRole[] | ListEnumStaffRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.StaffRole[] | ListEnumStaffRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumStaffRoleWithAggregatesFilter<$PrismaModel> | $Enums.StaffRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStaffRoleFilter<$PrismaModel>
    _max?: NestedEnumStaffRoleFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelFilter<$PrismaModel> | $Enums.NotificationChannel
  }

  export type NestedEnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelWithAggregatesFilter<$PrismaModel> | $Enums.NotificationChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationChannelFilter<$PrismaModel>
    _max?: NestedEnumNotificationChannelFilter<$PrismaModel>
  }

  export type NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumPanicStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PanicStatus | EnumPanicStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PanicStatus[] | ListEnumPanicStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PanicStatus[] | ListEnumPanicStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPanicStatusFilter<$PrismaModel> | $Enums.PanicStatus
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumPanicStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PanicStatus | EnumPanicStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PanicStatus[] | ListEnumPanicStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PanicStatus[] | ListEnumPanicStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPanicStatusWithAggregatesFilter<$PrismaModel> | $Enums.PanicStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPanicStatusFilter<$PrismaModel>
    _max?: NestedEnumPanicStatusFilter<$PrismaModel>
  }

  export type NestedEnumAdminRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleFilter<$PrismaModel> | $Enums.AdminRole
  }

  export type NestedEnumAdminRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleWithAggregatesFilter<$PrismaModel> | $Enums.AdminRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminRoleFilter<$PrismaModel>
    _max?: NestedEnumAdminRoleFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumBillingCycleFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingCycle | EnumBillingCycleFieldRefInput<$PrismaModel>
    in?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingCycleFilter<$PrismaModel> | $Enums.BillingCycle
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumBillingCycleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingCycle | EnumBillingCycleFieldRefInput<$PrismaModel>
    in?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingCycleWithAggregatesFilter<$PrismaModel> | $Enums.BillingCycle
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillingCycleFilter<$PrismaModel>
    _max?: NestedEnumBillingCycleFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumPaymentMethodTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodType | EnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodType[] | ListEnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethodType[] | ListEnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodTypeFilter<$PrismaModel> | $Enums.PaymentMethodType
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodType | EnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodType[] | ListEnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethodType[] | ListEnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethodType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type PatientProfileCreateWithoutUserInput = {
    id?: string
    bloodType?: string | null
    allergiesEnc?: string | null
    conditionsEnc?: string | null
    medicationsEnc?: string | null
    insuranceProvider?: string | null
    insurancePolicy?: string | null
    insurancePhone?: string | null
    photoUrl?: string | null
    isDonor?: boolean
    donorPreferencesEnc?: string | null
    donorVideoUrl?: string | null
    qrToken?: string
    qrGeneratedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientProfileUncheckedCreateWithoutUserInput = {
    id?: string
    bloodType?: string | null
    allergiesEnc?: string | null
    conditionsEnc?: string | null
    medicationsEnc?: string | null
    insuranceProvider?: string | null
    insurancePolicy?: string | null
    insurancePhone?: string | null
    photoUrl?: string | null
    isDonor?: boolean
    donorPreferencesEnc?: string | null
    donorVideoUrl?: string | null
    qrToken?: string
    qrGeneratedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientProfileCreateOrConnectWithoutUserInput = {
    where: PatientProfileWhereUniqueInput
    create: XOR<PatientProfileCreateWithoutUserInput, PatientProfileUncheckedCreateWithoutUserInput>
  }

  export type AdvanceDirectiveCreateWithoutUserInput = {
    id?: string
    type: $Enums.DirectiveType
    status?: $Enums.DirectiveStatus
    documentUrl?: string | null
    documentHash?: string | null
    originalFileName?: string | null
    nom151Sealed?: boolean
    nom151Timestamp?: Date | string | null
    nom151Certificate?: string | null
    nom151Provider?: string | null
    acceptsCPR?: boolean | null
    acceptsIntubation?: boolean | null
    acceptsDialysis?: boolean | null
    acceptsTransfusion?: boolean | null
    acceptsArtificialNutrition?: boolean | null
    palliativeCareOnly?: boolean | null
    additionalNotes?: string | null
    originState?: string | null
    legalBasisSummary?: string | null
    validatedAt?: Date | string | null
    validatedBy?: string | null
    validationMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    witnesses?: WitnessCreateNestedManyWithoutDirectiveInput
  }

  export type AdvanceDirectiveUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.DirectiveType
    status?: $Enums.DirectiveStatus
    documentUrl?: string | null
    documentHash?: string | null
    originalFileName?: string | null
    nom151Sealed?: boolean
    nom151Timestamp?: Date | string | null
    nom151Certificate?: string | null
    nom151Provider?: string | null
    acceptsCPR?: boolean | null
    acceptsIntubation?: boolean | null
    acceptsDialysis?: boolean | null
    acceptsTransfusion?: boolean | null
    acceptsArtificialNutrition?: boolean | null
    palliativeCareOnly?: boolean | null
    additionalNotes?: string | null
    originState?: string | null
    legalBasisSummary?: string | null
    validatedAt?: Date | string | null
    validatedBy?: string | null
    validationMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    witnesses?: WitnessUncheckedCreateNestedManyWithoutDirectiveInput
  }

  export type AdvanceDirectiveCreateOrConnectWithoutUserInput = {
    where: AdvanceDirectiveWhereUniqueInput
    create: XOR<AdvanceDirectiveCreateWithoutUserInput, AdvanceDirectiveUncheckedCreateWithoutUserInput>
  }

  export type AdvanceDirectiveCreateManyUserInputEnvelope = {
    data: AdvanceDirectiveCreateManyUserInput | AdvanceDirectiveCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RepresentativeCreateWithoutUserInput = {
    id?: string
    name: string
    phone: string
    email?: string | null
    relation: string
    priority?: number
    isDonorSpokesperson?: boolean
    notifyOnEmergency?: boolean
    notifyOnAccess?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RepresentativeUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    phone: string
    email?: string | null
    relation: string
    priority?: number
    isDonorSpokesperson?: boolean
    notifyOnEmergency?: boolean
    notifyOnAccess?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RepresentativeCreateOrConnectWithoutUserInput = {
    where: RepresentativeWhereUniqueInput
    create: XOR<RepresentativeCreateWithoutUserInput, RepresentativeUncheckedCreateWithoutUserInput>
  }

  export type RepresentativeCreateManyUserInputEnvelope = {
    data: RepresentativeCreateManyUserInput | RepresentativeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmergencyAccessCreateWithoutPatientInput = {
    id?: string
    accessorId?: string | null
    accessorName: string
    accessorRole: string
    accessorLicense?: string | null
    institutionName?: string | null
    insurancePolicyNo?: string | null
    qrTokenUsed: string
    ipAddress?: string | null
    userAgent?: string | null
    latitude?: number | null
    longitude?: number | null
    locationName?: string | null
    dataAccessed?: EmergencyAccessCreatedataAccessedInput | string[]
    representativesNotified?: EmergencyAccessCreaterepresentativesNotifiedInput | string[]
    notificationsSentAt?: Date | string | null
    accessToken?: string
    accessedAt?: Date | string
    expiresAt: Date | string
    institution?: MedicalInstitutionCreateNestedOneWithoutEmergencyAccessesInput
    insurance?: InsuranceCompanyCreateNestedOneWithoutEmergencyAccessesInput
  }

  export type EmergencyAccessUncheckedCreateWithoutPatientInput = {
    id?: string
    accessorId?: string | null
    accessorName: string
    accessorRole: string
    accessorLicense?: string | null
    institutionId?: string | null
    institutionName?: string | null
    insuranceId?: string | null
    insurancePolicyNo?: string | null
    qrTokenUsed: string
    ipAddress?: string | null
    userAgent?: string | null
    latitude?: number | null
    longitude?: number | null
    locationName?: string | null
    dataAccessed?: EmergencyAccessCreatedataAccessedInput | string[]
    representativesNotified?: EmergencyAccessCreaterepresentativesNotifiedInput | string[]
    notificationsSentAt?: Date | string | null
    accessToken?: string
    accessedAt?: Date | string
    expiresAt: Date | string
  }

  export type EmergencyAccessCreateOrConnectWithoutPatientInput = {
    where: EmergencyAccessWhereUniqueInput
    create: XOR<EmergencyAccessCreateWithoutPatientInput, EmergencyAccessUncheckedCreateWithoutPatientInput>
  }

  export type EmergencyAccessCreateManyPatientInputEnvelope = {
    data: EmergencyAccessCreateManyPatientInput | EmergencyAccessCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PanicAlertCreateWithoutUserInput = {
    id?: string
    latitude: number
    longitude: number
    accuracy?: number | null
    locationName?: string | null
    status?: $Enums.PanicStatus
    message?: string | null
    cancelledAt?: Date | string | null
    resolvedAt?: Date | string | null
    nearbyHospitals?: NullableJsonNullValueInput | InputJsonValue
    notificationsSent?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PanicAlertUncheckedCreateWithoutUserInput = {
    id?: string
    latitude: number
    longitude: number
    accuracy?: number | null
    locationName?: string | null
    status?: $Enums.PanicStatus
    message?: string | null
    cancelledAt?: Date | string | null
    resolvedAt?: Date | string | null
    nearbyHospitals?: NullableJsonNullValueInput | InputJsonValue
    notificationsSent?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PanicAlertCreateOrConnectWithoutUserInput = {
    where: PanicAlertWhereUniqueInput
    create: XOR<PanicAlertCreateWithoutUserInput, PanicAlertUncheckedCreateWithoutUserInput>
  }

  export type PanicAlertCreateManyUserInputEnvelope = {
    data: PanicAlertCreateManyUserInput | PanicAlertCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    actorType: string
    actorId?: string | null
    actorName?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    actorType: string
    actorId?: string | null
    actorName?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    refreshToken: string
    userAgent?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    refreshToken: string
    userAgent?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WebAuthnCredentialCreateWithoutUserInput = {
    id?: string
    credentialId: string
    credentialPublicKey: Buffer
    counter?: bigint | number
    deviceType?: string | null
    deviceName?: string | null
    transports?: WebAuthnCredentialCreatetransportsInput | string[]
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type WebAuthnCredentialUncheckedCreateWithoutUserInput = {
    id?: string
    credentialId: string
    credentialPublicKey: Buffer
    counter?: bigint | number
    deviceType?: string | null
    deviceName?: string | null
    transports?: WebAuthnCredentialCreatetransportsInput | string[]
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type WebAuthnCredentialCreateOrConnectWithoutUserInput = {
    where: WebAuthnCredentialWhereUniqueInput
    create: XOR<WebAuthnCredentialCreateWithoutUserInput, WebAuthnCredentialUncheckedCreateWithoutUserInput>
  }

  export type WebAuthnCredentialCreateManyUserInputEnvelope = {
    data: WebAuthnCredentialCreateManyUserInput | WebAuthnCredentialCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutUserInput = {
    id?: string
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    billingCycle?: $Enums.BillingCycle
    status?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
    payments?: PaymentCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    planId: string
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    billingCycle?: $Enums.BillingCycle
    status?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateWithoutUserInput = {
    id?: string
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    stripeInvoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod: $Enums.PaymentMethodType
    last4?: string | null
    cardBrand?: string | null
    oxxoVoucherUrl?: string | null
    oxxoExpiresAt?: Date | string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    failureCode?: string | null
    failureMessage?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionCreateNestedOneWithoutPaymentsInput
    invoice?: InvoiceCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: string
    subscriptionId?: string | null
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    stripeInvoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod: $Enums.PaymentMethodType
    last4?: string | null
    cardBrand?: string | null
    oxxoVoucherUrl?: string | null
    oxxoExpiresAt?: Date | string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    failureCode?: string | null
    failureMessage?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentMethodCreateWithoutUserInput = {
    id?: string
    stripePaymentMethodId: string
    type?: $Enums.PaymentMethodType
    last4: string
    brand: string
    expMonth: number
    expYear: number
    cardholderName?: string | null
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUncheckedCreateWithoutUserInput = {
    id?: string
    stripePaymentMethodId: string
    type?: $Enums.PaymentMethodType
    last4: string
    brand: string
    expMonth: number
    expYear: number
    cardholderName?: string | null
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodCreateOrConnectWithoutUserInput = {
    where: PaymentMethodWhereUniqueInput
    create: XOR<PaymentMethodCreateWithoutUserInput, PaymentMethodUncheckedCreateWithoutUserInput>
  }

  export type PaymentMethodCreateManyUserInputEnvelope = {
    data: PaymentMethodCreateManyUserInput | PaymentMethodCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FiscalDataCreateWithoutUserInput = {
    id?: string
    rfc: string
    razonSocial: string
    regimenFiscal: string
    usoCFDI?: string
    codigoPostal: string
    calle?: string | null
    numExterior?: string | null
    numInterior?: string | null
    colonia?: string | null
    municipio?: string | null
    estado?: string | null
    emailFacturacion: string
    facturamaClientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutFiscalDataInput
  }

  export type FiscalDataUncheckedCreateWithoutUserInput = {
    id?: string
    rfc: string
    razonSocial: string
    regimenFiscal: string
    usoCFDI?: string
    codigoPostal: string
    calle?: string | null
    numExterior?: string | null
    numInterior?: string | null
    colonia?: string | null
    municipio?: string | null
    estado?: string | null
    emailFacturacion: string
    facturamaClientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutFiscalDataInput
  }

  export type FiscalDataCreateOrConnectWithoutUserInput = {
    where: FiscalDataWhereUniqueInput
    create: XOR<FiscalDataCreateWithoutUserInput, FiscalDataUncheckedCreateWithoutUserInput>
  }

  export type InvoiceCreateWithoutUserInput = {
    id?: string
    facturamaInvoiceId?: string | null
    uuid?: string | null
    serie?: string | null
    folio?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    xmlUrl?: string | null
    pdfUrl?: string | null
    status?: $Enums.InvoiceStatus
    issuedAt?: Date | string | null
    cancelledAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payment: PaymentCreateNestedOneWithoutInvoiceInput
    fiscalData?: FiscalDataCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutUserInput = {
    id?: string
    paymentId: string
    fiscalDataId?: string | null
    facturamaInvoiceId?: string | null
    uuid?: string | null
    serie?: string | null
    folio?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    xmlUrl?: string | null
    pdfUrl?: string | null
    status?: $Enums.InvoiceStatus
    issuedAt?: Date | string | null
    cancelledAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput>
  }

  export type InvoiceCreateManyUserInputEnvelope = {
    data: InvoiceCreateManyUserInput | InvoiceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PatientProfileUpsertWithoutUserInput = {
    update: XOR<PatientProfileUpdateWithoutUserInput, PatientProfileUncheckedUpdateWithoutUserInput>
    create: XOR<PatientProfileCreateWithoutUserInput, PatientProfileUncheckedCreateWithoutUserInput>
    where?: PatientProfileWhereInput
  }

  export type PatientProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: PatientProfileWhereInput
    data: XOR<PatientProfileUpdateWithoutUserInput, PatientProfileUncheckedUpdateWithoutUserInput>
  }

  export type PatientProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    allergiesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    conditionsEnc?: NullableStringFieldUpdateOperationsInput | string | null
    medicationsEnc?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicy?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePhone?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDonor?: BoolFieldUpdateOperationsInput | boolean
    donorPreferencesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    donorVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrToken?: StringFieldUpdateOperationsInput | string
    qrGeneratedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    allergiesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    conditionsEnc?: NullableStringFieldUpdateOperationsInput | string | null
    medicationsEnc?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicy?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePhone?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDonor?: BoolFieldUpdateOperationsInput | boolean
    donorPreferencesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    donorVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrToken?: StringFieldUpdateOperationsInput | string
    qrGeneratedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvanceDirectiveUpsertWithWhereUniqueWithoutUserInput = {
    where: AdvanceDirectiveWhereUniqueInput
    update: XOR<AdvanceDirectiveUpdateWithoutUserInput, AdvanceDirectiveUncheckedUpdateWithoutUserInput>
    create: XOR<AdvanceDirectiveCreateWithoutUserInput, AdvanceDirectiveUncheckedCreateWithoutUserInput>
  }

  export type AdvanceDirectiveUpdateWithWhereUniqueWithoutUserInput = {
    where: AdvanceDirectiveWhereUniqueInput
    data: XOR<AdvanceDirectiveUpdateWithoutUserInput, AdvanceDirectiveUncheckedUpdateWithoutUserInput>
  }

  export type AdvanceDirectiveUpdateManyWithWhereWithoutUserInput = {
    where: AdvanceDirectiveScalarWhereInput
    data: XOR<AdvanceDirectiveUpdateManyMutationInput, AdvanceDirectiveUncheckedUpdateManyWithoutUserInput>
  }

  export type AdvanceDirectiveScalarWhereInput = {
    AND?: AdvanceDirectiveScalarWhereInput | AdvanceDirectiveScalarWhereInput[]
    OR?: AdvanceDirectiveScalarWhereInput[]
    NOT?: AdvanceDirectiveScalarWhereInput | AdvanceDirectiveScalarWhereInput[]
    id?: StringFilter<"AdvanceDirective"> | string
    userId?: StringFilter<"AdvanceDirective"> | string
    type?: EnumDirectiveTypeFilter<"AdvanceDirective"> | $Enums.DirectiveType
    status?: EnumDirectiveStatusFilter<"AdvanceDirective"> | $Enums.DirectiveStatus
    documentUrl?: StringNullableFilter<"AdvanceDirective"> | string | null
    documentHash?: StringNullableFilter<"AdvanceDirective"> | string | null
    originalFileName?: StringNullableFilter<"AdvanceDirective"> | string | null
    nom151Sealed?: BoolFilter<"AdvanceDirective"> | boolean
    nom151Timestamp?: DateTimeNullableFilter<"AdvanceDirective"> | Date | string | null
    nom151Certificate?: StringNullableFilter<"AdvanceDirective"> | string | null
    nom151Provider?: StringNullableFilter<"AdvanceDirective"> | string | null
    acceptsCPR?: BoolNullableFilter<"AdvanceDirective"> | boolean | null
    acceptsIntubation?: BoolNullableFilter<"AdvanceDirective"> | boolean | null
    acceptsDialysis?: BoolNullableFilter<"AdvanceDirective"> | boolean | null
    acceptsTransfusion?: BoolNullableFilter<"AdvanceDirective"> | boolean | null
    acceptsArtificialNutrition?: BoolNullableFilter<"AdvanceDirective"> | boolean | null
    palliativeCareOnly?: BoolNullableFilter<"AdvanceDirective"> | boolean | null
    additionalNotes?: StringNullableFilter<"AdvanceDirective"> | string | null
    originState?: StringNullableFilter<"AdvanceDirective"> | string | null
    legalBasisSummary?: StringNullableFilter<"AdvanceDirective"> | string | null
    validatedAt?: DateTimeNullableFilter<"AdvanceDirective"> | Date | string | null
    validatedBy?: StringNullableFilter<"AdvanceDirective"> | string | null
    validationMethod?: StringNullableFilter<"AdvanceDirective"> | string | null
    createdAt?: DateTimeFilter<"AdvanceDirective"> | Date | string
    updatedAt?: DateTimeFilter<"AdvanceDirective"> | Date | string
    revokedAt?: DateTimeNullableFilter<"AdvanceDirective"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"AdvanceDirective"> | Date | string | null
  }

  export type RepresentativeUpsertWithWhereUniqueWithoutUserInput = {
    where: RepresentativeWhereUniqueInput
    update: XOR<RepresentativeUpdateWithoutUserInput, RepresentativeUncheckedUpdateWithoutUserInput>
    create: XOR<RepresentativeCreateWithoutUserInput, RepresentativeUncheckedCreateWithoutUserInput>
  }

  export type RepresentativeUpdateWithWhereUniqueWithoutUserInput = {
    where: RepresentativeWhereUniqueInput
    data: XOR<RepresentativeUpdateWithoutUserInput, RepresentativeUncheckedUpdateWithoutUserInput>
  }

  export type RepresentativeUpdateManyWithWhereWithoutUserInput = {
    where: RepresentativeScalarWhereInput
    data: XOR<RepresentativeUpdateManyMutationInput, RepresentativeUncheckedUpdateManyWithoutUserInput>
  }

  export type RepresentativeScalarWhereInput = {
    AND?: RepresentativeScalarWhereInput | RepresentativeScalarWhereInput[]
    OR?: RepresentativeScalarWhereInput[]
    NOT?: RepresentativeScalarWhereInput | RepresentativeScalarWhereInput[]
    id?: StringFilter<"Representative"> | string
    userId?: StringFilter<"Representative"> | string
    name?: StringFilter<"Representative"> | string
    phone?: StringFilter<"Representative"> | string
    email?: StringNullableFilter<"Representative"> | string | null
    relation?: StringFilter<"Representative"> | string
    priority?: IntFilter<"Representative"> | number
    isDonorSpokesperson?: BoolFilter<"Representative"> | boolean
    notifyOnEmergency?: BoolFilter<"Representative"> | boolean
    notifyOnAccess?: BoolFilter<"Representative"> | boolean
    createdAt?: DateTimeFilter<"Representative"> | Date | string
    updatedAt?: DateTimeFilter<"Representative"> | Date | string
  }

  export type EmergencyAccessUpsertWithWhereUniqueWithoutPatientInput = {
    where: EmergencyAccessWhereUniqueInput
    update: XOR<EmergencyAccessUpdateWithoutPatientInput, EmergencyAccessUncheckedUpdateWithoutPatientInput>
    create: XOR<EmergencyAccessCreateWithoutPatientInput, EmergencyAccessUncheckedCreateWithoutPatientInput>
  }

  export type EmergencyAccessUpdateWithWhereUniqueWithoutPatientInput = {
    where: EmergencyAccessWhereUniqueInput
    data: XOR<EmergencyAccessUpdateWithoutPatientInput, EmergencyAccessUncheckedUpdateWithoutPatientInput>
  }

  export type EmergencyAccessUpdateManyWithWhereWithoutPatientInput = {
    where: EmergencyAccessScalarWhereInput
    data: XOR<EmergencyAccessUpdateManyMutationInput, EmergencyAccessUncheckedUpdateManyWithoutPatientInput>
  }

  export type EmergencyAccessScalarWhereInput = {
    AND?: EmergencyAccessScalarWhereInput | EmergencyAccessScalarWhereInput[]
    OR?: EmergencyAccessScalarWhereInput[]
    NOT?: EmergencyAccessScalarWhereInput | EmergencyAccessScalarWhereInput[]
    id?: StringFilter<"EmergencyAccess"> | string
    patientId?: StringFilter<"EmergencyAccess"> | string
    accessorId?: StringNullableFilter<"EmergencyAccess"> | string | null
    accessorName?: StringFilter<"EmergencyAccess"> | string
    accessorRole?: StringFilter<"EmergencyAccess"> | string
    accessorLicense?: StringNullableFilter<"EmergencyAccess"> | string | null
    institutionId?: StringNullableFilter<"EmergencyAccess"> | string | null
    institutionName?: StringNullableFilter<"EmergencyAccess"> | string | null
    insuranceId?: StringNullableFilter<"EmergencyAccess"> | string | null
    insurancePolicyNo?: StringNullableFilter<"EmergencyAccess"> | string | null
    qrTokenUsed?: StringFilter<"EmergencyAccess"> | string
    ipAddress?: StringNullableFilter<"EmergencyAccess"> | string | null
    userAgent?: StringNullableFilter<"EmergencyAccess"> | string | null
    latitude?: FloatNullableFilter<"EmergencyAccess"> | number | null
    longitude?: FloatNullableFilter<"EmergencyAccess"> | number | null
    locationName?: StringNullableFilter<"EmergencyAccess"> | string | null
    dataAccessed?: StringNullableListFilter<"EmergencyAccess">
    representativesNotified?: StringNullableListFilter<"EmergencyAccess">
    notificationsSentAt?: DateTimeNullableFilter<"EmergencyAccess"> | Date | string | null
    accessToken?: StringFilter<"EmergencyAccess"> | string
    accessedAt?: DateTimeFilter<"EmergencyAccess"> | Date | string
    expiresAt?: DateTimeFilter<"EmergencyAccess"> | Date | string
  }

  export type PanicAlertUpsertWithWhereUniqueWithoutUserInput = {
    where: PanicAlertWhereUniqueInput
    update: XOR<PanicAlertUpdateWithoutUserInput, PanicAlertUncheckedUpdateWithoutUserInput>
    create: XOR<PanicAlertCreateWithoutUserInput, PanicAlertUncheckedCreateWithoutUserInput>
  }

  export type PanicAlertUpdateWithWhereUniqueWithoutUserInput = {
    where: PanicAlertWhereUniqueInput
    data: XOR<PanicAlertUpdateWithoutUserInput, PanicAlertUncheckedUpdateWithoutUserInput>
  }

  export type PanicAlertUpdateManyWithWhereWithoutUserInput = {
    where: PanicAlertScalarWhereInput
    data: XOR<PanicAlertUpdateManyMutationInput, PanicAlertUncheckedUpdateManyWithoutUserInput>
  }

  export type PanicAlertScalarWhereInput = {
    AND?: PanicAlertScalarWhereInput | PanicAlertScalarWhereInput[]
    OR?: PanicAlertScalarWhereInput[]
    NOT?: PanicAlertScalarWhereInput | PanicAlertScalarWhereInput[]
    id?: StringFilter<"PanicAlert"> | string
    userId?: StringFilter<"PanicAlert"> | string
    latitude?: FloatFilter<"PanicAlert"> | number
    longitude?: FloatFilter<"PanicAlert"> | number
    accuracy?: FloatNullableFilter<"PanicAlert"> | number | null
    locationName?: StringNullableFilter<"PanicAlert"> | string | null
    status?: EnumPanicStatusFilter<"PanicAlert"> | $Enums.PanicStatus
    message?: StringNullableFilter<"PanicAlert"> | string | null
    cancelledAt?: DateTimeNullableFilter<"PanicAlert"> | Date | string | null
    resolvedAt?: DateTimeNullableFilter<"PanicAlert"> | Date | string | null
    nearbyHospitals?: JsonNullableFilter<"PanicAlert">
    notificationsSent?: JsonNullableFilter<"PanicAlert">
    createdAt?: DateTimeFilter<"PanicAlert"> | Date | string
    updatedAt?: DateTimeFilter<"PanicAlert"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    actorType?: StringFilter<"AuditLog"> | string
    actorId?: StringNullableFilter<"AuditLog"> | string | null
    actorName?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    oldValue?: JsonNullableFilter<"AuditLog">
    newValue?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    refreshToken?: StringFilter<"Session"> | string
    userAgent?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type WebAuthnCredentialUpsertWithWhereUniqueWithoutUserInput = {
    where: WebAuthnCredentialWhereUniqueInput
    update: XOR<WebAuthnCredentialUpdateWithoutUserInput, WebAuthnCredentialUncheckedUpdateWithoutUserInput>
    create: XOR<WebAuthnCredentialCreateWithoutUserInput, WebAuthnCredentialUncheckedCreateWithoutUserInput>
  }

  export type WebAuthnCredentialUpdateWithWhereUniqueWithoutUserInput = {
    where: WebAuthnCredentialWhereUniqueInput
    data: XOR<WebAuthnCredentialUpdateWithoutUserInput, WebAuthnCredentialUncheckedUpdateWithoutUserInput>
  }

  export type WebAuthnCredentialUpdateManyWithWhereWithoutUserInput = {
    where: WebAuthnCredentialScalarWhereInput
    data: XOR<WebAuthnCredentialUpdateManyMutationInput, WebAuthnCredentialUncheckedUpdateManyWithoutUserInput>
  }

  export type WebAuthnCredentialScalarWhereInput = {
    AND?: WebAuthnCredentialScalarWhereInput | WebAuthnCredentialScalarWhereInput[]
    OR?: WebAuthnCredentialScalarWhereInput[]
    NOT?: WebAuthnCredentialScalarWhereInput | WebAuthnCredentialScalarWhereInput[]
    id?: StringFilter<"WebAuthnCredential"> | string
    userId?: StringFilter<"WebAuthnCredential"> | string
    credentialId?: StringFilter<"WebAuthnCredential"> | string
    credentialPublicKey?: BytesFilter<"WebAuthnCredential"> | Buffer
    counter?: BigIntFilter<"WebAuthnCredential"> | bigint | number
    deviceType?: StringNullableFilter<"WebAuthnCredential"> | string | null
    deviceName?: StringNullableFilter<"WebAuthnCredential"> | string | null
    transports?: StringNullableListFilter<"WebAuthnCredential">
    createdAt?: DateTimeFilter<"WebAuthnCredential"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"WebAuthnCredential"> | Date | string | null
  }

  export type SubscriptionUpsertWithoutUserInput = {
    update: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutUserInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    payments?: PaymentUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    subscriptionId?: StringNullableFilter<"Payment"> | string | null
    stripePaymentIntentId?: StringNullableFilter<"Payment"> | string | null
    stripeChargeId?: StringNullableFilter<"Payment"> | string | null
    stripeInvoiceId?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    paymentMethod?: EnumPaymentMethodTypeFilter<"Payment"> | $Enums.PaymentMethodType
    last4?: StringNullableFilter<"Payment"> | string | null
    cardBrand?: StringNullableFilter<"Payment"> | string | null
    oxxoVoucherUrl?: StringNullableFilter<"Payment"> | string | null
    oxxoExpiresAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    description?: StringNullableFilter<"Payment"> | string | null
    failureCode?: StringNullableFilter<"Payment"> | string | null
    failureMessage?: StringNullableFilter<"Payment"> | string | null
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type PaymentMethodUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentMethodWhereUniqueInput
    update: XOR<PaymentMethodUpdateWithoutUserInput, PaymentMethodUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentMethodCreateWithoutUserInput, PaymentMethodUncheckedCreateWithoutUserInput>
  }

  export type PaymentMethodUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentMethodWhereUniqueInput
    data: XOR<PaymentMethodUpdateWithoutUserInput, PaymentMethodUncheckedUpdateWithoutUserInput>
  }

  export type PaymentMethodUpdateManyWithWhereWithoutUserInput = {
    where: PaymentMethodScalarWhereInput
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentMethodScalarWhereInput = {
    AND?: PaymentMethodScalarWhereInput | PaymentMethodScalarWhereInput[]
    OR?: PaymentMethodScalarWhereInput[]
    NOT?: PaymentMethodScalarWhereInput | PaymentMethodScalarWhereInput[]
    id?: StringFilter<"PaymentMethod"> | string
    userId?: StringFilter<"PaymentMethod"> | string
    stripePaymentMethodId?: StringFilter<"PaymentMethod"> | string
    type?: EnumPaymentMethodTypeFilter<"PaymentMethod"> | $Enums.PaymentMethodType
    last4?: StringFilter<"PaymentMethod"> | string
    brand?: StringFilter<"PaymentMethod"> | string
    expMonth?: IntFilter<"PaymentMethod"> | number
    expYear?: IntFilter<"PaymentMethod"> | number
    cardholderName?: StringNullableFilter<"PaymentMethod"> | string | null
    isDefault?: BoolFilter<"PaymentMethod"> | boolean
    isActive?: BoolFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
  }

  export type FiscalDataUpsertWithoutUserInput = {
    update: XOR<FiscalDataUpdateWithoutUserInput, FiscalDataUncheckedUpdateWithoutUserInput>
    create: XOR<FiscalDataCreateWithoutUserInput, FiscalDataUncheckedCreateWithoutUserInput>
    where?: FiscalDataWhereInput
  }

  export type FiscalDataUpdateToOneWithWhereWithoutUserInput = {
    where?: FiscalDataWhereInput
    data: XOR<FiscalDataUpdateWithoutUserInput, FiscalDataUncheckedUpdateWithoutUserInput>
  }

  export type FiscalDataUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rfc?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    regimenFiscal?: StringFieldUpdateOperationsInput | string
    usoCFDI?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    calle?: NullableStringFieldUpdateOperationsInput | string | null
    numExterior?: NullableStringFieldUpdateOperationsInput | string | null
    numInterior?: NullableStringFieldUpdateOperationsInput | string | null
    colonia?: NullableStringFieldUpdateOperationsInput | string | null
    municipio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    emailFacturacion?: StringFieldUpdateOperationsInput | string
    facturamaClientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutFiscalDataNestedInput
  }

  export type FiscalDataUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rfc?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    regimenFiscal?: StringFieldUpdateOperationsInput | string
    usoCFDI?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    calle?: NullableStringFieldUpdateOperationsInput | string | null
    numExterior?: NullableStringFieldUpdateOperationsInput | string | null
    numInterior?: NullableStringFieldUpdateOperationsInput | string | null
    colonia?: NullableStringFieldUpdateOperationsInput | string | null
    municipio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    emailFacturacion?: StringFieldUpdateOperationsInput | string
    facturamaClientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutFiscalDataNestedInput
  }

  export type InvoiceUpsertWithWhereUniqueWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutUserInput, InvoiceUncheckedUpdateWithoutUserInput>
    create: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutUserInput, InvoiceUncheckedUpdateWithoutUserInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutUserInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutUserInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    userId?: StringFilter<"Invoice"> | string
    paymentId?: StringFilter<"Invoice"> | string
    fiscalDataId?: StringNullableFilter<"Invoice"> | string | null
    facturamaInvoiceId?: StringNullableFilter<"Invoice"> | string | null
    uuid?: StringNullableFilter<"Invoice"> | string | null
    serie?: StringNullableFilter<"Invoice"> | string | null
    folio?: StringNullableFilter<"Invoice"> | string | null
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    iva?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    xmlUrl?: StringNullableFilter<"Invoice"> | string | null
    pdfUrl?: StringNullableFilter<"Invoice"> | string | null
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    issuedAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    errorMessage?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileCreateNestedOneWithoutUserInput
    directives?: AdvanceDirectiveCreateNestedManyWithoutUserInput
    representatives?: RepresentativeCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessCreateNestedManyWithoutPatientInput
    panicAlerts?: PanicAlertCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileUncheckedCreateNestedOneWithoutUserInput
    directives?: AdvanceDirectiveUncheckedCreateNestedManyWithoutUserInput
    representatives?: RepresentativeUncheckedCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessUncheckedCreateNestedManyWithoutPatientInput
    panicAlerts?: PanicAlertUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUpdateOneWithoutUserNestedInput
    directives?: AdvanceDirectiveUpdateManyWithoutUserNestedInput
    representatives?: RepresentativeUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUpdateManyWithoutPatientNestedInput
    panicAlerts?: PanicAlertUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUncheckedUpdateOneWithoutUserNestedInput
    directives?: AdvanceDirectiveUncheckedUpdateManyWithoutUserNestedInput
    representatives?: RepresentativeUncheckedUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUncheckedUpdateManyWithoutPatientNestedInput
    panicAlerts?: PanicAlertUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutWebauthnCredentialsInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileCreateNestedOneWithoutUserInput
    directives?: AdvanceDirectiveCreateNestedManyWithoutUserInput
    representatives?: RepresentativeCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessCreateNestedManyWithoutPatientInput
    panicAlerts?: PanicAlertCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWebauthnCredentialsInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileUncheckedCreateNestedOneWithoutUserInput
    directives?: AdvanceDirectiveUncheckedCreateNestedManyWithoutUserInput
    representatives?: RepresentativeUncheckedCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessUncheckedCreateNestedManyWithoutPatientInput
    panicAlerts?: PanicAlertUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWebauthnCredentialsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWebauthnCredentialsInput, UserUncheckedCreateWithoutWebauthnCredentialsInput>
  }

  export type UserUpsertWithoutWebauthnCredentialsInput = {
    update: XOR<UserUpdateWithoutWebauthnCredentialsInput, UserUncheckedUpdateWithoutWebauthnCredentialsInput>
    create: XOR<UserCreateWithoutWebauthnCredentialsInput, UserUncheckedCreateWithoutWebauthnCredentialsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWebauthnCredentialsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWebauthnCredentialsInput, UserUncheckedUpdateWithoutWebauthnCredentialsInput>
  }

  export type UserUpdateWithoutWebauthnCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUpdateOneWithoutUserNestedInput
    directives?: AdvanceDirectiveUpdateManyWithoutUserNestedInput
    representatives?: RepresentativeUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUpdateManyWithoutPatientNestedInput
    panicAlerts?: PanicAlertUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWebauthnCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUncheckedUpdateOneWithoutUserNestedInput
    directives?: AdvanceDirectiveUncheckedUpdateManyWithoutUserNestedInput
    representatives?: RepresentativeUncheckedUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUncheckedUpdateManyWithoutPatientNestedInput
    panicAlerts?: PanicAlertUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    directives?: AdvanceDirectiveCreateNestedManyWithoutUserInput
    representatives?: RepresentativeCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessCreateNestedManyWithoutPatientInput
    panicAlerts?: PanicAlertCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    directives?: AdvanceDirectiveUncheckedCreateNestedManyWithoutUserInput
    representatives?: RepresentativeUncheckedCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessUncheckedCreateNestedManyWithoutPatientInput
    panicAlerts?: PanicAlertUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directives?: AdvanceDirectiveUpdateManyWithoutUserNestedInput
    representatives?: RepresentativeUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUpdateManyWithoutPatientNestedInput
    panicAlerts?: PanicAlertUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directives?: AdvanceDirectiveUncheckedUpdateManyWithoutUserNestedInput
    representatives?: RepresentativeUncheckedUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUncheckedUpdateManyWithoutPatientNestedInput
    panicAlerts?: PanicAlertUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRepresentativesInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileCreateNestedOneWithoutUserInput
    directives?: AdvanceDirectiveCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessCreateNestedManyWithoutPatientInput
    panicAlerts?: PanicAlertCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRepresentativesInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileUncheckedCreateNestedOneWithoutUserInput
    directives?: AdvanceDirectiveUncheckedCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessUncheckedCreateNestedManyWithoutPatientInput
    panicAlerts?: PanicAlertUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRepresentativesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRepresentativesInput, UserUncheckedCreateWithoutRepresentativesInput>
  }

  export type UserUpsertWithoutRepresentativesInput = {
    update: XOR<UserUpdateWithoutRepresentativesInput, UserUncheckedUpdateWithoutRepresentativesInput>
    create: XOR<UserCreateWithoutRepresentativesInput, UserUncheckedCreateWithoutRepresentativesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRepresentativesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRepresentativesInput, UserUncheckedUpdateWithoutRepresentativesInput>
  }

  export type UserUpdateWithoutRepresentativesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUpdateOneWithoutUserNestedInput
    directives?: AdvanceDirectiveUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUpdateManyWithoutPatientNestedInput
    panicAlerts?: PanicAlertUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRepresentativesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUncheckedUpdateOneWithoutUserNestedInput
    directives?: AdvanceDirectiveUncheckedUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUncheckedUpdateManyWithoutPatientNestedInput
    panicAlerts?: PanicAlertUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDirectivesInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileCreateNestedOneWithoutUserInput
    representatives?: RepresentativeCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessCreateNestedManyWithoutPatientInput
    panicAlerts?: PanicAlertCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDirectivesInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileUncheckedCreateNestedOneWithoutUserInput
    representatives?: RepresentativeUncheckedCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessUncheckedCreateNestedManyWithoutPatientInput
    panicAlerts?: PanicAlertUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDirectivesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDirectivesInput, UserUncheckedCreateWithoutDirectivesInput>
  }

  export type WitnessCreateWithoutDirectiveInput = {
    id?: string
    name: string
    curp?: string | null
    email?: string | null
    phone?: string | null
    ineImageUrl?: string | null
    selfieImageUrl?: string | null
    identityVerified?: boolean
    verifiedAt?: Date | string | null
    signatureImageUrl?: string | null
    signedAt?: Date | string | null
    sessionId?: string | null
    sessionRecordingUrl?: string | null
    sessionStartedAt?: Date | string | null
    sessionEndedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WitnessUncheckedCreateWithoutDirectiveInput = {
    id?: string
    name: string
    curp?: string | null
    email?: string | null
    phone?: string | null
    ineImageUrl?: string | null
    selfieImageUrl?: string | null
    identityVerified?: boolean
    verifiedAt?: Date | string | null
    signatureImageUrl?: string | null
    signedAt?: Date | string | null
    sessionId?: string | null
    sessionRecordingUrl?: string | null
    sessionStartedAt?: Date | string | null
    sessionEndedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WitnessCreateOrConnectWithoutDirectiveInput = {
    where: WitnessWhereUniqueInput
    create: XOR<WitnessCreateWithoutDirectiveInput, WitnessUncheckedCreateWithoutDirectiveInput>
  }

  export type WitnessCreateManyDirectiveInputEnvelope = {
    data: WitnessCreateManyDirectiveInput | WitnessCreateManyDirectiveInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDirectivesInput = {
    update: XOR<UserUpdateWithoutDirectivesInput, UserUncheckedUpdateWithoutDirectivesInput>
    create: XOR<UserCreateWithoutDirectivesInput, UserUncheckedCreateWithoutDirectivesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDirectivesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDirectivesInput, UserUncheckedUpdateWithoutDirectivesInput>
  }

  export type UserUpdateWithoutDirectivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUpdateOneWithoutUserNestedInput
    representatives?: RepresentativeUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUpdateManyWithoutPatientNestedInput
    panicAlerts?: PanicAlertUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDirectivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUncheckedUpdateOneWithoutUserNestedInput
    representatives?: RepresentativeUncheckedUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUncheckedUpdateManyWithoutPatientNestedInput
    panicAlerts?: PanicAlertUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WitnessUpsertWithWhereUniqueWithoutDirectiveInput = {
    where: WitnessWhereUniqueInput
    update: XOR<WitnessUpdateWithoutDirectiveInput, WitnessUncheckedUpdateWithoutDirectiveInput>
    create: XOR<WitnessCreateWithoutDirectiveInput, WitnessUncheckedCreateWithoutDirectiveInput>
  }

  export type WitnessUpdateWithWhereUniqueWithoutDirectiveInput = {
    where: WitnessWhereUniqueInput
    data: XOR<WitnessUpdateWithoutDirectiveInput, WitnessUncheckedUpdateWithoutDirectiveInput>
  }

  export type WitnessUpdateManyWithWhereWithoutDirectiveInput = {
    where: WitnessScalarWhereInput
    data: XOR<WitnessUpdateManyMutationInput, WitnessUncheckedUpdateManyWithoutDirectiveInput>
  }

  export type WitnessScalarWhereInput = {
    AND?: WitnessScalarWhereInput | WitnessScalarWhereInput[]
    OR?: WitnessScalarWhereInput[]
    NOT?: WitnessScalarWhereInput | WitnessScalarWhereInput[]
    id?: StringFilter<"Witness"> | string
    directiveId?: StringFilter<"Witness"> | string
    name?: StringFilter<"Witness"> | string
    curp?: StringNullableFilter<"Witness"> | string | null
    email?: StringNullableFilter<"Witness"> | string | null
    phone?: StringNullableFilter<"Witness"> | string | null
    ineImageUrl?: StringNullableFilter<"Witness"> | string | null
    selfieImageUrl?: StringNullableFilter<"Witness"> | string | null
    identityVerified?: BoolFilter<"Witness"> | boolean
    verifiedAt?: DateTimeNullableFilter<"Witness"> | Date | string | null
    signatureImageUrl?: StringNullableFilter<"Witness"> | string | null
    signedAt?: DateTimeNullableFilter<"Witness"> | Date | string | null
    sessionId?: StringNullableFilter<"Witness"> | string | null
    sessionRecordingUrl?: StringNullableFilter<"Witness"> | string | null
    sessionStartedAt?: DateTimeNullableFilter<"Witness"> | Date | string | null
    sessionEndedAt?: DateTimeNullableFilter<"Witness"> | Date | string | null
    createdAt?: DateTimeFilter<"Witness"> | Date | string
  }

  export type AdvanceDirectiveCreateWithoutWitnessesInput = {
    id?: string
    type: $Enums.DirectiveType
    status?: $Enums.DirectiveStatus
    documentUrl?: string | null
    documentHash?: string | null
    originalFileName?: string | null
    nom151Sealed?: boolean
    nom151Timestamp?: Date | string | null
    nom151Certificate?: string | null
    nom151Provider?: string | null
    acceptsCPR?: boolean | null
    acceptsIntubation?: boolean | null
    acceptsDialysis?: boolean | null
    acceptsTransfusion?: boolean | null
    acceptsArtificialNutrition?: boolean | null
    palliativeCareOnly?: boolean | null
    additionalNotes?: string | null
    originState?: string | null
    legalBasisSummary?: string | null
    validatedAt?: Date | string | null
    validatedBy?: string | null
    validationMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutDirectivesInput
  }

  export type AdvanceDirectiveUncheckedCreateWithoutWitnessesInput = {
    id?: string
    userId: string
    type: $Enums.DirectiveType
    status?: $Enums.DirectiveStatus
    documentUrl?: string | null
    documentHash?: string | null
    originalFileName?: string | null
    nom151Sealed?: boolean
    nom151Timestamp?: Date | string | null
    nom151Certificate?: string | null
    nom151Provider?: string | null
    acceptsCPR?: boolean | null
    acceptsIntubation?: boolean | null
    acceptsDialysis?: boolean | null
    acceptsTransfusion?: boolean | null
    acceptsArtificialNutrition?: boolean | null
    palliativeCareOnly?: boolean | null
    additionalNotes?: string | null
    originState?: string | null
    legalBasisSummary?: string | null
    validatedAt?: Date | string | null
    validatedBy?: string | null
    validationMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
  }

  export type AdvanceDirectiveCreateOrConnectWithoutWitnessesInput = {
    where: AdvanceDirectiveWhereUniqueInput
    create: XOR<AdvanceDirectiveCreateWithoutWitnessesInput, AdvanceDirectiveUncheckedCreateWithoutWitnessesInput>
  }

  export type AdvanceDirectiveUpsertWithoutWitnessesInput = {
    update: XOR<AdvanceDirectiveUpdateWithoutWitnessesInput, AdvanceDirectiveUncheckedUpdateWithoutWitnessesInput>
    create: XOR<AdvanceDirectiveCreateWithoutWitnessesInput, AdvanceDirectiveUncheckedCreateWithoutWitnessesInput>
    where?: AdvanceDirectiveWhereInput
  }

  export type AdvanceDirectiveUpdateToOneWithWhereWithoutWitnessesInput = {
    where?: AdvanceDirectiveWhereInput
    data: XOR<AdvanceDirectiveUpdateWithoutWitnessesInput, AdvanceDirectiveUncheckedUpdateWithoutWitnessesInput>
  }

  export type AdvanceDirectiveUpdateWithoutWitnessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDirectiveTypeFieldUpdateOperationsInput | $Enums.DirectiveType
    status?: EnumDirectiveStatusFieldUpdateOperationsInput | $Enums.DirectiveStatus
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    originalFileName?: NullableStringFieldUpdateOperationsInput | string | null
    nom151Sealed?: BoolFieldUpdateOperationsInput | boolean
    nom151Timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom151Certificate?: NullableStringFieldUpdateOperationsInput | string | null
    nom151Provider?: NullableStringFieldUpdateOperationsInput | string | null
    acceptsCPR?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsIntubation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsDialysis?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsTransfusion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsArtificialNutrition?: NullableBoolFieldUpdateOperationsInput | boolean | null
    palliativeCareOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    originState?: NullableStringFieldUpdateOperationsInput | string | null
    legalBasisSummary?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutDirectivesNestedInput
  }

  export type AdvanceDirectiveUncheckedUpdateWithoutWitnessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumDirectiveTypeFieldUpdateOperationsInput | $Enums.DirectiveType
    status?: EnumDirectiveStatusFieldUpdateOperationsInput | $Enums.DirectiveStatus
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    originalFileName?: NullableStringFieldUpdateOperationsInput | string | null
    nom151Sealed?: BoolFieldUpdateOperationsInput | boolean
    nom151Timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom151Certificate?: NullableStringFieldUpdateOperationsInput | string | null
    nom151Provider?: NullableStringFieldUpdateOperationsInput | string | null
    acceptsCPR?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsIntubation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsDialysis?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsTransfusion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsArtificialNutrition?: NullableBoolFieldUpdateOperationsInput | boolean | null
    palliativeCareOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    originState?: NullableStringFieldUpdateOperationsInput | string | null
    legalBasisSummary?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutEmergencyAccessesInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileCreateNestedOneWithoutUserInput
    directives?: AdvanceDirectiveCreateNestedManyWithoutUserInput
    representatives?: RepresentativeCreateNestedManyWithoutUserInput
    panicAlerts?: PanicAlertCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmergencyAccessesInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileUncheckedCreateNestedOneWithoutUserInput
    directives?: AdvanceDirectiveUncheckedCreateNestedManyWithoutUserInput
    representatives?: RepresentativeUncheckedCreateNestedManyWithoutUserInput
    panicAlerts?: PanicAlertUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmergencyAccessesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmergencyAccessesInput, UserUncheckedCreateWithoutEmergencyAccessesInput>
  }

  export type MedicalInstitutionCreateWithoutEmergencyAccessesInput = {
    id?: string
    name: string
    type: $Enums.InstitutionType
    cluesCode?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    latitude?: number | null
    longitude?: number | null
    phone?: string | null
    emergencyPhone?: string | null
    email?: string | null
    attentionLevel?: $Enums.AttentionLevel | null
    specialties?: MedicalInstitutionCreatespecialtiesInput | string[]
    hasEmergency?: boolean
    has24Hours?: boolean
    hasICU?: boolean
    hasTrauma?: boolean
    oauthClientId?: string | null
    oauthClientSecret?: string | null
    isActive?: boolean
    isVerified?: boolean
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: MedicalStaffCreateNestedManyWithoutInstitutionInput
    insuranceNetworks?: InsuranceCompanyCreateNestedManyWithoutNetworkHospitalsInput
  }

  export type MedicalInstitutionUncheckedCreateWithoutEmergencyAccessesInput = {
    id?: string
    name: string
    type: $Enums.InstitutionType
    cluesCode?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    latitude?: number | null
    longitude?: number | null
    phone?: string | null
    emergencyPhone?: string | null
    email?: string | null
    attentionLevel?: $Enums.AttentionLevel | null
    specialties?: MedicalInstitutionCreatespecialtiesInput | string[]
    hasEmergency?: boolean
    has24Hours?: boolean
    hasICU?: boolean
    hasTrauma?: boolean
    oauthClientId?: string | null
    oauthClientSecret?: string | null
    isActive?: boolean
    isVerified?: boolean
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: MedicalStaffUncheckedCreateNestedManyWithoutInstitutionInput
    insuranceNetworks?: InsuranceCompanyUncheckedCreateNestedManyWithoutNetworkHospitalsInput
  }

  export type MedicalInstitutionCreateOrConnectWithoutEmergencyAccessesInput = {
    where: MedicalInstitutionWhereUniqueInput
    create: XOR<MedicalInstitutionCreateWithoutEmergencyAccessesInput, MedicalInstitutionUncheckedCreateWithoutEmergencyAccessesInput>
  }

  export type InsuranceCompanyCreateWithoutEmergencyAccessesInput = {
    id?: string
    name: string
    shortName?: string | null
    type: $Enums.InsuranceType
    cnsfNumber?: string | null
    rfc?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    phone?: string | null
    emergencyPhone?: string | null
    email?: string | null
    website?: string | null
    coverageTypes?: InsuranceCompanyCreatecoverageTypesInput | string[]
    networkSize?: number | null
    hasNationalCoverage?: boolean
    statesCovered?: InsuranceCompanyCreatestatesCoveredInput | string[]
    isVerified?: boolean
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    apiEnabled?: boolean
    apiEndpoint?: string | null
    logoUrl?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    plans?: InsurancePlanCreateNestedManyWithoutInsuranceInput
    networkHospitals?: MedicalInstitutionCreateNestedManyWithoutInsuranceNetworksInput
  }

  export type InsuranceCompanyUncheckedCreateWithoutEmergencyAccessesInput = {
    id?: string
    name: string
    shortName?: string | null
    type: $Enums.InsuranceType
    cnsfNumber?: string | null
    rfc?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    phone?: string | null
    emergencyPhone?: string | null
    email?: string | null
    website?: string | null
    coverageTypes?: InsuranceCompanyCreatecoverageTypesInput | string[]
    networkSize?: number | null
    hasNationalCoverage?: boolean
    statesCovered?: InsuranceCompanyCreatestatesCoveredInput | string[]
    isVerified?: boolean
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    apiEnabled?: boolean
    apiEndpoint?: string | null
    logoUrl?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    plans?: InsurancePlanUncheckedCreateNestedManyWithoutInsuranceInput
    networkHospitals?: MedicalInstitutionUncheckedCreateNestedManyWithoutInsuranceNetworksInput
  }

  export type InsuranceCompanyCreateOrConnectWithoutEmergencyAccessesInput = {
    where: InsuranceCompanyWhereUniqueInput
    create: XOR<InsuranceCompanyCreateWithoutEmergencyAccessesInput, InsuranceCompanyUncheckedCreateWithoutEmergencyAccessesInput>
  }

  export type UserUpsertWithoutEmergencyAccessesInput = {
    update: XOR<UserUpdateWithoutEmergencyAccessesInput, UserUncheckedUpdateWithoutEmergencyAccessesInput>
    create: XOR<UserCreateWithoutEmergencyAccessesInput, UserUncheckedCreateWithoutEmergencyAccessesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmergencyAccessesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmergencyAccessesInput, UserUncheckedUpdateWithoutEmergencyAccessesInput>
  }

  export type UserUpdateWithoutEmergencyAccessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUpdateOneWithoutUserNestedInput
    directives?: AdvanceDirectiveUpdateManyWithoutUserNestedInput
    representatives?: RepresentativeUpdateManyWithoutUserNestedInput
    panicAlerts?: PanicAlertUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmergencyAccessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUncheckedUpdateOneWithoutUserNestedInput
    directives?: AdvanceDirectiveUncheckedUpdateManyWithoutUserNestedInput
    representatives?: RepresentativeUncheckedUpdateManyWithoutUserNestedInput
    panicAlerts?: PanicAlertUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MedicalInstitutionUpsertWithoutEmergencyAccessesInput = {
    update: XOR<MedicalInstitutionUpdateWithoutEmergencyAccessesInput, MedicalInstitutionUncheckedUpdateWithoutEmergencyAccessesInput>
    create: XOR<MedicalInstitutionCreateWithoutEmergencyAccessesInput, MedicalInstitutionUncheckedCreateWithoutEmergencyAccessesInput>
    where?: MedicalInstitutionWhereInput
  }

  export type MedicalInstitutionUpdateToOneWithWhereWithoutEmergencyAccessesInput = {
    where?: MedicalInstitutionWhereInput
    data: XOR<MedicalInstitutionUpdateWithoutEmergencyAccessesInput, MedicalInstitutionUncheckedUpdateWithoutEmergencyAccessesInput>
  }

  export type MedicalInstitutionUpdateWithoutEmergencyAccessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    cluesCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    attentionLevel?: NullableEnumAttentionLevelFieldUpdateOperationsInput | $Enums.AttentionLevel | null
    specialties?: MedicalInstitutionUpdatespecialtiesInput | string[]
    hasEmergency?: BoolFieldUpdateOperationsInput | boolean
    has24Hours?: BoolFieldUpdateOperationsInput | boolean
    hasICU?: BoolFieldUpdateOperationsInput | boolean
    hasTrauma?: BoolFieldUpdateOperationsInput | boolean
    oauthClientId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: MedicalStaffUpdateManyWithoutInstitutionNestedInput
    insuranceNetworks?: InsuranceCompanyUpdateManyWithoutNetworkHospitalsNestedInput
  }

  export type MedicalInstitutionUncheckedUpdateWithoutEmergencyAccessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    cluesCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    attentionLevel?: NullableEnumAttentionLevelFieldUpdateOperationsInput | $Enums.AttentionLevel | null
    specialties?: MedicalInstitutionUpdatespecialtiesInput | string[]
    hasEmergency?: BoolFieldUpdateOperationsInput | boolean
    has24Hours?: BoolFieldUpdateOperationsInput | boolean
    hasICU?: BoolFieldUpdateOperationsInput | boolean
    hasTrauma?: BoolFieldUpdateOperationsInput | boolean
    oauthClientId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: MedicalStaffUncheckedUpdateManyWithoutInstitutionNestedInput
    insuranceNetworks?: InsuranceCompanyUncheckedUpdateManyWithoutNetworkHospitalsNestedInput
  }

  export type InsuranceCompanyUpsertWithoutEmergencyAccessesInput = {
    update: XOR<InsuranceCompanyUpdateWithoutEmergencyAccessesInput, InsuranceCompanyUncheckedUpdateWithoutEmergencyAccessesInput>
    create: XOR<InsuranceCompanyCreateWithoutEmergencyAccessesInput, InsuranceCompanyUncheckedCreateWithoutEmergencyAccessesInput>
    where?: InsuranceCompanyWhereInput
  }

  export type InsuranceCompanyUpdateToOneWithWhereWithoutEmergencyAccessesInput = {
    where?: InsuranceCompanyWhereInput
    data: XOR<InsuranceCompanyUpdateWithoutEmergencyAccessesInput, InsuranceCompanyUncheckedUpdateWithoutEmergencyAccessesInput>
  }

  export type InsuranceCompanyUpdateWithoutEmergencyAccessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType
    cnsfNumber?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    coverageTypes?: InsuranceCompanyUpdatecoverageTypesInput | string[]
    networkSize?: NullableIntFieldUpdateOperationsInput | number | null
    hasNationalCoverage?: BoolFieldUpdateOperationsInput | boolean
    statesCovered?: InsuranceCompanyUpdatestatesCoveredInput | string[]
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    apiEnabled?: BoolFieldUpdateOperationsInput | boolean
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plans?: InsurancePlanUpdateManyWithoutInsuranceNestedInput
    networkHospitals?: MedicalInstitutionUpdateManyWithoutInsuranceNetworksNestedInput
  }

  export type InsuranceCompanyUncheckedUpdateWithoutEmergencyAccessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType
    cnsfNumber?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    coverageTypes?: InsuranceCompanyUpdatecoverageTypesInput | string[]
    networkSize?: NullableIntFieldUpdateOperationsInput | number | null
    hasNationalCoverage?: BoolFieldUpdateOperationsInput | boolean
    statesCovered?: InsuranceCompanyUpdatestatesCoveredInput | string[]
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    apiEnabled?: BoolFieldUpdateOperationsInput | boolean
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plans?: InsurancePlanUncheckedUpdateManyWithoutInsuranceNestedInput
    networkHospitals?: MedicalInstitutionUncheckedUpdateManyWithoutInsuranceNetworksNestedInput
  }

  export type EmergencyAccessCreateWithoutInstitutionInput = {
    id?: string
    accessorId?: string | null
    accessorName: string
    accessorRole: string
    accessorLicense?: string | null
    institutionName?: string | null
    insurancePolicyNo?: string | null
    qrTokenUsed: string
    ipAddress?: string | null
    userAgent?: string | null
    latitude?: number | null
    longitude?: number | null
    locationName?: string | null
    dataAccessed?: EmergencyAccessCreatedataAccessedInput | string[]
    representativesNotified?: EmergencyAccessCreaterepresentativesNotifiedInput | string[]
    notificationsSentAt?: Date | string | null
    accessToken?: string
    accessedAt?: Date | string
    expiresAt: Date | string
    patient: UserCreateNestedOneWithoutEmergencyAccessesInput
    insurance?: InsuranceCompanyCreateNestedOneWithoutEmergencyAccessesInput
  }

  export type EmergencyAccessUncheckedCreateWithoutInstitutionInput = {
    id?: string
    patientId: string
    accessorId?: string | null
    accessorName: string
    accessorRole: string
    accessorLicense?: string | null
    institutionName?: string | null
    insuranceId?: string | null
    insurancePolicyNo?: string | null
    qrTokenUsed: string
    ipAddress?: string | null
    userAgent?: string | null
    latitude?: number | null
    longitude?: number | null
    locationName?: string | null
    dataAccessed?: EmergencyAccessCreatedataAccessedInput | string[]
    representativesNotified?: EmergencyAccessCreaterepresentativesNotifiedInput | string[]
    notificationsSentAt?: Date | string | null
    accessToken?: string
    accessedAt?: Date | string
    expiresAt: Date | string
  }

  export type EmergencyAccessCreateOrConnectWithoutInstitutionInput = {
    where: EmergencyAccessWhereUniqueInput
    create: XOR<EmergencyAccessCreateWithoutInstitutionInput, EmergencyAccessUncheckedCreateWithoutInstitutionInput>
  }

  export type EmergencyAccessCreateManyInstitutionInputEnvelope = {
    data: EmergencyAccessCreateManyInstitutionInput | EmergencyAccessCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type MedicalStaffCreateWithoutInstitutionInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.StaffRole
    license?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type MedicalStaffUncheckedCreateWithoutInstitutionInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.StaffRole
    license?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type MedicalStaffCreateOrConnectWithoutInstitutionInput = {
    where: MedicalStaffWhereUniqueInput
    create: XOR<MedicalStaffCreateWithoutInstitutionInput, MedicalStaffUncheckedCreateWithoutInstitutionInput>
  }

  export type MedicalStaffCreateManyInstitutionInputEnvelope = {
    data: MedicalStaffCreateManyInstitutionInput | MedicalStaffCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type InsuranceCompanyCreateWithoutNetworkHospitalsInput = {
    id?: string
    name: string
    shortName?: string | null
    type: $Enums.InsuranceType
    cnsfNumber?: string | null
    rfc?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    phone?: string | null
    emergencyPhone?: string | null
    email?: string | null
    website?: string | null
    coverageTypes?: InsuranceCompanyCreatecoverageTypesInput | string[]
    networkSize?: number | null
    hasNationalCoverage?: boolean
    statesCovered?: InsuranceCompanyCreatestatesCoveredInput | string[]
    isVerified?: boolean
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    apiEnabled?: boolean
    apiEndpoint?: string | null
    logoUrl?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    plans?: InsurancePlanCreateNestedManyWithoutInsuranceInput
    emergencyAccesses?: EmergencyAccessCreateNestedManyWithoutInsuranceInput
  }

  export type InsuranceCompanyUncheckedCreateWithoutNetworkHospitalsInput = {
    id?: string
    name: string
    shortName?: string | null
    type: $Enums.InsuranceType
    cnsfNumber?: string | null
    rfc?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    phone?: string | null
    emergencyPhone?: string | null
    email?: string | null
    website?: string | null
    coverageTypes?: InsuranceCompanyCreatecoverageTypesInput | string[]
    networkSize?: number | null
    hasNationalCoverage?: boolean
    statesCovered?: InsuranceCompanyCreatestatesCoveredInput | string[]
    isVerified?: boolean
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    apiEnabled?: boolean
    apiEndpoint?: string | null
    logoUrl?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    plans?: InsurancePlanUncheckedCreateNestedManyWithoutInsuranceInput
    emergencyAccesses?: EmergencyAccessUncheckedCreateNestedManyWithoutInsuranceInput
  }

  export type InsuranceCompanyCreateOrConnectWithoutNetworkHospitalsInput = {
    where: InsuranceCompanyWhereUniqueInput
    create: XOR<InsuranceCompanyCreateWithoutNetworkHospitalsInput, InsuranceCompanyUncheckedCreateWithoutNetworkHospitalsInput>
  }

  export type EmergencyAccessUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: EmergencyAccessWhereUniqueInput
    update: XOR<EmergencyAccessUpdateWithoutInstitutionInput, EmergencyAccessUncheckedUpdateWithoutInstitutionInput>
    create: XOR<EmergencyAccessCreateWithoutInstitutionInput, EmergencyAccessUncheckedCreateWithoutInstitutionInput>
  }

  export type EmergencyAccessUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: EmergencyAccessWhereUniqueInput
    data: XOR<EmergencyAccessUpdateWithoutInstitutionInput, EmergencyAccessUncheckedUpdateWithoutInstitutionInput>
  }

  export type EmergencyAccessUpdateManyWithWhereWithoutInstitutionInput = {
    where: EmergencyAccessScalarWhereInput
    data: XOR<EmergencyAccessUpdateManyMutationInput, EmergencyAccessUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type MedicalStaffUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: MedicalStaffWhereUniqueInput
    update: XOR<MedicalStaffUpdateWithoutInstitutionInput, MedicalStaffUncheckedUpdateWithoutInstitutionInput>
    create: XOR<MedicalStaffCreateWithoutInstitutionInput, MedicalStaffUncheckedCreateWithoutInstitutionInput>
  }

  export type MedicalStaffUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: MedicalStaffWhereUniqueInput
    data: XOR<MedicalStaffUpdateWithoutInstitutionInput, MedicalStaffUncheckedUpdateWithoutInstitutionInput>
  }

  export type MedicalStaffUpdateManyWithWhereWithoutInstitutionInput = {
    where: MedicalStaffScalarWhereInput
    data: XOR<MedicalStaffUpdateManyMutationInput, MedicalStaffUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type MedicalStaffScalarWhereInput = {
    AND?: MedicalStaffScalarWhereInput | MedicalStaffScalarWhereInput[]
    OR?: MedicalStaffScalarWhereInput[]
    NOT?: MedicalStaffScalarWhereInput | MedicalStaffScalarWhereInput[]
    id?: StringFilter<"MedicalStaff"> | string
    institutionId?: StringFilter<"MedicalStaff"> | string
    name?: StringFilter<"MedicalStaff"> | string
    email?: StringFilter<"MedicalStaff"> | string
    passwordHash?: StringFilter<"MedicalStaff"> | string
    role?: EnumStaffRoleFilter<"MedicalStaff"> | $Enums.StaffRole
    license?: StringNullableFilter<"MedicalStaff"> | string | null
    isActive?: BoolFilter<"MedicalStaff"> | boolean
    createdAt?: DateTimeFilter<"MedicalStaff"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalStaff"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"MedicalStaff"> | Date | string | null
  }

  export type InsuranceCompanyUpsertWithWhereUniqueWithoutNetworkHospitalsInput = {
    where: InsuranceCompanyWhereUniqueInput
    update: XOR<InsuranceCompanyUpdateWithoutNetworkHospitalsInput, InsuranceCompanyUncheckedUpdateWithoutNetworkHospitalsInput>
    create: XOR<InsuranceCompanyCreateWithoutNetworkHospitalsInput, InsuranceCompanyUncheckedCreateWithoutNetworkHospitalsInput>
  }

  export type InsuranceCompanyUpdateWithWhereUniqueWithoutNetworkHospitalsInput = {
    where: InsuranceCompanyWhereUniqueInput
    data: XOR<InsuranceCompanyUpdateWithoutNetworkHospitalsInput, InsuranceCompanyUncheckedUpdateWithoutNetworkHospitalsInput>
  }

  export type InsuranceCompanyUpdateManyWithWhereWithoutNetworkHospitalsInput = {
    where: InsuranceCompanyScalarWhereInput
    data: XOR<InsuranceCompanyUpdateManyMutationInput, InsuranceCompanyUncheckedUpdateManyWithoutNetworkHospitalsInput>
  }

  export type InsuranceCompanyScalarWhereInput = {
    AND?: InsuranceCompanyScalarWhereInput | InsuranceCompanyScalarWhereInput[]
    OR?: InsuranceCompanyScalarWhereInput[]
    NOT?: InsuranceCompanyScalarWhereInput | InsuranceCompanyScalarWhereInput[]
    id?: StringFilter<"InsuranceCompany"> | string
    name?: StringFilter<"InsuranceCompany"> | string
    shortName?: StringNullableFilter<"InsuranceCompany"> | string | null
    type?: EnumInsuranceTypeFilter<"InsuranceCompany"> | $Enums.InsuranceType
    cnsfNumber?: StringNullableFilter<"InsuranceCompany"> | string | null
    rfc?: StringNullableFilter<"InsuranceCompany"> | string | null
    address?: StringNullableFilter<"InsuranceCompany"> | string | null
    city?: StringNullableFilter<"InsuranceCompany"> | string | null
    state?: StringNullableFilter<"InsuranceCompany"> | string | null
    zipCode?: StringNullableFilter<"InsuranceCompany"> | string | null
    phone?: StringNullableFilter<"InsuranceCompany"> | string | null
    emergencyPhone?: StringNullableFilter<"InsuranceCompany"> | string | null
    email?: StringNullableFilter<"InsuranceCompany"> | string | null
    website?: StringNullableFilter<"InsuranceCompany"> | string | null
    coverageTypes?: StringNullableListFilter<"InsuranceCompany">
    networkSize?: IntNullableFilter<"InsuranceCompany"> | number | null
    hasNationalCoverage?: BoolFilter<"InsuranceCompany"> | boolean
    statesCovered?: StringNullableListFilter<"InsuranceCompany">
    isVerified?: BoolFilter<"InsuranceCompany"> | boolean
    verifiedAt?: DateTimeNullableFilter<"InsuranceCompany"> | Date | string | null
    verifiedBy?: StringNullableFilter<"InsuranceCompany"> | string | null
    apiEnabled?: BoolFilter<"InsuranceCompany"> | boolean
    apiEndpoint?: StringNullableFilter<"InsuranceCompany"> | string | null
    logoUrl?: StringNullableFilter<"InsuranceCompany"> | string | null
    description?: StringNullableFilter<"InsuranceCompany"> | string | null
    isActive?: BoolFilter<"InsuranceCompany"> | boolean
    createdAt?: DateTimeFilter<"InsuranceCompany"> | Date | string
    updatedAt?: DateTimeFilter<"InsuranceCompany"> | Date | string
  }

  export type InsurancePlanCreateWithoutInsuranceInput = {
    id?: string
    name: string
    code?: string | null
    sumAssured?: number | null
    deductible?: number | null
    coinsurance?: number | null
    features?: InsurancePlanCreatefeaturesInput | string[]
    exclusions?: InsurancePlanCreateexclusionsInput | string[]
    hospitalLevel?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsurancePlanUncheckedCreateWithoutInsuranceInput = {
    id?: string
    name: string
    code?: string | null
    sumAssured?: number | null
    deductible?: number | null
    coinsurance?: number | null
    features?: InsurancePlanCreatefeaturesInput | string[]
    exclusions?: InsurancePlanCreateexclusionsInput | string[]
    hospitalLevel?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsurancePlanCreateOrConnectWithoutInsuranceInput = {
    where: InsurancePlanWhereUniqueInput
    create: XOR<InsurancePlanCreateWithoutInsuranceInput, InsurancePlanUncheckedCreateWithoutInsuranceInput>
  }

  export type InsurancePlanCreateManyInsuranceInputEnvelope = {
    data: InsurancePlanCreateManyInsuranceInput | InsurancePlanCreateManyInsuranceInput[]
    skipDuplicates?: boolean
  }

  export type MedicalInstitutionCreateWithoutInsuranceNetworksInput = {
    id?: string
    name: string
    type: $Enums.InstitutionType
    cluesCode?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    latitude?: number | null
    longitude?: number | null
    phone?: string | null
    emergencyPhone?: string | null
    email?: string | null
    attentionLevel?: $Enums.AttentionLevel | null
    specialties?: MedicalInstitutionCreatespecialtiesInput | string[]
    hasEmergency?: boolean
    has24Hours?: boolean
    hasICU?: boolean
    hasTrauma?: boolean
    oauthClientId?: string | null
    oauthClientSecret?: string | null
    isActive?: boolean
    isVerified?: boolean
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emergencyAccesses?: EmergencyAccessCreateNestedManyWithoutInstitutionInput
    staff?: MedicalStaffCreateNestedManyWithoutInstitutionInput
  }

  export type MedicalInstitutionUncheckedCreateWithoutInsuranceNetworksInput = {
    id?: string
    name: string
    type: $Enums.InstitutionType
    cluesCode?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    latitude?: number | null
    longitude?: number | null
    phone?: string | null
    emergencyPhone?: string | null
    email?: string | null
    attentionLevel?: $Enums.AttentionLevel | null
    specialties?: MedicalInstitutionCreatespecialtiesInput | string[]
    hasEmergency?: boolean
    has24Hours?: boolean
    hasICU?: boolean
    hasTrauma?: boolean
    oauthClientId?: string | null
    oauthClientSecret?: string | null
    isActive?: boolean
    isVerified?: boolean
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emergencyAccesses?: EmergencyAccessUncheckedCreateNestedManyWithoutInstitutionInput
    staff?: MedicalStaffUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type MedicalInstitutionCreateOrConnectWithoutInsuranceNetworksInput = {
    where: MedicalInstitutionWhereUniqueInput
    create: XOR<MedicalInstitutionCreateWithoutInsuranceNetworksInput, MedicalInstitutionUncheckedCreateWithoutInsuranceNetworksInput>
  }

  export type EmergencyAccessCreateWithoutInsuranceInput = {
    id?: string
    accessorId?: string | null
    accessorName: string
    accessorRole: string
    accessorLicense?: string | null
    institutionName?: string | null
    insurancePolicyNo?: string | null
    qrTokenUsed: string
    ipAddress?: string | null
    userAgent?: string | null
    latitude?: number | null
    longitude?: number | null
    locationName?: string | null
    dataAccessed?: EmergencyAccessCreatedataAccessedInput | string[]
    representativesNotified?: EmergencyAccessCreaterepresentativesNotifiedInput | string[]
    notificationsSentAt?: Date | string | null
    accessToken?: string
    accessedAt?: Date | string
    expiresAt: Date | string
    patient: UserCreateNestedOneWithoutEmergencyAccessesInput
    institution?: MedicalInstitutionCreateNestedOneWithoutEmergencyAccessesInput
  }

  export type EmergencyAccessUncheckedCreateWithoutInsuranceInput = {
    id?: string
    patientId: string
    accessorId?: string | null
    accessorName: string
    accessorRole: string
    accessorLicense?: string | null
    institutionId?: string | null
    institutionName?: string | null
    insurancePolicyNo?: string | null
    qrTokenUsed: string
    ipAddress?: string | null
    userAgent?: string | null
    latitude?: number | null
    longitude?: number | null
    locationName?: string | null
    dataAccessed?: EmergencyAccessCreatedataAccessedInput | string[]
    representativesNotified?: EmergencyAccessCreaterepresentativesNotifiedInput | string[]
    notificationsSentAt?: Date | string | null
    accessToken?: string
    accessedAt?: Date | string
    expiresAt: Date | string
  }

  export type EmergencyAccessCreateOrConnectWithoutInsuranceInput = {
    where: EmergencyAccessWhereUniqueInput
    create: XOR<EmergencyAccessCreateWithoutInsuranceInput, EmergencyAccessUncheckedCreateWithoutInsuranceInput>
  }

  export type EmergencyAccessCreateManyInsuranceInputEnvelope = {
    data: EmergencyAccessCreateManyInsuranceInput | EmergencyAccessCreateManyInsuranceInput[]
    skipDuplicates?: boolean
  }

  export type InsurancePlanUpsertWithWhereUniqueWithoutInsuranceInput = {
    where: InsurancePlanWhereUniqueInput
    update: XOR<InsurancePlanUpdateWithoutInsuranceInput, InsurancePlanUncheckedUpdateWithoutInsuranceInput>
    create: XOR<InsurancePlanCreateWithoutInsuranceInput, InsurancePlanUncheckedCreateWithoutInsuranceInput>
  }

  export type InsurancePlanUpdateWithWhereUniqueWithoutInsuranceInput = {
    where: InsurancePlanWhereUniqueInput
    data: XOR<InsurancePlanUpdateWithoutInsuranceInput, InsurancePlanUncheckedUpdateWithoutInsuranceInput>
  }

  export type InsurancePlanUpdateManyWithWhereWithoutInsuranceInput = {
    where: InsurancePlanScalarWhereInput
    data: XOR<InsurancePlanUpdateManyMutationInput, InsurancePlanUncheckedUpdateManyWithoutInsuranceInput>
  }

  export type InsurancePlanScalarWhereInput = {
    AND?: InsurancePlanScalarWhereInput | InsurancePlanScalarWhereInput[]
    OR?: InsurancePlanScalarWhereInput[]
    NOT?: InsurancePlanScalarWhereInput | InsurancePlanScalarWhereInput[]
    id?: StringFilter<"InsurancePlan"> | string
    insuranceId?: StringFilter<"InsurancePlan"> | string
    name?: StringFilter<"InsurancePlan"> | string
    code?: StringNullableFilter<"InsurancePlan"> | string | null
    sumAssured?: FloatNullableFilter<"InsurancePlan"> | number | null
    deductible?: FloatNullableFilter<"InsurancePlan"> | number | null
    coinsurance?: FloatNullableFilter<"InsurancePlan"> | number | null
    features?: StringNullableListFilter<"InsurancePlan">
    exclusions?: StringNullableListFilter<"InsurancePlan">
    hospitalLevel?: StringNullableFilter<"InsurancePlan"> | string | null
    isActive?: BoolFilter<"InsurancePlan"> | boolean
    createdAt?: DateTimeFilter<"InsurancePlan"> | Date | string
    updatedAt?: DateTimeFilter<"InsurancePlan"> | Date | string
  }

  export type MedicalInstitutionUpsertWithWhereUniqueWithoutInsuranceNetworksInput = {
    where: MedicalInstitutionWhereUniqueInput
    update: XOR<MedicalInstitutionUpdateWithoutInsuranceNetworksInput, MedicalInstitutionUncheckedUpdateWithoutInsuranceNetworksInput>
    create: XOR<MedicalInstitutionCreateWithoutInsuranceNetworksInput, MedicalInstitutionUncheckedCreateWithoutInsuranceNetworksInput>
  }

  export type MedicalInstitutionUpdateWithWhereUniqueWithoutInsuranceNetworksInput = {
    where: MedicalInstitutionWhereUniqueInput
    data: XOR<MedicalInstitutionUpdateWithoutInsuranceNetworksInput, MedicalInstitutionUncheckedUpdateWithoutInsuranceNetworksInput>
  }

  export type MedicalInstitutionUpdateManyWithWhereWithoutInsuranceNetworksInput = {
    where: MedicalInstitutionScalarWhereInput
    data: XOR<MedicalInstitutionUpdateManyMutationInput, MedicalInstitutionUncheckedUpdateManyWithoutInsuranceNetworksInput>
  }

  export type MedicalInstitutionScalarWhereInput = {
    AND?: MedicalInstitutionScalarWhereInput | MedicalInstitutionScalarWhereInput[]
    OR?: MedicalInstitutionScalarWhereInput[]
    NOT?: MedicalInstitutionScalarWhereInput | MedicalInstitutionScalarWhereInput[]
    id?: StringFilter<"MedicalInstitution"> | string
    name?: StringFilter<"MedicalInstitution"> | string
    type?: EnumInstitutionTypeFilter<"MedicalInstitution"> | $Enums.InstitutionType
    cluesCode?: StringNullableFilter<"MedicalInstitution"> | string | null
    address?: StringNullableFilter<"MedicalInstitution"> | string | null
    city?: StringNullableFilter<"MedicalInstitution"> | string | null
    state?: StringNullableFilter<"MedicalInstitution"> | string | null
    zipCode?: StringNullableFilter<"MedicalInstitution"> | string | null
    latitude?: FloatNullableFilter<"MedicalInstitution"> | number | null
    longitude?: FloatNullableFilter<"MedicalInstitution"> | number | null
    phone?: StringNullableFilter<"MedicalInstitution"> | string | null
    emergencyPhone?: StringNullableFilter<"MedicalInstitution"> | string | null
    email?: StringNullableFilter<"MedicalInstitution"> | string | null
    attentionLevel?: EnumAttentionLevelNullableFilter<"MedicalInstitution"> | $Enums.AttentionLevel | null
    specialties?: StringNullableListFilter<"MedicalInstitution">
    hasEmergency?: BoolFilter<"MedicalInstitution"> | boolean
    has24Hours?: BoolFilter<"MedicalInstitution"> | boolean
    hasICU?: BoolFilter<"MedicalInstitution"> | boolean
    hasTrauma?: BoolFilter<"MedicalInstitution"> | boolean
    oauthClientId?: StringNullableFilter<"MedicalInstitution"> | string | null
    oauthClientSecret?: StringNullableFilter<"MedicalInstitution"> | string | null
    isActive?: BoolFilter<"MedicalInstitution"> | boolean
    isVerified?: BoolFilter<"MedicalInstitution"> | boolean
    verifiedAt?: DateTimeNullableFilter<"MedicalInstitution"> | Date | string | null
    createdAt?: DateTimeFilter<"MedicalInstitution"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalInstitution"> | Date | string
  }

  export type EmergencyAccessUpsertWithWhereUniqueWithoutInsuranceInput = {
    where: EmergencyAccessWhereUniqueInput
    update: XOR<EmergencyAccessUpdateWithoutInsuranceInput, EmergencyAccessUncheckedUpdateWithoutInsuranceInput>
    create: XOR<EmergencyAccessCreateWithoutInsuranceInput, EmergencyAccessUncheckedCreateWithoutInsuranceInput>
  }

  export type EmergencyAccessUpdateWithWhereUniqueWithoutInsuranceInput = {
    where: EmergencyAccessWhereUniqueInput
    data: XOR<EmergencyAccessUpdateWithoutInsuranceInput, EmergencyAccessUncheckedUpdateWithoutInsuranceInput>
  }

  export type EmergencyAccessUpdateManyWithWhereWithoutInsuranceInput = {
    where: EmergencyAccessScalarWhereInput
    data: XOR<EmergencyAccessUpdateManyMutationInput, EmergencyAccessUncheckedUpdateManyWithoutInsuranceInput>
  }

  export type InsuranceCompanyCreateWithoutPlansInput = {
    id?: string
    name: string
    shortName?: string | null
    type: $Enums.InsuranceType
    cnsfNumber?: string | null
    rfc?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    phone?: string | null
    emergencyPhone?: string | null
    email?: string | null
    website?: string | null
    coverageTypes?: InsuranceCompanyCreatecoverageTypesInput | string[]
    networkSize?: number | null
    hasNationalCoverage?: boolean
    statesCovered?: InsuranceCompanyCreatestatesCoveredInput | string[]
    isVerified?: boolean
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    apiEnabled?: boolean
    apiEndpoint?: string | null
    logoUrl?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    networkHospitals?: MedicalInstitutionCreateNestedManyWithoutInsuranceNetworksInput
    emergencyAccesses?: EmergencyAccessCreateNestedManyWithoutInsuranceInput
  }

  export type InsuranceCompanyUncheckedCreateWithoutPlansInput = {
    id?: string
    name: string
    shortName?: string | null
    type: $Enums.InsuranceType
    cnsfNumber?: string | null
    rfc?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    phone?: string | null
    emergencyPhone?: string | null
    email?: string | null
    website?: string | null
    coverageTypes?: InsuranceCompanyCreatecoverageTypesInput | string[]
    networkSize?: number | null
    hasNationalCoverage?: boolean
    statesCovered?: InsuranceCompanyCreatestatesCoveredInput | string[]
    isVerified?: boolean
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    apiEnabled?: boolean
    apiEndpoint?: string | null
    logoUrl?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    networkHospitals?: MedicalInstitutionUncheckedCreateNestedManyWithoutInsuranceNetworksInput
    emergencyAccesses?: EmergencyAccessUncheckedCreateNestedManyWithoutInsuranceInput
  }

  export type InsuranceCompanyCreateOrConnectWithoutPlansInput = {
    where: InsuranceCompanyWhereUniqueInput
    create: XOR<InsuranceCompanyCreateWithoutPlansInput, InsuranceCompanyUncheckedCreateWithoutPlansInput>
  }

  export type InsuranceCompanyUpsertWithoutPlansInput = {
    update: XOR<InsuranceCompanyUpdateWithoutPlansInput, InsuranceCompanyUncheckedUpdateWithoutPlansInput>
    create: XOR<InsuranceCompanyCreateWithoutPlansInput, InsuranceCompanyUncheckedCreateWithoutPlansInput>
    where?: InsuranceCompanyWhereInput
  }

  export type InsuranceCompanyUpdateToOneWithWhereWithoutPlansInput = {
    where?: InsuranceCompanyWhereInput
    data: XOR<InsuranceCompanyUpdateWithoutPlansInput, InsuranceCompanyUncheckedUpdateWithoutPlansInput>
  }

  export type InsuranceCompanyUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType
    cnsfNumber?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    coverageTypes?: InsuranceCompanyUpdatecoverageTypesInput | string[]
    networkSize?: NullableIntFieldUpdateOperationsInput | number | null
    hasNationalCoverage?: BoolFieldUpdateOperationsInput | boolean
    statesCovered?: InsuranceCompanyUpdatestatesCoveredInput | string[]
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    apiEnabled?: BoolFieldUpdateOperationsInput | boolean
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    networkHospitals?: MedicalInstitutionUpdateManyWithoutInsuranceNetworksNestedInput
    emergencyAccesses?: EmergencyAccessUpdateManyWithoutInsuranceNestedInput
  }

  export type InsuranceCompanyUncheckedUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType
    cnsfNumber?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    coverageTypes?: InsuranceCompanyUpdatecoverageTypesInput | string[]
    networkSize?: NullableIntFieldUpdateOperationsInput | number | null
    hasNationalCoverage?: BoolFieldUpdateOperationsInput | boolean
    statesCovered?: InsuranceCompanyUpdatestatesCoveredInput | string[]
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    apiEnabled?: BoolFieldUpdateOperationsInput | boolean
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    networkHospitals?: MedicalInstitutionUncheckedUpdateManyWithoutInsuranceNetworksNestedInput
    emergencyAccesses?: EmergencyAccessUncheckedUpdateManyWithoutInsuranceNestedInput
  }

  export type MedicalInstitutionCreateWithoutStaffInput = {
    id?: string
    name: string
    type: $Enums.InstitutionType
    cluesCode?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    latitude?: number | null
    longitude?: number | null
    phone?: string | null
    emergencyPhone?: string | null
    email?: string | null
    attentionLevel?: $Enums.AttentionLevel | null
    specialties?: MedicalInstitutionCreatespecialtiesInput | string[]
    hasEmergency?: boolean
    has24Hours?: boolean
    hasICU?: boolean
    hasTrauma?: boolean
    oauthClientId?: string | null
    oauthClientSecret?: string | null
    isActive?: boolean
    isVerified?: boolean
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emergencyAccesses?: EmergencyAccessCreateNestedManyWithoutInstitutionInput
    insuranceNetworks?: InsuranceCompanyCreateNestedManyWithoutNetworkHospitalsInput
  }

  export type MedicalInstitutionUncheckedCreateWithoutStaffInput = {
    id?: string
    name: string
    type: $Enums.InstitutionType
    cluesCode?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    latitude?: number | null
    longitude?: number | null
    phone?: string | null
    emergencyPhone?: string | null
    email?: string | null
    attentionLevel?: $Enums.AttentionLevel | null
    specialties?: MedicalInstitutionCreatespecialtiesInput | string[]
    hasEmergency?: boolean
    has24Hours?: boolean
    hasICU?: boolean
    hasTrauma?: boolean
    oauthClientId?: string | null
    oauthClientSecret?: string | null
    isActive?: boolean
    isVerified?: boolean
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emergencyAccesses?: EmergencyAccessUncheckedCreateNestedManyWithoutInstitutionInput
    insuranceNetworks?: InsuranceCompanyUncheckedCreateNestedManyWithoutNetworkHospitalsInput
  }

  export type MedicalInstitutionCreateOrConnectWithoutStaffInput = {
    where: MedicalInstitutionWhereUniqueInput
    create: XOR<MedicalInstitutionCreateWithoutStaffInput, MedicalInstitutionUncheckedCreateWithoutStaffInput>
  }

  export type MedicalInstitutionUpsertWithoutStaffInput = {
    update: XOR<MedicalInstitutionUpdateWithoutStaffInput, MedicalInstitutionUncheckedUpdateWithoutStaffInput>
    create: XOR<MedicalInstitutionCreateWithoutStaffInput, MedicalInstitutionUncheckedCreateWithoutStaffInput>
    where?: MedicalInstitutionWhereInput
  }

  export type MedicalInstitutionUpdateToOneWithWhereWithoutStaffInput = {
    where?: MedicalInstitutionWhereInput
    data: XOR<MedicalInstitutionUpdateWithoutStaffInput, MedicalInstitutionUncheckedUpdateWithoutStaffInput>
  }

  export type MedicalInstitutionUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    cluesCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    attentionLevel?: NullableEnumAttentionLevelFieldUpdateOperationsInput | $Enums.AttentionLevel | null
    specialties?: MedicalInstitutionUpdatespecialtiesInput | string[]
    hasEmergency?: BoolFieldUpdateOperationsInput | boolean
    has24Hours?: BoolFieldUpdateOperationsInput | boolean
    hasICU?: BoolFieldUpdateOperationsInput | boolean
    hasTrauma?: BoolFieldUpdateOperationsInput | boolean
    oauthClientId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emergencyAccesses?: EmergencyAccessUpdateManyWithoutInstitutionNestedInput
    insuranceNetworks?: InsuranceCompanyUpdateManyWithoutNetworkHospitalsNestedInput
  }

  export type MedicalInstitutionUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    cluesCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    attentionLevel?: NullableEnumAttentionLevelFieldUpdateOperationsInput | $Enums.AttentionLevel | null
    specialties?: MedicalInstitutionUpdatespecialtiesInput | string[]
    hasEmergency?: BoolFieldUpdateOperationsInput | boolean
    has24Hours?: BoolFieldUpdateOperationsInput | boolean
    hasICU?: BoolFieldUpdateOperationsInput | boolean
    hasTrauma?: BoolFieldUpdateOperationsInput | boolean
    oauthClientId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emergencyAccesses?: EmergencyAccessUncheckedUpdateManyWithoutInstitutionNestedInput
    insuranceNetworks?: InsuranceCompanyUncheckedUpdateManyWithoutNetworkHospitalsNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileCreateNestedOneWithoutUserInput
    directives?: AdvanceDirectiveCreateNestedManyWithoutUserInput
    representatives?: RepresentativeCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessCreateNestedManyWithoutPatientInput
    panicAlerts?: PanicAlertCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileUncheckedCreateNestedOneWithoutUserInput
    directives?: AdvanceDirectiveUncheckedCreateNestedManyWithoutUserInput
    representatives?: RepresentativeUncheckedCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessUncheckedCreateNestedManyWithoutPatientInput
    panicAlerts?: PanicAlertUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUpdateOneWithoutUserNestedInput
    directives?: AdvanceDirectiveUpdateManyWithoutUserNestedInput
    representatives?: RepresentativeUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUpdateManyWithoutPatientNestedInput
    panicAlerts?: PanicAlertUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUncheckedUpdateOneWithoutUserNestedInput
    directives?: AdvanceDirectiveUncheckedUpdateManyWithoutUserNestedInput
    representatives?: RepresentativeUncheckedUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUncheckedUpdateManyWithoutPatientNestedInput
    panicAlerts?: PanicAlertUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPanicAlertsInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileCreateNestedOneWithoutUserInput
    directives?: AdvanceDirectiveCreateNestedManyWithoutUserInput
    representatives?: RepresentativeCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessCreateNestedManyWithoutPatientInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPanicAlertsInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileUncheckedCreateNestedOneWithoutUserInput
    directives?: AdvanceDirectiveUncheckedCreateNestedManyWithoutUserInput
    representatives?: RepresentativeUncheckedCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessUncheckedCreateNestedManyWithoutPatientInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPanicAlertsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPanicAlertsInput, UserUncheckedCreateWithoutPanicAlertsInput>
  }

  export type UserUpsertWithoutPanicAlertsInput = {
    update: XOR<UserUpdateWithoutPanicAlertsInput, UserUncheckedUpdateWithoutPanicAlertsInput>
    create: XOR<UserCreateWithoutPanicAlertsInput, UserUncheckedCreateWithoutPanicAlertsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPanicAlertsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPanicAlertsInput, UserUncheckedUpdateWithoutPanicAlertsInput>
  }

  export type UserUpdateWithoutPanicAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUpdateOneWithoutUserNestedInput
    directives?: AdvanceDirectiveUpdateManyWithoutUserNestedInput
    representatives?: RepresentativeUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUpdateManyWithoutPatientNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPanicAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUncheckedUpdateOneWithoutUserNestedInput
    directives?: AdvanceDirectiveUncheckedUpdateManyWithoutUserNestedInput
    representatives?: RepresentativeUncheckedUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUncheckedUpdateManyWithoutPatientNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AdminSessionCreateWithoutAdminInput = {
    id?: string
    refreshToken: string
    userAgent?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type AdminSessionUncheckedCreateWithoutAdminInput = {
    id?: string
    refreshToken: string
    userAgent?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type AdminSessionCreateOrConnectWithoutAdminInput = {
    where: AdminSessionWhereUniqueInput
    create: XOR<AdminSessionCreateWithoutAdminInput, AdminSessionUncheckedCreateWithoutAdminInput>
  }

  export type AdminSessionCreateManyAdminInputEnvelope = {
    data: AdminSessionCreateManyAdminInput | AdminSessionCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminAuditLogCreateWithoutAdminInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AdminAuditLogUncheckedCreateWithoutAdminInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AdminAuditLogCreateOrConnectWithoutAdminInput = {
    where: AdminAuditLogWhereUniqueInput
    create: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput>
  }

  export type AdminAuditLogCreateManyAdminInputEnvelope = {
    data: AdminAuditLogCreateManyAdminInput | AdminAuditLogCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminSessionUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminSessionWhereUniqueInput
    update: XOR<AdminSessionUpdateWithoutAdminInput, AdminSessionUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminSessionCreateWithoutAdminInput, AdminSessionUncheckedCreateWithoutAdminInput>
  }

  export type AdminSessionUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminSessionWhereUniqueInput
    data: XOR<AdminSessionUpdateWithoutAdminInput, AdminSessionUncheckedUpdateWithoutAdminInput>
  }

  export type AdminSessionUpdateManyWithWhereWithoutAdminInput = {
    where: AdminSessionScalarWhereInput
    data: XOR<AdminSessionUpdateManyMutationInput, AdminSessionUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminSessionScalarWhereInput = {
    AND?: AdminSessionScalarWhereInput | AdminSessionScalarWhereInput[]
    OR?: AdminSessionScalarWhereInput[]
    NOT?: AdminSessionScalarWhereInput | AdminSessionScalarWhereInput[]
    id?: StringFilter<"AdminSession"> | string
    adminId?: StringFilter<"AdminSession"> | string
    refreshToken?: StringFilter<"AdminSession"> | string
    userAgent?: StringNullableFilter<"AdminSession"> | string | null
    ipAddress?: StringNullableFilter<"AdminSession"> | string | null
    expiresAt?: DateTimeFilter<"AdminSession"> | Date | string
    createdAt?: DateTimeFilter<"AdminSession"> | Date | string
  }

  export type AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminAuditLogWhereUniqueInput
    update: XOR<AdminAuditLogUpdateWithoutAdminInput, AdminAuditLogUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput>
  }

  export type AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminAuditLogWhereUniqueInput
    data: XOR<AdminAuditLogUpdateWithoutAdminInput, AdminAuditLogUncheckedUpdateWithoutAdminInput>
  }

  export type AdminAuditLogUpdateManyWithWhereWithoutAdminInput = {
    where: AdminAuditLogScalarWhereInput
    data: XOR<AdminAuditLogUpdateManyMutationInput, AdminAuditLogUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminAuditLogScalarWhereInput = {
    AND?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
    OR?: AdminAuditLogScalarWhereInput[]
    NOT?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
    id?: StringFilter<"AdminAuditLog"> | string
    adminId?: StringFilter<"AdminAuditLog"> | string
    action?: StringFilter<"AdminAuditLog"> | string
    resource?: StringFilter<"AdminAuditLog"> | string
    resourceId?: StringNullableFilter<"AdminAuditLog"> | string | null
    details?: JsonNullableFilter<"AdminAuditLog">
    oldValue?: JsonNullableFilter<"AdminAuditLog">
    newValue?: JsonNullableFilter<"AdminAuditLog">
    ipAddress?: StringNullableFilter<"AdminAuditLog"> | string | null
    userAgent?: StringNullableFilter<"AdminAuditLog"> | string | null
    createdAt?: DateTimeFilter<"AdminAuditLog"> | Date | string
  }

  export type AdminUserCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role?: $Enums.AdminRole
    permissions?: AdminUserCreatepermissionsInput | string[]
    isActive?: boolean
    isSuperAdmin?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    auditActions?: AdminAuditLogCreateNestedManyWithoutAdminInput
  }

  export type AdminUserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role?: $Enums.AdminRole
    permissions?: AdminUserCreatepermissionsInput | string[]
    isActive?: boolean
    isSuperAdmin?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    auditActions?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminUserCreateOrConnectWithoutSessionsInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutSessionsInput, AdminUserUncheckedCreateWithoutSessionsInput>
  }

  export type AdminUserUpsertWithoutSessionsInput = {
    update: XOR<AdminUserUpdateWithoutSessionsInput, AdminUserUncheckedUpdateWithoutSessionsInput>
    create: XOR<AdminUserCreateWithoutSessionsInput, AdminUserUncheckedCreateWithoutSessionsInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutSessionsInput, AdminUserUncheckedUpdateWithoutSessionsInput>
  }

  export type AdminUserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    permissions?: AdminUserUpdatepermissionsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditActions?: AdminAuditLogUpdateManyWithoutAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    permissions?: AdminUserUpdatepermissionsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditActions?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminUserCreateWithoutAuditActionsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role?: $Enums.AdminRole
    permissions?: AdminUserCreatepermissionsInput | string[]
    isActive?: boolean
    isSuperAdmin?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    sessions?: AdminSessionCreateNestedManyWithoutAdminInput
  }

  export type AdminUserUncheckedCreateWithoutAuditActionsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role?: $Enums.AdminRole
    permissions?: AdminUserCreatepermissionsInput | string[]
    isActive?: boolean
    isSuperAdmin?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    sessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminUserCreateOrConnectWithoutAuditActionsInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutAuditActionsInput, AdminUserUncheckedCreateWithoutAuditActionsInput>
  }

  export type AdminUserUpsertWithoutAuditActionsInput = {
    update: XOR<AdminUserUpdateWithoutAuditActionsInput, AdminUserUncheckedUpdateWithoutAuditActionsInput>
    create: XOR<AdminUserCreateWithoutAuditActionsInput, AdminUserUncheckedCreateWithoutAuditActionsInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutAuditActionsInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutAuditActionsInput, AdminUserUncheckedUpdateWithoutAuditActionsInput>
  }

  export type AdminUserUpdateWithoutAuditActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    permissions?: AdminUserUpdatepermissionsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: AdminSessionUpdateManyWithoutAdminNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutAuditActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    permissions?: AdminUserUpdatepermissionsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type SubscriptionCreateWithoutPlanInput = {
    id?: string
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    billingCycle?: $Enums.BillingCycle
    status?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionInput
    payments?: PaymentCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutPlanInput = {
    id?: string
    userId: string
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    billingCycle?: $Enums.BillingCycle
    status?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionCreateManyPlanInputEnvelope = {
    data: SubscriptionCreateManyPlanInput | SubscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    planId?: StringFilter<"Subscription"> | string
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    billingCycle?: EnumBillingCycleFilter<"Subscription"> | $Enums.BillingCycle
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    trialEndsAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelReason?: StringNullableFilter<"Subscription"> | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type UserCreateWithoutSubscriptionInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileCreateNestedOneWithoutUserInput
    directives?: AdvanceDirectiveCreateNestedManyWithoutUserInput
    representatives?: RepresentativeCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessCreateNestedManyWithoutPatientInput
    panicAlerts?: PanicAlertCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileUncheckedCreateNestedOneWithoutUserInput
    directives?: AdvanceDirectiveUncheckedCreateNestedManyWithoutUserInput
    representatives?: RepresentativeUncheckedCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessUncheckedCreateNestedManyWithoutPatientInput
    panicAlerts?: PanicAlertUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
  }

  export type SubscriptionPlanCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    priceMonthly?: Decimal | DecimalJsLike | number | string | null
    priceAnnual?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    stripePriceIdMonthly?: string | null
    stripePriceIdAnnual?: string | null
    stripeProductId?: string | null
    features: JsonNullValueInput | InputJsonValue
    limits: JsonNullValueInput | InputJsonValue
    trialDays?: number
    isActive?: boolean
    isDefault?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    priceMonthly?: Decimal | DecimalJsLike | number | string | null
    priceAnnual?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    stripePriceIdMonthly?: string | null
    stripePriceIdAnnual?: string | null
    stripeProductId?: string | null
    features: JsonNullValueInput | InputJsonValue
    limits: JsonNullValueInput | InputJsonValue
    trialDays?: number
    isActive?: boolean
    isDefault?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput = {
    where: SubscriptionPlanWhereUniqueInput
    create: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
  }

  export type PaymentCreateWithoutSubscriptionInput = {
    id?: string
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    stripeInvoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod: $Enums.PaymentMethodType
    last4?: string | null
    cardBrand?: string | null
    oxxoVoucherUrl?: string | null
    oxxoExpiresAt?: Date | string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    failureCode?: string | null
    failureMessage?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
    invoice?: InvoiceCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    userId: string
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    stripeInvoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod: $Enums.PaymentMethodType
    last4?: string | null
    cardBrand?: string | null
    oxxoVoucherUrl?: string | null
    oxxoExpiresAt?: Date | string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    failureCode?: string | null
    failureMessage?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutSubscriptionInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput>
  }

  export type PaymentCreateManySubscriptionInputEnvelope = {
    data: PaymentCreateManySubscriptionInput | PaymentCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSubscriptionInput = {
    update: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UserUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUpdateOneWithoutUserNestedInput
    directives?: AdvanceDirectiveUpdateManyWithoutUserNestedInput
    representatives?: RepresentativeUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUpdateManyWithoutPatientNestedInput
    panicAlerts?: PanicAlertUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUncheckedUpdateOneWithoutUserNestedInput
    directives?: AdvanceDirectiveUncheckedUpdateManyWithoutUserNestedInput
    representatives?: RepresentativeUncheckedUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUncheckedUpdateManyWithoutPatientNestedInput
    panicAlerts?: PanicAlertUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubscriptionPlanUpsertWithoutSubscriptionsInput = {
    update: XOR<SubscriptionPlanUpdateWithoutSubscriptionsInput, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    where?: SubscriptionPlanWhereInput
  }

  export type SubscriptionPlanUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: SubscriptionPlanWhereInput
    data: XOR<SubscriptionPlanUpdateWithoutSubscriptionsInput, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlanUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceAnnual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    stripePriceIdMonthly?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceIdAnnual?: NullableStringFieldUpdateOperationsInput | string | null
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    limits?: JsonNullValueInput | InputJsonValue
    trialDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceAnnual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    stripePriceIdMonthly?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceIdAnnual?: NullableStringFieldUpdateOperationsInput | string | null
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    limits?: JsonNullValueInput | InputJsonValue
    trialDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutSubscriptionInput, PaymentUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutSubscriptionInput, PaymentUncheckedUpdateWithoutSubscriptionInput>
  }

  export type PaymentUpdateManyWithWhereWithoutSubscriptionInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type UserCreateWithoutPaymentsInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileCreateNestedOneWithoutUserInput
    directives?: AdvanceDirectiveCreateNestedManyWithoutUserInput
    representatives?: RepresentativeCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessCreateNestedManyWithoutPatientInput
    panicAlerts?: PanicAlertCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileUncheckedCreateNestedOneWithoutUserInput
    directives?: AdvanceDirectiveUncheckedCreateNestedManyWithoutUserInput
    representatives?: RepresentativeUncheckedCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessUncheckedCreateNestedManyWithoutPatientInput
    panicAlerts?: PanicAlertUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type SubscriptionCreateWithoutPaymentsInput = {
    id?: string
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    billingCycle?: $Enums.BillingCycle
    status?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionInput
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    planId: string
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    billingCycle?: $Enums.BillingCycle
    status?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutPaymentsInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceCreateWithoutPaymentInput = {
    id?: string
    facturamaInvoiceId?: string | null
    uuid?: string | null
    serie?: string | null
    folio?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    xmlUrl?: string | null
    pdfUrl?: string | null
    status?: $Enums.InvoiceStatus
    issuedAt?: Date | string | null
    cancelledAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInvoicesInput
    fiscalData?: FiscalDataCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentInput = {
    id?: string
    userId: string
    fiscalDataId?: string | null
    facturamaInvoiceId?: string | null
    uuid?: string | null
    serie?: string | null
    folio?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    xmlUrl?: string | null
    pdfUrl?: string | null
    status?: $Enums.InvoiceStatus
    issuedAt?: Date | string | null
    cancelledAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutPaymentInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentInput, InvoiceUncheckedCreateWithoutPaymentInput>
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUpdateOneWithoutUserNestedInput
    directives?: AdvanceDirectiveUpdateManyWithoutUserNestedInput
    representatives?: RepresentativeUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUpdateManyWithoutPatientNestedInput
    panicAlerts?: PanicAlertUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUncheckedUpdateOneWithoutUserNestedInput
    directives?: AdvanceDirectiveUncheckedUpdateManyWithoutUserNestedInput
    representatives?: RepresentativeUncheckedUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUncheckedUpdateManyWithoutPatientNestedInput
    panicAlerts?: PanicAlertUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubscriptionUpsertWithoutPaymentsInput = {
    update: XOR<SubscriptionUpdateWithoutPaymentsInput, SubscriptionUncheckedUpdateWithoutPaymentsInput>
    create: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutPaymentsInput, SubscriptionUncheckedUpdateWithoutPaymentsInput>
  }

  export type SubscriptionUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpsertWithoutPaymentInput = {
    update: XOR<InvoiceUpdateWithoutPaymentInput, InvoiceUncheckedUpdateWithoutPaymentInput>
    create: XOR<InvoiceCreateWithoutPaymentInput, InvoiceUncheckedCreateWithoutPaymentInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentInput, InvoiceUncheckedUpdateWithoutPaymentInput>
  }

  export type InvoiceUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    facturamaInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableStringFieldUpdateOperationsInput | string | null
    folio?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    xmlUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    fiscalData?: FiscalDataUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fiscalDataId?: NullableStringFieldUpdateOperationsInput | string | null
    facturamaInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableStringFieldUpdateOperationsInput | string | null
    folio?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    xmlUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutPaymentMethodsInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileCreateNestedOneWithoutUserInput
    directives?: AdvanceDirectiveCreateNestedManyWithoutUserInput
    representatives?: RepresentativeCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessCreateNestedManyWithoutPatientInput
    panicAlerts?: PanicAlertCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentMethodsInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileUncheckedCreateNestedOneWithoutUserInput
    directives?: AdvanceDirectiveUncheckedCreateNestedManyWithoutUserInput
    representatives?: RepresentativeUncheckedCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessUncheckedCreateNestedManyWithoutPatientInput
    panicAlerts?: PanicAlertUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentMethodsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentMethodsInput, UserUncheckedCreateWithoutPaymentMethodsInput>
  }

  export type UserUpsertWithoutPaymentMethodsInput = {
    update: XOR<UserUpdateWithoutPaymentMethodsInput, UserUncheckedUpdateWithoutPaymentMethodsInput>
    create: XOR<UserCreateWithoutPaymentMethodsInput, UserUncheckedCreateWithoutPaymentMethodsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentMethodsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentMethodsInput, UserUncheckedUpdateWithoutPaymentMethodsInput>
  }

  export type UserUpdateWithoutPaymentMethodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUpdateOneWithoutUserNestedInput
    directives?: AdvanceDirectiveUpdateManyWithoutUserNestedInput
    representatives?: RepresentativeUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUpdateManyWithoutPatientNestedInput
    panicAlerts?: PanicAlertUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentMethodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUncheckedUpdateOneWithoutUserNestedInput
    directives?: AdvanceDirectiveUncheckedUpdateManyWithoutUserNestedInput
    representatives?: RepresentativeUncheckedUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUncheckedUpdateManyWithoutPatientNestedInput
    panicAlerts?: PanicAlertUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFiscalDataInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileCreateNestedOneWithoutUserInput
    directives?: AdvanceDirectiveCreateNestedManyWithoutUserInput
    representatives?: RepresentativeCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessCreateNestedManyWithoutPatientInput
    panicAlerts?: PanicAlertCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFiscalDataInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileUncheckedCreateNestedOneWithoutUserInput
    directives?: AdvanceDirectiveUncheckedCreateNestedManyWithoutUserInput
    representatives?: RepresentativeUncheckedCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessUncheckedCreateNestedManyWithoutPatientInput
    panicAlerts?: PanicAlertUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFiscalDataInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFiscalDataInput, UserUncheckedCreateWithoutFiscalDataInput>
  }

  export type InvoiceCreateWithoutFiscalDataInput = {
    id?: string
    facturamaInvoiceId?: string | null
    uuid?: string | null
    serie?: string | null
    folio?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    xmlUrl?: string | null
    pdfUrl?: string | null
    status?: $Enums.InvoiceStatus
    issuedAt?: Date | string | null
    cancelledAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInvoicesInput
    payment: PaymentCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutFiscalDataInput = {
    id?: string
    userId: string
    paymentId: string
    facturamaInvoiceId?: string | null
    uuid?: string | null
    serie?: string | null
    folio?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    xmlUrl?: string | null
    pdfUrl?: string | null
    status?: $Enums.InvoiceStatus
    issuedAt?: Date | string | null
    cancelledAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutFiscalDataInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutFiscalDataInput, InvoiceUncheckedCreateWithoutFiscalDataInput>
  }

  export type InvoiceCreateManyFiscalDataInputEnvelope = {
    data: InvoiceCreateManyFiscalDataInput | InvoiceCreateManyFiscalDataInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutFiscalDataInput = {
    update: XOR<UserUpdateWithoutFiscalDataInput, UserUncheckedUpdateWithoutFiscalDataInput>
    create: XOR<UserCreateWithoutFiscalDataInput, UserUncheckedCreateWithoutFiscalDataInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFiscalDataInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFiscalDataInput, UserUncheckedUpdateWithoutFiscalDataInput>
  }

  export type UserUpdateWithoutFiscalDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUpdateOneWithoutUserNestedInput
    directives?: AdvanceDirectiveUpdateManyWithoutUserNestedInput
    representatives?: RepresentativeUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUpdateManyWithoutPatientNestedInput
    panicAlerts?: PanicAlertUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFiscalDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUncheckedUpdateOneWithoutUserNestedInput
    directives?: AdvanceDirectiveUncheckedUpdateManyWithoutUserNestedInput
    representatives?: RepresentativeUncheckedUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUncheckedUpdateManyWithoutPatientNestedInput
    panicAlerts?: PanicAlertUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InvoiceUpsertWithWhereUniqueWithoutFiscalDataInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutFiscalDataInput, InvoiceUncheckedUpdateWithoutFiscalDataInput>
    create: XOR<InvoiceCreateWithoutFiscalDataInput, InvoiceUncheckedCreateWithoutFiscalDataInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutFiscalDataInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutFiscalDataInput, InvoiceUncheckedUpdateWithoutFiscalDataInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutFiscalDataInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutFiscalDataInput>
  }

  export type UserCreateWithoutInvoicesInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileCreateNestedOneWithoutUserInput
    directives?: AdvanceDirectiveCreateNestedManyWithoutUserInput
    representatives?: RepresentativeCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessCreateNestedManyWithoutPatientInput
    panicAlerts?: PanicAlertCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvoicesInput = {
    id?: string
    email: string
    passwordHash: string
    curp: string
    name: string
    dateOfBirth?: Date | string | null
    sex?: string | null
    phone?: string | null
    address?: string | null
    isActive?: boolean
    isVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    resetToken?: string | null
    resetExpires?: Date | string | null
    webauthnChallenge?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    profile?: PatientProfileUncheckedCreateNestedOneWithoutUserInput
    directives?: AdvanceDirectiveUncheckedCreateNestedManyWithoutUserInput
    representatives?: RepresentativeUncheckedCreateNestedManyWithoutUserInput
    emergencyAccesses?: EmergencyAccessUncheckedCreateNestedManyWithoutPatientInput
    panicAlerts?: PanicAlertUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    webauthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fiscalData?: FiscalDataUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvoicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
  }

  export type PaymentCreateWithoutInvoiceInput = {
    id?: string
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    stripeInvoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod: $Enums.PaymentMethodType
    last4?: string | null
    cardBrand?: string | null
    oxxoVoucherUrl?: string | null
    oxxoExpiresAt?: Date | string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    failureCode?: string | null
    failureMessage?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
    subscription?: SubscriptionCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    userId: string
    subscriptionId?: string | null
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    stripeInvoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod: $Enums.PaymentMethodType
    last4?: string | null
    cardBrand?: string | null
    oxxoVoucherUrl?: string | null
    oxxoExpiresAt?: Date | string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    failureCode?: string | null
    failureMessage?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type FiscalDataCreateWithoutInvoicesInput = {
    id?: string
    rfc: string
    razonSocial: string
    regimenFiscal: string
    usoCFDI?: string
    codigoPostal: string
    calle?: string | null
    numExterior?: string | null
    numInterior?: string | null
    colonia?: string | null
    municipio?: string | null
    estado?: string | null
    emailFacturacion: string
    facturamaClientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFiscalDataInput
  }

  export type FiscalDataUncheckedCreateWithoutInvoicesInput = {
    id?: string
    userId: string
    rfc: string
    razonSocial: string
    regimenFiscal: string
    usoCFDI?: string
    codigoPostal: string
    calle?: string | null
    numExterior?: string | null
    numInterior?: string | null
    colonia?: string | null
    municipio?: string | null
    estado?: string | null
    emailFacturacion: string
    facturamaClientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FiscalDataCreateOrConnectWithoutInvoicesInput = {
    where: FiscalDataWhereUniqueInput
    create: XOR<FiscalDataCreateWithoutInvoicesInput, FiscalDataUncheckedCreateWithoutInvoicesInput>
  }

  export type UserUpsertWithoutInvoicesInput = {
    update: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUpdateOneWithoutUserNestedInput
    directives?: AdvanceDirectiveUpdateManyWithoutUserNestedInput
    representatives?: RepresentativeUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUpdateManyWithoutPatientNestedInput
    panicAlerts?: PanicAlertUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    curp?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webauthnChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: PatientProfileUncheckedUpdateOneWithoutUserNestedInput
    directives?: AdvanceDirectiveUncheckedUpdateManyWithoutUserNestedInput
    representatives?: RepresentativeUncheckedUpdateManyWithoutUserNestedInput
    emergencyAccesses?: EmergencyAccessUncheckedUpdateManyWithoutPatientNestedInput
    panicAlerts?: PanicAlertUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    webauthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fiscalData?: FiscalDataUncheckedUpdateOneWithoutUserNestedInput
  }

  export type PaymentUpsertWithoutInvoiceInput = {
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    oxxoVoucherUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oxxoExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    failureCode?: NullableStringFieldUpdateOperationsInput | string | null
    failureMessage?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    subscription?: SubscriptionUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    oxxoVoucherUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oxxoExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    failureCode?: NullableStringFieldUpdateOperationsInput | string | null
    failureMessage?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiscalDataUpsertWithoutInvoicesInput = {
    update: XOR<FiscalDataUpdateWithoutInvoicesInput, FiscalDataUncheckedUpdateWithoutInvoicesInput>
    create: XOR<FiscalDataCreateWithoutInvoicesInput, FiscalDataUncheckedCreateWithoutInvoicesInput>
    where?: FiscalDataWhereInput
  }

  export type FiscalDataUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: FiscalDataWhereInput
    data: XOR<FiscalDataUpdateWithoutInvoicesInput, FiscalDataUncheckedUpdateWithoutInvoicesInput>
  }

  export type FiscalDataUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    rfc?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    regimenFiscal?: StringFieldUpdateOperationsInput | string
    usoCFDI?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    calle?: NullableStringFieldUpdateOperationsInput | string | null
    numExterior?: NullableStringFieldUpdateOperationsInput | string | null
    numInterior?: NullableStringFieldUpdateOperationsInput | string | null
    colonia?: NullableStringFieldUpdateOperationsInput | string | null
    municipio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    emailFacturacion?: StringFieldUpdateOperationsInput | string
    facturamaClientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFiscalDataNestedInput
  }

  export type FiscalDataUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rfc?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    regimenFiscal?: StringFieldUpdateOperationsInput | string
    usoCFDI?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    calle?: NullableStringFieldUpdateOperationsInput | string | null
    numExterior?: NullableStringFieldUpdateOperationsInput | string | null
    numInterior?: NullableStringFieldUpdateOperationsInput | string | null
    colonia?: NullableStringFieldUpdateOperationsInput | string | null
    municipio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    emailFacturacion?: StringFieldUpdateOperationsInput | string
    facturamaClientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvanceDirectiveCreateManyUserInput = {
    id?: string
    type: $Enums.DirectiveType
    status?: $Enums.DirectiveStatus
    documentUrl?: string | null
    documentHash?: string | null
    originalFileName?: string | null
    nom151Sealed?: boolean
    nom151Timestamp?: Date | string | null
    nom151Certificate?: string | null
    nom151Provider?: string | null
    acceptsCPR?: boolean | null
    acceptsIntubation?: boolean | null
    acceptsDialysis?: boolean | null
    acceptsTransfusion?: boolean | null
    acceptsArtificialNutrition?: boolean | null
    palliativeCareOnly?: boolean | null
    additionalNotes?: string | null
    originState?: string | null
    legalBasisSummary?: string | null
    validatedAt?: Date | string | null
    validatedBy?: string | null
    validationMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
  }

  export type RepresentativeCreateManyUserInput = {
    id?: string
    name: string
    phone: string
    email?: string | null
    relation: string
    priority?: number
    isDonorSpokesperson?: boolean
    notifyOnEmergency?: boolean
    notifyOnAccess?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmergencyAccessCreateManyPatientInput = {
    id?: string
    accessorId?: string | null
    accessorName: string
    accessorRole: string
    accessorLicense?: string | null
    institutionId?: string | null
    institutionName?: string | null
    insuranceId?: string | null
    insurancePolicyNo?: string | null
    qrTokenUsed: string
    ipAddress?: string | null
    userAgent?: string | null
    latitude?: number | null
    longitude?: number | null
    locationName?: string | null
    dataAccessed?: EmergencyAccessCreatedataAccessedInput | string[]
    representativesNotified?: EmergencyAccessCreaterepresentativesNotifiedInput | string[]
    notificationsSentAt?: Date | string | null
    accessToken?: string
    accessedAt?: Date | string
    expiresAt: Date | string
  }

  export type PanicAlertCreateManyUserInput = {
    id?: string
    latitude: number
    longitude: number
    accuracy?: number | null
    locationName?: string | null
    status?: $Enums.PanicStatus
    message?: string | null
    cancelledAt?: Date | string | null
    resolvedAt?: Date | string | null
    nearbyHospitals?: NullableJsonNullValueInput | InputJsonValue
    notificationsSent?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    actorType: string
    actorId?: string | null
    actorName?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    refreshToken: string
    userAgent?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type WebAuthnCredentialCreateManyUserInput = {
    id?: string
    credentialId: string
    credentialPublicKey: Buffer
    counter?: bigint | number
    deviceType?: string | null
    deviceName?: string | null
    transports?: WebAuthnCredentialCreatetransportsInput | string[]
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type PaymentCreateManyUserInput = {
    id?: string
    subscriptionId?: string | null
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    stripeInvoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod: $Enums.PaymentMethodType
    last4?: string | null
    cardBrand?: string | null
    oxxoVoucherUrl?: string | null
    oxxoExpiresAt?: Date | string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    failureCode?: string | null
    failureMessage?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodCreateManyUserInput = {
    id?: string
    stripePaymentMethodId: string
    type?: $Enums.PaymentMethodType
    last4: string
    brand: string
    expMonth: number
    expYear: number
    cardholderName?: string | null
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyUserInput = {
    id?: string
    paymentId: string
    fiscalDataId?: string | null
    facturamaInvoiceId?: string | null
    uuid?: string | null
    serie?: string | null
    folio?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    xmlUrl?: string | null
    pdfUrl?: string | null
    status?: $Enums.InvoiceStatus
    issuedAt?: Date | string | null
    cancelledAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdvanceDirectiveUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDirectiveTypeFieldUpdateOperationsInput | $Enums.DirectiveType
    status?: EnumDirectiveStatusFieldUpdateOperationsInput | $Enums.DirectiveStatus
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    originalFileName?: NullableStringFieldUpdateOperationsInput | string | null
    nom151Sealed?: BoolFieldUpdateOperationsInput | boolean
    nom151Timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom151Certificate?: NullableStringFieldUpdateOperationsInput | string | null
    nom151Provider?: NullableStringFieldUpdateOperationsInput | string | null
    acceptsCPR?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsIntubation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsDialysis?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsTransfusion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsArtificialNutrition?: NullableBoolFieldUpdateOperationsInput | boolean | null
    palliativeCareOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    originState?: NullableStringFieldUpdateOperationsInput | string | null
    legalBasisSummary?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    witnesses?: WitnessUpdateManyWithoutDirectiveNestedInput
  }

  export type AdvanceDirectiveUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDirectiveTypeFieldUpdateOperationsInput | $Enums.DirectiveType
    status?: EnumDirectiveStatusFieldUpdateOperationsInput | $Enums.DirectiveStatus
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    originalFileName?: NullableStringFieldUpdateOperationsInput | string | null
    nom151Sealed?: BoolFieldUpdateOperationsInput | boolean
    nom151Timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom151Certificate?: NullableStringFieldUpdateOperationsInput | string | null
    nom151Provider?: NullableStringFieldUpdateOperationsInput | string | null
    acceptsCPR?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsIntubation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsDialysis?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsTransfusion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsArtificialNutrition?: NullableBoolFieldUpdateOperationsInput | boolean | null
    palliativeCareOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    originState?: NullableStringFieldUpdateOperationsInput | string | null
    legalBasisSummary?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    witnesses?: WitnessUncheckedUpdateManyWithoutDirectiveNestedInput
  }

  export type AdvanceDirectiveUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDirectiveTypeFieldUpdateOperationsInput | $Enums.DirectiveType
    status?: EnumDirectiveStatusFieldUpdateOperationsInput | $Enums.DirectiveStatus
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    originalFileName?: NullableStringFieldUpdateOperationsInput | string | null
    nom151Sealed?: BoolFieldUpdateOperationsInput | boolean
    nom151Timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom151Certificate?: NullableStringFieldUpdateOperationsInput | string | null
    nom151Provider?: NullableStringFieldUpdateOperationsInput | string | null
    acceptsCPR?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsIntubation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsDialysis?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsTransfusion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsArtificialNutrition?: NullableBoolFieldUpdateOperationsInput | boolean | null
    palliativeCareOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    originState?: NullableStringFieldUpdateOperationsInput | string | null
    legalBasisSummary?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RepresentativeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    relation?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    isDonorSpokesperson?: BoolFieldUpdateOperationsInput | boolean
    notifyOnEmergency?: BoolFieldUpdateOperationsInput | boolean
    notifyOnAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepresentativeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    relation?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    isDonorSpokesperson?: BoolFieldUpdateOperationsInput | boolean
    notifyOnEmergency?: BoolFieldUpdateOperationsInput | boolean
    notifyOnAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepresentativeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    relation?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    isDonorSpokesperson?: BoolFieldUpdateOperationsInput | boolean
    notifyOnEmergency?: BoolFieldUpdateOperationsInput | boolean
    notifyOnAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyAccessUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessorId?: NullableStringFieldUpdateOperationsInput | string | null
    accessorName?: StringFieldUpdateOperationsInput | string
    accessorRole?: StringFieldUpdateOperationsInput | string
    accessorLicense?: NullableStringFieldUpdateOperationsInput | string | null
    institutionName?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNo?: NullableStringFieldUpdateOperationsInput | string | null
    qrTokenUsed?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    dataAccessed?: EmergencyAccessUpdatedataAccessedInput | string[]
    representativesNotified?: EmergencyAccessUpdaterepresentativesNotifiedInput | string[]
    notificationsSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: MedicalInstitutionUpdateOneWithoutEmergencyAccessesNestedInput
    insurance?: InsuranceCompanyUpdateOneWithoutEmergencyAccessesNestedInput
  }

  export type EmergencyAccessUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessorId?: NullableStringFieldUpdateOperationsInput | string | null
    accessorName?: StringFieldUpdateOperationsInput | string
    accessorRole?: StringFieldUpdateOperationsInput | string
    accessorLicense?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionName?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNo?: NullableStringFieldUpdateOperationsInput | string | null
    qrTokenUsed?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    dataAccessed?: EmergencyAccessUpdatedataAccessedInput | string[]
    representativesNotified?: EmergencyAccessUpdaterepresentativesNotifiedInput | string[]
    notificationsSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyAccessUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessorId?: NullableStringFieldUpdateOperationsInput | string | null
    accessorName?: StringFieldUpdateOperationsInput | string
    accessorRole?: StringFieldUpdateOperationsInput | string
    accessorLicense?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionName?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNo?: NullableStringFieldUpdateOperationsInput | string | null
    qrTokenUsed?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    dataAccessed?: EmergencyAccessUpdatedataAccessedInput | string[]
    representativesNotified?: EmergencyAccessUpdaterepresentativesNotifiedInput | string[]
    notificationsSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PanicAlertUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPanicStatusFieldUpdateOperationsInput | $Enums.PanicStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nearbyHospitals?: NullableJsonNullValueInput | InputJsonValue
    notificationsSent?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PanicAlertUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPanicStatusFieldUpdateOperationsInput | $Enums.PanicStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nearbyHospitals?: NullableJsonNullValueInput | InputJsonValue
    notificationsSent?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PanicAlertUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPanicStatusFieldUpdateOperationsInput | $Enums.PanicStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nearbyHospitals?: NullableJsonNullValueInput | InputJsonValue
    notificationsSent?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorType?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    actorName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorType?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    actorName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorType?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    actorName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebAuthnCredentialUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: BytesFieldUpdateOperationsInput | Buffer
    counter?: BigIntFieldUpdateOperationsInput | bigint | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    transports?: WebAuthnCredentialUpdatetransportsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WebAuthnCredentialUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: BytesFieldUpdateOperationsInput | Buffer
    counter?: BigIntFieldUpdateOperationsInput | bigint | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    transports?: WebAuthnCredentialUpdatetransportsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WebAuthnCredentialUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: BytesFieldUpdateOperationsInput | Buffer
    counter?: BigIntFieldUpdateOperationsInput | bigint | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    transports?: WebAuthnCredentialUpdatetransportsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    oxxoVoucherUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oxxoExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    failureCode?: NullableStringFieldUpdateOperationsInput | string | null
    failureMessage?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneWithoutPaymentsNestedInput
    invoice?: InvoiceUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    oxxoVoucherUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oxxoExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    failureCode?: NullableStringFieldUpdateOperationsInput | string | null
    failureMessage?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    oxxoVoucherUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oxxoExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    failureCode?: NullableStringFieldUpdateOperationsInput | string | null
    failureMessage?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentMethodId?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    last4?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    expMonth?: IntFieldUpdateOperationsInput | number
    expYear?: IntFieldUpdateOperationsInput | number
    cardholderName?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentMethodId?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    last4?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    expMonth?: IntFieldUpdateOperationsInput | number
    expYear?: IntFieldUpdateOperationsInput | number
    cardholderName?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentMethodId?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    last4?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    expMonth?: IntFieldUpdateOperationsInput | number
    expYear?: IntFieldUpdateOperationsInput | number
    cardholderName?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    facturamaInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableStringFieldUpdateOperationsInput | string | null
    folio?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    xmlUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneRequiredWithoutInvoiceNestedInput
    fiscalData?: FiscalDataUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    fiscalDataId?: NullableStringFieldUpdateOperationsInput | string | null
    facturamaInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableStringFieldUpdateOperationsInput | string | null
    folio?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    xmlUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    fiscalDataId?: NullableStringFieldUpdateOperationsInput | string | null
    facturamaInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableStringFieldUpdateOperationsInput | string | null
    folio?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    xmlUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WitnessCreateManyDirectiveInput = {
    id?: string
    name: string
    curp?: string | null
    email?: string | null
    phone?: string | null
    ineImageUrl?: string | null
    selfieImageUrl?: string | null
    identityVerified?: boolean
    verifiedAt?: Date | string | null
    signatureImageUrl?: string | null
    signedAt?: Date | string | null
    sessionId?: string | null
    sessionRecordingUrl?: string | null
    sessionStartedAt?: Date | string | null
    sessionEndedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WitnessUpdateWithoutDirectiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ineImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    selfieImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sessionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionEndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WitnessUncheckedUpdateWithoutDirectiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ineImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    selfieImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sessionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionEndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WitnessUncheckedUpdateManyWithoutDirectiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ineImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    selfieImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionRecordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sessionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionEndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyAccessCreateManyInstitutionInput = {
    id?: string
    patientId: string
    accessorId?: string | null
    accessorName: string
    accessorRole: string
    accessorLicense?: string | null
    institutionName?: string | null
    insuranceId?: string | null
    insurancePolicyNo?: string | null
    qrTokenUsed: string
    ipAddress?: string | null
    userAgent?: string | null
    latitude?: number | null
    longitude?: number | null
    locationName?: string | null
    dataAccessed?: EmergencyAccessCreatedataAccessedInput | string[]
    representativesNotified?: EmergencyAccessCreaterepresentativesNotifiedInput | string[]
    notificationsSentAt?: Date | string | null
    accessToken?: string
    accessedAt?: Date | string
    expiresAt: Date | string
  }

  export type MedicalStaffCreateManyInstitutionInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.StaffRole
    license?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type EmergencyAccessUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessorId?: NullableStringFieldUpdateOperationsInput | string | null
    accessorName?: StringFieldUpdateOperationsInput | string
    accessorRole?: StringFieldUpdateOperationsInput | string
    accessorLicense?: NullableStringFieldUpdateOperationsInput | string | null
    institutionName?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNo?: NullableStringFieldUpdateOperationsInput | string | null
    qrTokenUsed?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    dataAccessed?: EmergencyAccessUpdatedataAccessedInput | string[]
    representativesNotified?: EmergencyAccessUpdaterepresentativesNotifiedInput | string[]
    notificationsSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: UserUpdateOneRequiredWithoutEmergencyAccessesNestedInput
    insurance?: InsuranceCompanyUpdateOneWithoutEmergencyAccessesNestedInput
  }

  export type EmergencyAccessUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    accessorId?: NullableStringFieldUpdateOperationsInput | string | null
    accessorName?: StringFieldUpdateOperationsInput | string
    accessorRole?: StringFieldUpdateOperationsInput | string
    accessorLicense?: NullableStringFieldUpdateOperationsInput | string | null
    institutionName?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNo?: NullableStringFieldUpdateOperationsInput | string | null
    qrTokenUsed?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    dataAccessed?: EmergencyAccessUpdatedataAccessedInput | string[]
    representativesNotified?: EmergencyAccessUpdaterepresentativesNotifiedInput | string[]
    notificationsSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyAccessUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    accessorId?: NullableStringFieldUpdateOperationsInput | string | null
    accessorName?: StringFieldUpdateOperationsInput | string
    accessorRole?: StringFieldUpdateOperationsInput | string
    accessorLicense?: NullableStringFieldUpdateOperationsInput | string | null
    institutionName?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNo?: NullableStringFieldUpdateOperationsInput | string | null
    qrTokenUsed?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    dataAccessed?: EmergencyAccessUpdatedataAccessedInput | string[]
    representativesNotified?: EmergencyAccessUpdaterepresentativesNotifiedInput | string[]
    notificationsSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalStaffUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    license?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MedicalStaffUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    license?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MedicalStaffUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    license?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InsuranceCompanyUpdateWithoutNetworkHospitalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType
    cnsfNumber?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    coverageTypes?: InsuranceCompanyUpdatecoverageTypesInput | string[]
    networkSize?: NullableIntFieldUpdateOperationsInput | number | null
    hasNationalCoverage?: BoolFieldUpdateOperationsInput | boolean
    statesCovered?: InsuranceCompanyUpdatestatesCoveredInput | string[]
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    apiEnabled?: BoolFieldUpdateOperationsInput | boolean
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plans?: InsurancePlanUpdateManyWithoutInsuranceNestedInput
    emergencyAccesses?: EmergencyAccessUpdateManyWithoutInsuranceNestedInput
  }

  export type InsuranceCompanyUncheckedUpdateWithoutNetworkHospitalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType
    cnsfNumber?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    coverageTypes?: InsuranceCompanyUpdatecoverageTypesInput | string[]
    networkSize?: NullableIntFieldUpdateOperationsInput | number | null
    hasNationalCoverage?: BoolFieldUpdateOperationsInput | boolean
    statesCovered?: InsuranceCompanyUpdatestatesCoveredInput | string[]
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    apiEnabled?: BoolFieldUpdateOperationsInput | boolean
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plans?: InsurancePlanUncheckedUpdateManyWithoutInsuranceNestedInput
    emergencyAccesses?: EmergencyAccessUncheckedUpdateManyWithoutInsuranceNestedInput
  }

  export type InsuranceCompanyUncheckedUpdateManyWithoutNetworkHospitalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType
    cnsfNumber?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    coverageTypes?: InsuranceCompanyUpdatecoverageTypesInput | string[]
    networkSize?: NullableIntFieldUpdateOperationsInput | number | null
    hasNationalCoverage?: BoolFieldUpdateOperationsInput | boolean
    statesCovered?: InsuranceCompanyUpdatestatesCoveredInput | string[]
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    apiEnabled?: BoolFieldUpdateOperationsInput | boolean
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsurancePlanCreateManyInsuranceInput = {
    id?: string
    name: string
    code?: string | null
    sumAssured?: number | null
    deductible?: number | null
    coinsurance?: number | null
    features?: InsurancePlanCreatefeaturesInput | string[]
    exclusions?: InsurancePlanCreateexclusionsInput | string[]
    hospitalLevel?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmergencyAccessCreateManyInsuranceInput = {
    id?: string
    patientId: string
    accessorId?: string | null
    accessorName: string
    accessorRole: string
    accessorLicense?: string | null
    institutionId?: string | null
    institutionName?: string | null
    insurancePolicyNo?: string | null
    qrTokenUsed: string
    ipAddress?: string | null
    userAgent?: string | null
    latitude?: number | null
    longitude?: number | null
    locationName?: string | null
    dataAccessed?: EmergencyAccessCreatedataAccessedInput | string[]
    representativesNotified?: EmergencyAccessCreaterepresentativesNotifiedInput | string[]
    notificationsSentAt?: Date | string | null
    accessToken?: string
    accessedAt?: Date | string
    expiresAt: Date | string
  }

  export type InsurancePlanUpdateWithoutInsuranceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sumAssured?: NullableFloatFieldUpdateOperationsInput | number | null
    deductible?: NullableFloatFieldUpdateOperationsInput | number | null
    coinsurance?: NullableFloatFieldUpdateOperationsInput | number | null
    features?: InsurancePlanUpdatefeaturesInput | string[]
    exclusions?: InsurancePlanUpdateexclusionsInput | string[]
    hospitalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsurancePlanUncheckedUpdateWithoutInsuranceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sumAssured?: NullableFloatFieldUpdateOperationsInput | number | null
    deductible?: NullableFloatFieldUpdateOperationsInput | number | null
    coinsurance?: NullableFloatFieldUpdateOperationsInput | number | null
    features?: InsurancePlanUpdatefeaturesInput | string[]
    exclusions?: InsurancePlanUpdateexclusionsInput | string[]
    hospitalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsurancePlanUncheckedUpdateManyWithoutInsuranceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sumAssured?: NullableFloatFieldUpdateOperationsInput | number | null
    deductible?: NullableFloatFieldUpdateOperationsInput | number | null
    coinsurance?: NullableFloatFieldUpdateOperationsInput | number | null
    features?: InsurancePlanUpdatefeaturesInput | string[]
    exclusions?: InsurancePlanUpdateexclusionsInput | string[]
    hospitalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalInstitutionUpdateWithoutInsuranceNetworksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    cluesCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    attentionLevel?: NullableEnumAttentionLevelFieldUpdateOperationsInput | $Enums.AttentionLevel | null
    specialties?: MedicalInstitutionUpdatespecialtiesInput | string[]
    hasEmergency?: BoolFieldUpdateOperationsInput | boolean
    has24Hours?: BoolFieldUpdateOperationsInput | boolean
    hasICU?: BoolFieldUpdateOperationsInput | boolean
    hasTrauma?: BoolFieldUpdateOperationsInput | boolean
    oauthClientId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emergencyAccesses?: EmergencyAccessUpdateManyWithoutInstitutionNestedInput
    staff?: MedicalStaffUpdateManyWithoutInstitutionNestedInput
  }

  export type MedicalInstitutionUncheckedUpdateWithoutInsuranceNetworksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    cluesCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    attentionLevel?: NullableEnumAttentionLevelFieldUpdateOperationsInput | $Enums.AttentionLevel | null
    specialties?: MedicalInstitutionUpdatespecialtiesInput | string[]
    hasEmergency?: BoolFieldUpdateOperationsInput | boolean
    has24Hours?: BoolFieldUpdateOperationsInput | boolean
    hasICU?: BoolFieldUpdateOperationsInput | boolean
    hasTrauma?: BoolFieldUpdateOperationsInput | boolean
    oauthClientId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emergencyAccesses?: EmergencyAccessUncheckedUpdateManyWithoutInstitutionNestedInput
    staff?: MedicalStaffUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type MedicalInstitutionUncheckedUpdateManyWithoutInsuranceNetworksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    cluesCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    attentionLevel?: NullableEnumAttentionLevelFieldUpdateOperationsInput | $Enums.AttentionLevel | null
    specialties?: MedicalInstitutionUpdatespecialtiesInput | string[]
    hasEmergency?: BoolFieldUpdateOperationsInput | boolean
    has24Hours?: BoolFieldUpdateOperationsInput | boolean
    hasICU?: BoolFieldUpdateOperationsInput | boolean
    hasTrauma?: BoolFieldUpdateOperationsInput | boolean
    oauthClientId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyAccessUpdateWithoutInsuranceInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessorId?: NullableStringFieldUpdateOperationsInput | string | null
    accessorName?: StringFieldUpdateOperationsInput | string
    accessorRole?: StringFieldUpdateOperationsInput | string
    accessorLicense?: NullableStringFieldUpdateOperationsInput | string | null
    institutionName?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNo?: NullableStringFieldUpdateOperationsInput | string | null
    qrTokenUsed?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    dataAccessed?: EmergencyAccessUpdatedataAccessedInput | string[]
    representativesNotified?: EmergencyAccessUpdaterepresentativesNotifiedInput | string[]
    notificationsSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: UserUpdateOneRequiredWithoutEmergencyAccessesNestedInput
    institution?: MedicalInstitutionUpdateOneWithoutEmergencyAccessesNestedInput
  }

  export type EmergencyAccessUncheckedUpdateWithoutInsuranceInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    accessorId?: NullableStringFieldUpdateOperationsInput | string | null
    accessorName?: StringFieldUpdateOperationsInput | string
    accessorRole?: StringFieldUpdateOperationsInput | string
    accessorLicense?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionName?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNo?: NullableStringFieldUpdateOperationsInput | string | null
    qrTokenUsed?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    dataAccessed?: EmergencyAccessUpdatedataAccessedInput | string[]
    representativesNotified?: EmergencyAccessUpdaterepresentativesNotifiedInput | string[]
    notificationsSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyAccessUncheckedUpdateManyWithoutInsuranceInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    accessorId?: NullableStringFieldUpdateOperationsInput | string | null
    accessorName?: StringFieldUpdateOperationsInput | string
    accessorRole?: StringFieldUpdateOperationsInput | string
    accessorLicense?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionName?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNo?: NullableStringFieldUpdateOperationsInput | string | null
    qrTokenUsed?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    dataAccessed?: EmergencyAccessUpdatedataAccessedInput | string[]
    representativesNotified?: EmergencyAccessUpdaterepresentativesNotifiedInput | string[]
    notificationsSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessToken?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSessionCreateManyAdminInput = {
    id?: string
    refreshToken: string
    userAgent?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type AdminAuditLogCreateManyAdminInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AdminSessionUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSessionUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSessionUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyPlanInput = {
    id?: string
    userId: string
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    billingCycle?: $Enums.BillingCycle
    status?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
    payments?: PaymentUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManySubscriptionInput = {
    id?: string
    userId: string
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    stripeInvoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod: $Enums.PaymentMethodType
    last4?: string | null
    cardBrand?: string | null
    oxxoVoucherUrl?: string | null
    oxxoExpiresAt?: Date | string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    failureCode?: string | null
    failureMessage?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    oxxoVoucherUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oxxoExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    failureCode?: NullableStringFieldUpdateOperationsInput | string | null
    failureMessage?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    invoice?: InvoiceUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    oxxoVoucherUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oxxoExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    failureCode?: NullableStringFieldUpdateOperationsInput | string | null
    failureMessage?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    oxxoVoucherUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oxxoExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    failureCode?: NullableStringFieldUpdateOperationsInput | string | null
    failureMessage?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyFiscalDataInput = {
    id?: string
    userId: string
    paymentId: string
    facturamaInvoiceId?: string | null
    uuid?: string | null
    serie?: string | null
    folio?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    xmlUrl?: string | null
    pdfUrl?: string | null
    status?: $Enums.InvoiceStatus
    issuedAt?: Date | string | null
    cancelledAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateWithoutFiscalDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    facturamaInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableStringFieldUpdateOperationsInput | string | null
    folio?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    xmlUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    payment?: PaymentUpdateOneRequiredWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutFiscalDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    facturamaInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableStringFieldUpdateOperationsInput | string | null
    folio?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    xmlUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyWithoutFiscalDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    facturamaInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableStringFieldUpdateOperationsInput | string | null
    folio?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    xmlUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdvanceDirectiveCountOutputTypeDefaultArgs instead
     */
    export type AdvanceDirectiveCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdvanceDirectiveCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MedicalInstitutionCountOutputTypeDefaultArgs instead
     */
    export type MedicalInstitutionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MedicalInstitutionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InsuranceCompanyCountOutputTypeDefaultArgs instead
     */
    export type InsuranceCompanyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InsuranceCompanyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminUserCountOutputTypeDefaultArgs instead
     */
    export type AdminUserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminUserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionPlanCountOutputTypeDefaultArgs instead
     */
    export type SubscriptionPlanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionCountOutputTypeDefaultArgs instead
     */
    export type SubscriptionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FiscalDataCountOutputTypeDefaultArgs instead
     */
    export type FiscalDataCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FiscalDataCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WebAuthnCredentialDefaultArgs instead
     */
    export type WebAuthnCredentialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WebAuthnCredentialDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientProfileDefaultArgs instead
     */
    export type PatientProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RepresentativeDefaultArgs instead
     */
    export type RepresentativeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RepresentativeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdvanceDirectiveDefaultArgs instead
     */
    export type AdvanceDirectiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdvanceDirectiveDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WitnessDefaultArgs instead
     */
    export type WitnessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WitnessDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmergencyAccessDefaultArgs instead
     */
    export type EmergencyAccessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmergencyAccessDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MedicalInstitutionDefaultArgs instead
     */
    export type MedicalInstitutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MedicalInstitutionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InsuranceCompanyDefaultArgs instead
     */
    export type InsuranceCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InsuranceCompanyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InsurancePlanDefaultArgs instead
     */
    export type InsurancePlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InsurancePlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MedicalStaffDefaultArgs instead
     */
    export type MedicalStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MedicalStaffDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StateLegalTemplateDefaultArgs instead
     */
    export type StateLegalTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StateLegalTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PanicAlertDefaultArgs instead
     */
    export type PanicAlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PanicAlertDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminUserDefaultArgs instead
     */
    export type AdminUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminSessionDefaultArgs instead
     */
    export type AdminSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminAuditLogDefaultArgs instead
     */
    export type AdminAuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminAuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionPlanDefaultArgs instead
     */
    export type SubscriptionPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionDefaultArgs instead
     */
    export type SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentMethodDefaultArgs instead
     */
    export type PaymentMethodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentMethodDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FiscalDataDefaultArgs instead
     */
    export type FiscalDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FiscalDataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceDefaultArgs instead
     */
    export type InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}