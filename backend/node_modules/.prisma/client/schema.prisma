// Sistema VIDA - Schema de Base de Datos
// Prisma Schema para PostgreSQL

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==================== USUARIOS ====================

model User {
  id           String    @id @default(uuid())
  email        String    @unique
  passwordHash String
  curp         String    @unique
  name         String
  dateOfBirth  DateTime?
  sex          String? // H/M
  phone        String?
  address      String?

  // Estado de la cuenta
  isActive            Boolean   @default(true)
  isVerified          Boolean   @default(false)
  verificationToken   String?
  verificationExpires DateTime?

  // Recuperación de contraseña
  resetToken   String?
  resetExpires DateTime?

  // WebAuthn challenge temporal
  webauthnChallenge String?

  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  lastLoginAt DateTime?

  // Relaciones
  profile             PatientProfile?
  directives          AdvanceDirective[]
  representatives     Representative[]
  emergencyAccesses   EmergencyAccess[]    @relation("PatientAccesses")
  panicAlerts         PanicAlert[]
  auditLogs           AuditLog[]
  sessions            Session[]
  webauthnCredentials WebAuthnCredential[]

  // Relaciones de pagos y suscripciones
  subscription   Subscription?
  payments       Payment[]
  paymentMethods PaymentMethod[]
  fiscalData     FiscalData?
  invoices       Invoice[]

  @@index([curp])
  @@index([email])
  @@index([isActive])
}

model Session {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  refreshToken String  @unique
  userAgent    String?
  ipAddress    String?

  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([refreshToken])
}

// ==================== WEBAUTHN / BIOMETRÍA ====================

model WebAuthnCredential {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Credencial WebAuthn
  credentialId        String @unique // Base64URL encoded
  credentialPublicKey Bytes // Public key in COSE format
  counter             BigInt @default(0)

  // Metadatos del dispositivo
  deviceType String? // "platform" (Face ID) or "cross-platform" (security key)
  deviceName String? // Nombre amigable: "iPhone de Juan", "MacBook Pro"
  transports String[] // ["internal", "usb", "ble", "nfc"]

  // Timestamps
  createdAt  DateTime  @default(now())
  lastUsedAt DateTime?

  @@index([userId])
  @@index([credentialId])
}

// ==================== PERFIL DEL PACIENTE (PUP) ====================

model PatientProfile {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Datos médicos críticos (almacenados cifrados)
  bloodType      String?
  allergiesEnc   String? // JSON cifrado: ["Penicilina", "Mariscos"]
  conditionsEnc  String? // JSON cifrado: ["Diabetes", "Hipertensión"]
  medicationsEnc String? // JSON cifrado: ["Metformina 500mg"]

  // Datos de seguro médico
  insuranceProvider String?
  insurancePolicy   String?
  insurancePhone    String?

  // Foto de perfil (URL en S3 o base64)
  photoUrl String?

  // Donación de órganos
  isDonor             Boolean @default(false)
  donorPreferencesEnc String? // JSON cifrado con preferencias granulares
  donorVideoUrl       String? // Testimonio personal en video

  // QR único para acceso de emergencia
  qrToken       String   @unique @default(uuid())
  qrGeneratedAt DateTime @default(now())

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([qrToken])
}

// ==================== REPRESENTANTES ====================

model Representative {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  name     String
  phone    String
  email    String?
  relation String // Esposo/a, Hijo/a, Hermano/a, etc.
  priority Int     @default(1) // 1 = primario, 2+ = suplentes

  // Para portavoz de donación
  isDonorSpokesperson Boolean @default(false)

  // Notificaciones
  notifyOnEmergency Boolean @default(true)
  notifyOnAccess    Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([priority])
}

// ==================== DIRECTIVAS DE VOLUNTAD ANTICIPADA ====================

model AdvanceDirective {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Tipo y estado
  type   DirectiveType
  status DirectiveStatus @default(DRAFT)

  // Documento PDF (para documentos notarizados subidos)
  documentUrl      String?
  documentHash     String? // SHA-256 para verificación de integridad
  originalFileName String?

  // Constancia NOM-151
  nom151Sealed      Boolean   @default(false)
  nom151Timestamp   DateTime?
  nom151Certificate String?   @db.Text
  nom151Provider    String?

  // Contenido del borrador digital
  acceptsCPR                 Boolean?
  acceptsIntubation          Boolean?
  acceptsDialysis            Boolean?
  acceptsTransfusion         Boolean?
  acceptsArtificialNutrition Boolean?
  palliativeCareOnly         Boolean?
  additionalNotes            String?  @db.Text

  // Estado jurídico del documento (para el armonizador legal)
  originState       String? // CDMX, Jalisco, etc.
  legalBasisSummary String? @db.Text

  // Validación
  validatedAt      DateTime?
  validatedBy      String?
  validationMethod String? // EMAIL, SMS, WITNESS

  // Timestamps
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  revokedAt DateTime?
  expiresAt DateTime?

  // Relaciones
  witnesses Witness[]

  @@index([userId])
  @@index([status])
  @@index([type])
}

enum DirectiveType {
  NOTARIZED_DOCUMENT // Documento notariado existente (PDF)
  DIGITAL_DRAFT // Borrador creado en app (sin validación legal completa)
  DIGITAL_WITNESSED // Formato con testigos digitales (Fase 2)
}

enum DirectiveStatus {
  DRAFT // Borrador en proceso
  PENDING_VALIDATION // Esperando validación
  ACTIVE // Activo y válido
  REVOKED // Revocado por el usuario
  EXPIRED // Expirado
}

// ==================== TESTIGOS (FASE 2) ====================

model Witness {
  id          String           @id @default(uuid())
  directiveId String
  directive   AdvanceDirective @relation(fields: [directiveId], references: [id], onDelete: Cascade)

  name  String
  curp  String?
  email String?
  phone String?

  // Verificación de identidad
  ineImageUrl      String?
  selfieImageUrl   String?
  identityVerified Boolean   @default(false)
  verifiedAt       DateTime?

  // Firma digital
  signatureImageUrl String?
  signedAt          DateTime?

  // Sesión de testificación (videoconferencia)
  sessionId           String?
  sessionRecordingUrl String?
  sessionStartedAt    DateTime?
  sessionEndedAt      DateTime?

  createdAt DateTime @default(now())

  @@index([directiveId])
}

// ==================== ACCESO DE EMERGENCIA (PAE) ====================

model EmergencyAccess {
  id String @id @default(uuid())

  // Paciente
  patientId String
  patient   User   @relation("PatientAccesses", fields: [patientId], references: [id])

  // Profesional que accede
  accessorId      String? // ID si está registrado
  accessorName    String
  accessorRole    String // Paramédico, Médico Urgencias, etc.
  accessorLicense String? // Cédula profesional
  institutionId   String?
  institution     MedicalInstitution? @relation(fields: [institutionId], references: [id])
  institutionName String?

  // Aseguradora (si aplica)
  insuranceId       String?
  insurance         InsuranceCompany? @relation("InsuranceEmergencyAccess", fields: [insuranceId], references: [id])
  insurancePolicyNo String? // Número de póliza del paciente

  // Contexto del acceso
  qrTokenUsed  String
  ipAddress    String?
  userAgent    String?
  latitude     Float?
  longitude    Float?
  locationName String?

  // Datos accedidos (para auditoría)
  dataAccessed String[] // ["profile", "allergies", "directives", etc.]

  // Notificaciones enviadas
  representativesNotified String[] // IDs de representantes notificados
  notificationsSentAt     DateTime?

  // Token de sesión temporal
  accessToken String   @unique @default(uuid())
  accessedAt  DateTime @default(now())
  expiresAt   DateTime // Típicamente 60 minutos después

  @@index([patientId])
  @@index([accessedAt])
  @@index([accessToken])
  @@index([qrTokenUsed])
}

// ==================== INSTITUCIONES MÉDICAS ====================

model MedicalInstitution {
  id        String          @id @default(uuid())
  name      String
  type      InstitutionType
  cluesCode String?         @unique // Clave CLUES de la DGIS

  // Ubicación
  address   String?
  city      String?
  state     String?
  zipCode   String?
  latitude  Float?
  longitude Float?

  // Contacto
  phone          String?
  emergencyPhone String?
  email          String?

  // Nivel de atención (CLUES)
  attentionLevel AttentionLevel? // Primer, segundo o tercer nivel

  // Especialidades disponibles
  specialties String[] // ["Urgencias", "Cardiologia", "Traumatologia", etc.]

  // Servicios de emergencia
  hasEmergency Boolean @default(true) // Tiene servicio de urgencias
  has24Hours   Boolean @default(false) // Atención 24 horas
  hasICU       Boolean @default(false) // Unidad de Cuidados Intensivos
  hasTrauma    Boolean @default(false) // Atención de trauma

  // Credenciales OAuth para PAE
  oauthClientId     String? @unique
  oauthClientSecret String? // Hash del secret

  // Estado
  isActive   Boolean   @default(true)
  isVerified Boolean   @default(false)
  verifiedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relaciones
  emergencyAccesses EmergencyAccess[]
  staff             MedicalStaff[]
  insuranceNetworks InsuranceCompany[] @relation("InsuranceNetwork")

  @@index([cluesCode])
  @@index([type])
  @@index([state])
  @@index([attentionLevel])
}

enum AttentionLevel {
  FIRST // Primer nivel - Atención primaria, consulta general
  SECOND // Segundo nivel - Hospitales generales, especialidades básicas
  THIRD // Tercer nivel - Alta especialidad, hospitales de referencia
}

enum InstitutionType {
  HOSPITAL_PUBLIC
  HOSPITAL_PRIVATE
  CLINIC
  AMBULANCE_SERVICE
  IMSS
  ISSSTE
  OTHER
}

// ==================== ASEGURADORAS ====================

model InsuranceCompany {
  id        String        @id @default(uuid())
  name      String
  shortName String? // Nombre corto o siglas (ej: "GNP", "AXA")
  type      InsuranceType

  // Registro oficial
  cnsfNumber String? @unique // Número de registro CNSF
  rfc        String? @unique // RFC de la empresa

  // Contacto corporativo
  address        String?
  city           String?
  state          String?
  zipCode        String?
  phone          String?
  emergencyPhone String? // Línea de emergencias 24h
  email          String?
  website        String?

  // Cobertura
  coverageTypes       String[] // ["Gastos Médicos Mayores", "Vida", "Accidentes", etc.]
  networkSize         Int? // Número de hospitales en red
  hasNationalCoverage Boolean  @default(false)
  statesCovered       String[] // Estados donde opera

  // Planes disponibles
  plans InsurancePlan[]

  // Red de hospitales asociados
  networkHospitals MedicalInstitution[] @relation("InsuranceNetwork")

  // Verificación
  isVerified Boolean   @default(false)
  verifiedAt DateTime?
  verifiedBy String?

  // Integración API (para verificación automática de pólizas)
  apiEnabled  Boolean @default(false)
  apiEndpoint String?

  // Metadatos
  logoUrl     String?
  description String?
  isActive    Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relaciones
  emergencyAccesses EmergencyAccess[] @relation("InsuranceEmergencyAccess")

  @@index([type])
  @@index([state])
  @@index([isVerified])
}

enum InsuranceType {
  HEALTH // Gastos médicos mayores
  LIFE // Seguro de vida
  ACCIDENT // Accidentes personales
  HEALTH_LIFE // Combinado salud y vida
  GOVERNMENT // Seguro Popular, INSABI, etc.
  OTHER
}

model InsurancePlan {
  id          String           @id @default(uuid())
  insuranceId String
  insurance   InsuranceCompany @relation(fields: [insuranceId], references: [id], onDelete: Cascade)

  name String // "Plan Platinum", "Cobertura Básica", etc.
  code String? // Código interno del plan

  // Cobertura
  sumAssured  Float? // Suma asegurada
  deductible  Float? // Deducible
  coinsurance Float? // Coaseguro (porcentaje)

  // Características
  features   String[] // ["Cobertura internacional", "Maternidad", etc.]
  exclusions String[] // Exclusiones principales

  // Hospitales
  hospitalLevel String? // "Red Amplia", "Red Selecta", etc.

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([insuranceId])
}

model MedicalStaff {
  id            String             @id @default(uuid())
  institutionId String
  institution   MedicalInstitution @relation(fields: [institutionId], references: [id], onDelete: Cascade)

  name         String
  email        String    @unique
  passwordHash String
  role         StaffRole
  license      String? // Cédula profesional

  isActive Boolean @default(true)

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  lastLoginAt DateTime?

  @@index([institutionId])
  @@index([email])
}

enum StaffRole {
  ADMIN // Administrador de la institución
  DOCTOR // Médico
  PARAMEDIC // Paramédico
  NURSE // Enfermero/a
  EMERGENCY_TECH // Técnico en emergencias
}

// ==================== AUDITORÍA ====================

model AuditLog {
  id String @id @default(uuid())

  // Actor
  userId    String?
  user      User?   @relation(fields: [userId], references: [id])
  actorType String // USER, STAFF, SYSTEM
  actorId   String?
  actorName String?

  // Acción
  action     String // CREATE, READ, UPDATE, DELETE, LOGIN, etc.
  resource   String // users, profiles, directives, etc.
  resourceId String?

  // Detalles
  details  Json?
  oldValue Json?
  newValue Json?

  // Contexto
  ipAddress String?
  userAgent String?

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([action])
  @@index([resource])
  @@index([createdAt])
}

// ==================== PLANTILLAS LEGALES POR ESTADO ====================

model StateLegalTemplate {
  id        String @id @default(uuid())
  stateCode String @unique // CDMX, JAL, NL, etc.
  stateName String

  // Información de la ley
  lawName    String
  lawDate    DateTime?
  lawSummary String?   @db.Text

  // Plantilla del documento
  templateHtml   String? @db.Text
  templateFields Json? // Campos requeridos por el estado

  // Requisitos
  requiresNotary      Boolean @default(true)
  requiresWitnesses   Int     @default(2)
  requiresMedicalCert Boolean @default(false)

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([stateCode])
}

// ==================== NOTIFICACIONES ====================

model Notification {
  id String @id @default(uuid())

  // Destinatario
  userId String?
  email  String?
  phone  String?

  // Contenido
  type    NotificationType
  channel NotificationChannel
  subject String?
  body    String              @db.Text

  // Estado
  status       NotificationStatus @default(PENDING)
  sentAt       DateTime?
  deliveredAt  DateTime?
  failedAt     DateTime?
  errorMessage String?

  // Metadata
  metadata Json?

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([status])
  @@index([type])
}

enum NotificationType {
  VERIFICATION_EMAIL
  VERIFICATION_SMS
  PASSWORD_RESET
  EMERGENCY_ALERT
  ACCESS_NOTIFICATION
  DIRECTIVE_REMINDER
  SYSTEM_ALERT
}

enum NotificationChannel {
  EMAIL
  SMS
  PUSH
}

enum NotificationStatus {
  PENDING
  SENT
  DELIVERED
  FAILED
}

// ==================== ALERTAS DE PANICO ====================

model PanicAlert {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Ubicacion
  latitude     Float
  longitude    Float
  accuracy     Float?
  locationName String?

  // Estado
  status  PanicStatus @default(ACTIVE)
  message String?

  // Timestamps
  cancelledAt DateTime?
  resolvedAt  DateTime?

  // Datos de respuesta
  nearbyHospitals   Json? // Array de hospitales cercanos al momento de la alerta
  notificationsSent Json? // Resumen de notificaciones enviadas

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

enum PanicStatus {
  ACTIVE // Alerta activa
  CANCELLED // Cancelada por el usuario
  RESOLVED // Resuelta (atendida)
  EXPIRED // Expirada automaticamente (24h)
}

// ==================== ADMINISTRADORES DEL SISTEMA ====================

model AdminUser {
  id           String    @id @default(uuid())
  email        String    @unique
  passwordHash String
  name         String
  role         AdminRole @default(VIEWER)
  permissions  String[] // ['metrics:read', 'users:write', etc.]

  isActive     Boolean @default(true)
  isSuperAdmin Boolean @default(false)

  // Seguridad
  lastLoginAt    DateTime?
  lastLoginIp    String?
  failedAttempts Int       @default(0)
  lockedUntil    DateTime?

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String? // ID del admin que lo creo

  // Relaciones
  sessions     AdminSession[]
  auditActions AdminAuditLog[]

  @@index([email])
  @@index([role])
}

enum AdminRole {
  SUPER_ADMIN // Acceso total al sistema
  ADMIN // Gestion completa de usuarios e instituciones
  MODERATOR // Gestion limitada, solo lectura de auditoria
  VIEWER // Solo lectura de metricas
  SUPPORT // Soporte tecnico, acceso a logs
}

model AdminSession {
  id      String    @id @default(uuid())
  adminId String
  admin   AdminUser @relation(fields: [adminId], references: [id], onDelete: Cascade)

  refreshToken String  @unique
  userAgent    String?
  ipAddress    String?

  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([adminId])
  @@index([refreshToken])
}

// Auditoria de acciones de administradores
model AdminAuditLog {
  id String @id @default(uuid())

  adminId String
  admin   AdminUser @relation(fields: [adminId], references: [id])

  action     String // LOGIN, VIEW_USER, DEACTIVATE_USER, VIEW_AUDIT, EXPORT_DATA
  resource   String // users, audit_logs, institutions, metrics
  resourceId String?

  details  Json?
  oldValue Json?
  newValue Json?

  ipAddress String?
  userAgent String?

  createdAt DateTime @default(now())

  @@index([adminId])
  @@index([action])
  @@index([resource])
  @@index([createdAt])
}

// ==================== SUSCRIPCIONES Y PLANES ====================

model SubscriptionPlan {
  id                   String   @id @default(uuid())
  name                 String // "Plan Gratuito", "Plan Premium"
  slug                 String   @unique // "free", "premium-monthly", "premium-annual"
  description          String?  @db.Text
  priceMonthly         Decimal? @db.Decimal(10, 2)
  priceAnnual          Decimal? @db.Decimal(10, 2)
  currency             String   @default("MXN")
  stripePriceIdMonthly String?
  stripePriceIdAnnual  String?
  stripeProductId      String?
  features             Json // { "advanceDirectives": true, "smsNotifications": true, ... }
  limits               Json // { "representativesLimit": 2, "qrDownloadsPerMonth": 3, ... }
  trialDays            Int      @default(0)
  isActive             Boolean  @default(true)
  isDefault            Boolean  @default(false) // Plan por defecto para nuevos usuarios
  displayOrder         Int      @default(0)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  // Relaciones
  subscriptions Subscription[]

  @@index([slug])
  @@index([isActive])
}

model Subscription {
  id                   String             @id @default(uuid())
  userId               String             @unique
  user                 User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  planId               String
  plan                 SubscriptionPlan   @relation(fields: [planId], references: [id])
  stripeSubscriptionId String?            @unique
  stripeCustomerId     String?
  billingCycle         BillingCycle       @default(MONTHLY)
  status               SubscriptionStatus @default(ACTIVE)
  trialEndsAt          DateTime?
  currentPeriodStart   DateTime
  currentPeriodEnd     DateTime
  cancelAtPeriodEnd    Boolean            @default(false)
  cancelledAt          DateTime?
  cancelReason         String?
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt

  // Relaciones
  payments Payment[]

  @@index([status])
  @@index([stripeCustomerId])
}

enum BillingCycle {
  MONTHLY
  ANNUAL
}

enum SubscriptionStatus {
  ACTIVE // Suscripción activa
  TRIALING // En periodo de prueba
  PAST_DUE // Pago vencido
  CANCELED // Cancelada
  UNPAID // Sin pago
  INCOMPLETE // Incompleta (esperando primer pago)
  PAUSED // Pausada
}

// ==================== PAGOS ====================

model Payment {
  id                    String            @id @default(uuid())
  userId                String
  user                  User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  subscriptionId        String?
  subscription          Subscription?     @relation(fields: [subscriptionId], references: [id])
  stripePaymentIntentId String?           @unique
  stripeChargeId        String?
  stripeInvoiceId       String?
  amount                Decimal           @db.Decimal(10, 2)
  currency              String            @default("MXN")
  paymentMethod         PaymentMethodType
  last4                 String?
  cardBrand             String?
  oxxoVoucherUrl        String? // URL del voucher para pago en OXXO
  oxxoExpiresAt         DateTime? // Fecha límite para pago en OXXO
  status                PaymentStatus     @default(PENDING)
  description           String?
  failureCode           String?
  failureMessage        String?
  paidAt                DateTime?
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt

  // Relaciones
  invoice Invoice?

  @@index([userId])
  @@index([status])
  @@index([stripePaymentIntentId])
}

enum PaymentMethodType {
  CARD
  OXXO
}

enum PaymentStatus {
  PENDING // Pendiente
  PROCESSING // Procesando
  REQUIRES_ACTION // Requiere acción (3D Secure, OXXO voucher)
  SUCCEEDED // Exitoso
  FAILED // Fallido
  CANCELED // Cancelado
  REFUNDED // Reembolsado
}

model PaymentMethod {
  id                    String            @id @default(uuid())
  userId                String
  user                  User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  stripePaymentMethodId String            @unique
  type                  PaymentMethodType @default(CARD)
  last4                 String
  brand                 String
  expMonth              Int
  expYear               Int
  cardholderName        String?
  isDefault             Boolean           @default(false)
  isActive              Boolean           @default(true)
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt

  @@index([userId])
}

// ==================== FACTURACION CFDI ====================

model FiscalData {
  id                String   @id @default(uuid())
  userId            String   @unique
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  rfc               String
  razonSocial       String
  regimenFiscal     String // Código SAT: "601", "612", etc.
  usoCFDI           String   @default("G03") // Gastos en general
  codigoPostal      String
  calle             String?
  numExterior       String?
  numInterior       String?
  colonia           String?
  municipio         String?
  estado            String?
  emailFacturacion  String
  facturamaClientId String? // ID del cliente en Facturama
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relaciones
  invoices Invoice[]

  @@index([rfc])
  @@index([userId])
}

model Invoice {
  id                 String        @id @default(uuid())
  userId             String
  user               User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  paymentId          String        @unique
  payment            Payment       @relation(fields: [paymentId], references: [id])
  fiscalDataId       String?
  fiscalData         FiscalData?   @relation(fields: [fiscalDataId], references: [id])
  facturamaInvoiceId String?       @unique // ID en Facturama
  uuid               String?       @unique // UUID del CFDI (folio fiscal)
  serie              String?
  folio              String?
  subtotal           Decimal       @db.Decimal(10, 2)
  iva                Decimal       @db.Decimal(10, 2)
  total              Decimal       @db.Decimal(10, 2)
  xmlUrl             String? // URL del archivo XML
  pdfUrl             String? // URL del archivo PDF
  status             InvoiceStatus @default(PENDING)
  issuedAt           DateTime?
  cancelledAt        DateTime?
  errorMessage       String?
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt

  @@index([userId])
  @@index([uuid])
  @@index([status])
}

enum InvoiceStatus {
  PENDING // Pendiente de timbrar
  ISSUED // Timbrada/Emitida
  SENT // Enviada al cliente
  CANCELLED // Cancelada
  ERROR // Error al timbrar
}
